{"searchDocs":[{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/1.1.0/","content":"","keywords":"javascript  jspsych","version":"1.1.0"},{"title":"Flexible deployment online and in the lab​","type":1,"pageTitle":"Introduction","url":"/docs/1.1.0/#flexible-deployment-online-and-in-the-lab","content":"Honeycomb provides the ability to write one codebase and use it flexibly across settings (with guaranteed consistency in instructions, timing, etc.). The same code-base is used to maintain and deploy the identical task on Mechanical Turk, Prolific, and in research settings during concurrent electrophysiological recordings. ","version":"1.1.0","tagName":"h3"},{"title":"Easy to install executables​","type":1,"pageTitle":"Introduction","url":"/docs/1.1.0/#easy-to-install-executables","content":"Deployment specifications are abstracted as parameters that are easy to configure, and application building is automated via GitHub actions providing continuous delivery of easy-to-download executables, easing setup burden across research sites. ","version":"1.1.0","tagName":"h3"},{"title":"Foundation in jsPsych​","type":1,"pageTitle":"Introduction","url":"/docs/1.1.0/#foundation-in-jspsych","content":"jsPsych tasks can be converted to the Honeycomb structure to take advantage of the flexible deployment and automated GitHub Actions workflow that Honeycomb provides. ","version":"1.1.0","tagName":"h3"},{"title":"Configuration","type":0,"sectionRef":"#","url":"/docs/1.1.0/configuration","content":"","keywords":"javascript  jspsych","version":"1.1.0"},{"title":"Environment Variables​","type":1,"pageTitle":"Configuration","url":"/docs/1.1.0/configuration#environment-variables","content":"Honeycomb uses environment variables during build and run time to control the different configurations. Below we list the environment variables used by the app and indicate whether they are mandatory, optional and needed during build (npm build) or run time (using the application executable or npm run dev) ELECTRON_START_URL : URL (e.g. http://localhost:3000) where the front end of the app is being hosted - also used in electron.js to indicate the app is running in dev modeEVENT_MARKER_PRODUCT_ID: The product ID of the event marker (e.g. 0487). If not set, it will use the productID set in public/config/trigger.js if available, or attempt to connect using the com name.EVENT_MARKER_COM_NAME : The com name of the event marker (e.g. COM3). If not set, it will use the comName set in public/config/trigger.js. If the productID is set (not an empty string), this field will be ignored.REACT_APP_AT_HOME: whether the app is being used in home mode (true) or clinic mode (false). During development and build time, you can run npm run dev:home/npm run dev:clinic or npm run build:home/npm run build:clinic to have the npm script set the variable for you. When running the production desktop application, you need to define it. Not defining this variable is equivalent to setting it to false. Build-time and run-time values need to be the same.REACT_APP_PATIENT_ID : The default patient id to show when requesting a patient ID in userID. If not set, no default is shown (blank input box). ","version":"1.1.0","tagName":"h2"},{"title":"Project Organization","type":0,"sectionRef":"#","url":"/docs/1.1.0/folders","content":"","keywords":"javascript  jspsych","version":"1.1.0"},{"title":"package.json​","type":1,"pageTitle":"Project Organization","url":"/docs/1.1.0/folders#packagejson","content":"The package.json file contains metadata about your project and scripts to run tasks related to your task. The name should be updated to your task's name and scripts can be added as desired, but otherwise this file should not be edited manually. To remove or add a dependency use npm install or npm uninstall with the -D flag if installing a dev dependency. The package-lock.json contains metadata about the package installation. It should never be manually updated. ","version":"1.1.0","tagName":"h3"},{"title":"assets/​","type":1,"pageTitle":"Project Organization","url":"/docs/1.1.0/folders#assets","content":"The icons used for the installed applications are put here. ","version":"1.1.0","tagName":"h3"},{"title":"public/​","type":1,"pageTitle":"Project Organization","url":"/docs/1.1.0/folders#public","content":"The public directory contains files that are used as assets in the built app. The favicon.ico is the small icon you can see in the browser tab (on Chrome) - it is set to Brown's logo in the project. The index.html contains the shell of your website - the name displayed on the tab can be changed here, otherwise it shouldn't need to be edited. The scripts included in the file are for psiturk as are the files in the lib/ directory. electron.js​ This file contains all of the code relating to the electron app. This includes the event-marker, throwing errors via dialog windows, saving data, and reading files. config/​ The config directory contains the config files needed for the electron app. This includes the event-marker details and event codes. Note: the productId can be overwritten by the environment variable EVENT_MARKER_PRODUCT_ID ","version":"1.1.0","tagName":"h3"},{"title":"Automated Builds","type":0,"sectionRef":"#","url":"/docs/1.1.0/ci","content":"","keywords":"javascript  jspsych","version":"1.1.0"},{"title":"What is CI/CD:​","type":1,"pageTitle":"Automated Builds","url":"/docs/1.1.0/ci#what-is-cicd","content":"Continuous Integration, Continuous Deployment: CI/CD or CICD refers to continuous integration and either continuous delivery or continuous deployment. CI/CD enforces the automated building of bundled executables so that tasks can be easily installed without dependencies. In Honeycomb, CI/CD is managed by GitHub Actions. ","version":"1.1.0","tagName":"h2"},{"title":"What are Github Actions​","type":1,"pageTitle":"Automated Builds","url":"/docs/1.1.0/ci#what-are-github-actions","content":"GitHub Actions automate tasks within the development life cycle of your software. GitHub Actions consist of a series of commands that run after a specified event has occurred. For example, every time someone creates a pull request for a repository, you can automatically run a command to build and test your software. You can learn more about the events that trigger workflows in GitHub's documentation. GitHub Actions are written as YAML files inside a .github/worflows/ folder in your repository. ","version":"1.1.0","tagName":"h2"},{"title":"Building the executables​","type":1,"pageTitle":"Automated Builds","url":"/docs/1.1.0/ci#building-the-executables","content":"Honeycomb includes workflows to build and create installers for Windows, Mac, and Linux. These workflows exist for two configurations of the tasks: Home: The app does not expect event code triggers and photodiode spots. Clinic: The app expects event code triggers and photodiode spots.  More specifically, the following workflows are included: build.yaml: Every time an Pull Request (PR) is opened, or a push is made to the main branch, the software is built and tests are run for all platforms and home and clinic settings. This workflow does not build and upload desktop installerspackage.yaml: Create installers for any/all platforms for the home and clinic setting on demand 1. The installers/executables are uploaded as artifacts and are available for download from the GitHub Actions tab. This also builds PsiTurk version when linux or all operating systems are selectedrelease.yml: Every time a Tag is released, installers are created and uploaded as packages. This also builds PsiTurk version, and deploys to GitHub pages a web version of the application.  1 On-demand workflows are triggered manually from the GitHub Actions tab. Each GitHub organization/individual has a quota on storage on private repositories. Uploading artifacts counts against your quota. You may consider configuring your workflows to only upload what you need. ","version":"1.1.0","tagName":"h2"},{"title":"Download your bundled executable to install and run your task​","type":1,"pageTitle":"Automated Builds","url":"/docs/1.1.0/ci#download-your-bundled-executable-to-install-and-run-your-task","content":"You can download the executable file from either the tagged release page or the GitHub actions page. To install, unzip the downloaded file and allow to run. The executable does not require installation of any additional software. ","version":"1.1.0","tagName":"h2"},{"title":"Uninstall the task​","type":1,"pageTitle":"Automated Builds","url":"/docs/1.1.0/ci#uninstall-the-task","content":"Windows​ Go to System Settings: Add or remove programs. Look for the name of your task in the installed programs list, and Uninstall. ","version":"1.1.0","tagName":"h2"},{"title":"src/​","type":1,"pageTitle":"Project Organization","url":"/docs/1.1.0/folders#src","content":"This folder contains the code for the app, the vast majority of changes and code should go here. App.js​ This is the starting point for the app. The &lt;Experiment&gt; component initializes a jspsych experiment. This is also where communication is set up with the electron and psiturk processes. App.css​ This is where styling for the app is housed. If colors, fonts, spacing, etc. need to be set, do it here. assets/​ This folder contains any static files that are used by the app, such as images. config/​ In the config/ directory, there are .js files which contain settings for the different parts of the task. Every task should have a main config and a trigger config (assuming use of the event marker). The main config has all global settings for the task (such as whether it is in mturk mode or not), load the appropriate language file, and set up a default (or only) configuration object for the task. The trigger config has settings specific to the event marker and uses a slightly different style of javascript as it is imported both in the React app as well as the electron process. Other config files can be used to add settings for specific blocks or sub-sections of the experiment. language/​ Any language that is displayed in the experiment should be stored in this folder. Usage of language json files allows for easy internationalization of the task (e.g. english and spanish) as well as allows for mturk specific language. This also makes it easy to re-use common phrases in many places in the task. lib/​ The lib/ directory contains utility functions and markup that is used in the tasks. This allows for functions and html to be re-used wherever needed. The lib/utils.js file contains functions that are generally useful across many tasks, whereas lib/taskUtils.js contains functions specific to this task. lib/markup​ markup files should contain primarily templates for HTML that is used throughout the task. Typically this will be a function that takes in some parameters and then returns a string with html. timelines​ jspsych uses timelines to control what trials are displayed in what order. timelines can contain other timelines, which is why there may be several files in this directory. The main.js file should have the timeline that is called by App.js. trials​ jspsych uses trials as its base unit of an experiment. These trials do things such as display some stimulus or request a response. ","version":"1.1.0","tagName":"h3"},{"title":"Set up event triggers","type":0,"sectionRef":"#","url":"/docs/1.1.0/event_triggers","content":"","keywords":"javascript  jspsych","version":"1.1.0"},{"title":"BrainVision Trigger Box setup​","type":1,"pageTitle":"Set up event triggers","url":"/docs/1.1.0/event_triggers#brainvision-trigger-box-setup","content":"Follow the TriggerBox setup instructions in the BrainVision Trigger Box manual. Plug the TriggerBox into the computer running the task. Check your operating system’s device list to identify the COM port that the TriggerBox is connected to. Create a new system environment variable: COMNAME  and set to the COM port to the correct value (e.g., COM3). ","version":"1.1.0","tagName":"h2"},{"title":"Open Source Event Trigger setup​","type":1,"pageTitle":"Set up event triggers","url":"/docs/1.1.0/event_triggers#open-source-event-trigger-setup","content":"Details on how to make the open source event trigger and photodiode can be found here: https://github.com/neuromotion/USB-event-markerConnect the open source event trigger to the computer running the task using a USB to micro-USB cable. Check your operating system’s USB device list to identify the product ID of the teensyduino event marker. Create a new system environment variable: EVENT_MARKER_PRODUCT_ID and set to the product ID of the event marker. ","version":"1.1.0","tagName":"h2"},{"title":"Send event code triggers​","type":1,"pageTitle":"Set up event triggers","url":"/docs/1.1.0/event_triggers#send-event-code-triggers","content":"Change the eventCodes values listed in the src/config/trigger.js file to the desired values. Import eventCodes from./trigger and export as eventCodes Whenever you would like to send an event code in a trial, load eventCodes from ../config/main/, and call pdSpotEncodewith the proper eventCode (e.g. eventCode.Fixation) as input. ","version":"1.1.0","tagName":"h2"},{"title":"Run the task with event triggers​","type":1,"pageTitle":"Set up event triggers","url":"/docs/1.1.0/event_triggers#run-the-task-with-event-triggers","content":"Honeycomb automatically checks whether your event marker is connected and running at the start of the task. If it is not connected, the task will present an error and will not be able to run. ","version":"1.1.0","tagName":"h2"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/docs/1.1.0/quick_start","content":"","keywords":"javascript  jspsych","version":"1.1.0"},{"title":"1. Start your new task from our template repository​","type":1,"pageTitle":"Quick Start","url":"/docs/1.1.0/quick_start#1-start-your-new-task-from-our-template-repository","content":"The simplest way to get started is creating a new repository using Honeycomb as a template. Go to https://github.com/brown-ccv/honeycomb and click on Use this template on the top right. Then select the organization and the name of your repository and click on create repository from template Alternatively, you can use GitHub CLI to create a new project based on the Honeycomb template repository. First, install GitHub CLI (https://cli.github.com/), then simply run on your terminal: gh repo create your-new-task-name --template brown-ccv/honeycomb  You can now move into the directory that was just created cd your-new-task-name  ","version":"1.1.0","tagName":"h3"},{"title":"2. Change name and description​","type":1,"pageTitle":"Quick Start","url":"/docs/1.1.0/quick_start#2-change-name-and-description","content":"Update the package.json fields to reflect your app name and description, e.g. name, author, repository ","version":"1.1.0","tagName":"h3"},{"title":"3. Install the dependencies.​","type":1,"pageTitle":"Quick Start","url":"/docs/1.1.0/quick_start#3-install-the-dependencies","content":"Electron DependenciesHoneycomb relies on Electron to package the cross-platform desktop applications. Before starting, you will need to install Electron's pre-requisites. You can find instructions here for your specific OS Honeycomb npm packagesOnce Node.js is installed you will able to use npm commands in the terminal. To install the dependencies for HoneyComb run the following command at the terminal (remember you need cd your-new-task-name before) npm install  ","version":"1.1.0","tagName":"h3"},{"title":"4. Run the task in dev mode​","type":1,"pageTitle":"Quick Start","url":"/docs/1.1.0/quick_start#4-run-the-task-in-dev-mode","content":"To launch an electron window with the task with the inspector open to the console and will hot-reload when changes are made to the app **For Mac and Linux: npm run dev  **For Windows: You will need to open 2 terminals. In the first -and make sure you are in the task-&lt;TASK NAME&gt; repo directory- run the command: npm start  In the second terminal - make sure you are in the task-&lt;TASK NAME&gt; repo directory-, run: npm run electron-dev  ","version":"1.1.0","tagName":"h3"},{"title":"5. Check out the data​","type":1,"pageTitle":"Quick Start","url":"/docs/1.1.0/quick_start#5-check-out-the-data","content":"The data is saved throughout the task to the users's app directory. This is logged at the beginning of the task wherever you ran npm run dev (for windows, instead in two different terminals ran npm start and npm run electron-dev). It is also stored in a folder that is generated by the app, which should be found on the desktop. ","version":"1.1.0","tagName":"h3"},{"title":"6. Quit The Task​","type":1,"pageTitle":"Quick Start","url":"/docs/1.1.0/quick_start#6-quit-the-task","content":"If you want to quit in the middle of the task, you can use these keyboard shortcuts: Ctrl+W (for PC/Windows)  Cmd+Q (for Mac)  Partial data will be saved. ","version":"1.1.0","tagName":"h3"},{"title":"7. Merge updates from honeycomb template repo​","type":1,"pageTitle":"Quick Start","url":"/docs/1.1.0/quick_start#7-merge-updates-from-honeycomb-template-repo","content":"Honeycomb is an active project, and will be updated with new features over time. To merge the honeycomb template repository updates with your task, follow the following steps: First time only: git remote add honeycomb https://github.com/brown-ccv/honeycomb.git  Every time: git fetch --all  git merge honeycomb/main --allow-unrelated histories  If there are any conflicts: git stash  To merge: git commit -a -m &quot;merge honeycomb latest&quot;  ","version":"1.1.0","tagName":"h3"},{"title":"NPM Scripts","type":0,"sectionRef":"#","url":"/docs/1.1.0/npm_scripts","content":"","keywords":"javascript  jspsych","version":"1.1.0"},{"title":"npm run dev​","type":1,"pageTitle":"NPM Scripts","url":"/docs/1.1.0/npm_scripts#npm-run-dev","content":"Runs npm start and npm run electron-dev concurrently. This may not play nicely with windows. If it doesn't, run npm start and npm run electron-dev from different terminal windows. ","version":"1.1.0","tagName":"h3"},{"title":"npm start​","type":1,"pageTitle":"NPM Scripts","url":"/docs/1.1.0/npm_scripts#npm-start","content":"Runs the app in the development mode. Open http://localhost:3000 to view it in the browser. The page will reload if you make edits. You will also see any lint errors in the console. ","version":"1.1.0","tagName":"h3"},{"title":"npm test​","type":1,"pageTitle":"NPM Scripts","url":"/docs/1.1.0/npm_scripts#npm-test","content":"Launches the test runner in the interactive watch mode. See the section about running tests for more information. ","version":"1.1.0","tagName":"h3"},{"title":"npm build​","type":1,"pageTitle":"NPM Scripts","url":"/docs/1.1.0/npm_scripts#npm-build","content":"Creates a production build of the app (renderer). This must be done before running package:platform or the psiturk build instructions. ","version":"1.1.0","tagName":"h3"},{"title":"npm run package:platform​","type":1,"pageTitle":"NPM Scripts","url":"/docs/1.1.0/npm_scripts#npm-run-packageplatform","content":"It correctly bundles creates electron packages for the given platform. It then creates an installer for that platform. The output can be found in /distplatforms: windows, mac, linux. Prerequisites​ If not running this command on a windows machine, must have mono and wine installed. ","version":"1.1.0","tagName":"h3"},{"title":"npm run eject​","type":1,"pageTitle":"NPM Scripts","url":"/docs/1.1.0/npm_scripts#npm-run-eject","content":"Note: this is a one-way operation. Once you eject, you can’t go back! If you aren’t satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (Webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own. You don’t have to ever use eject. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it. ","version":"1.1.0","tagName":"h3"},{"title":"Run Electron​","type":1,"pageTitle":"NPM Scripts","url":"/docs/1.1.0/npm_scripts#run-electron","content":"npm run electron​ Run the built app. npm run electron-dev​ Run the current state of the code (un-built). ","version":"1.1.0","tagName":"h3"},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"/docs/1.1.0/troubleshooting","content":"","keywords":"javascript  jspsych","version":"1.1.0"},{"title":"Potential Issues​","type":1,"pageTitle":"Troubleshooting","url":"/docs/1.1.0/troubleshooting#potential-issues","content":"Package not found or other error related to npm​ Try deleting your node_modules folder and the package-lock.json then running npm install then npm run rebuild. ","version":"1.1.0","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/2.x/","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"Flexible deployment online and in the lab​","type":1,"pageTitle":"Introduction","url":"/docs/2.x/#flexible-deployment-online-and-in-the-lab","content":"Honeycomb provides the ability to write one codebase and use it flexibly across settings (with guaranteed consistency in instructions, timing, etc.). The same code-base is used to maintain and deploy the identical task on Mechanical Turk, Prolific, and in research settings during concurrent electrophysiological recordings. ","version":"2.x","tagName":"h3"},{"title":"Easy to install executables​","type":1,"pageTitle":"Introduction","url":"/docs/2.x/#easy-to-install-executables","content":"Deployment specifications are abstracted as parameters that are easy to configure, and application building is automated via GitHub actions providing continuous delivery of easy-to-download executables, easing setup burden across research sites. ","version":"2.x","tagName":"h3"},{"title":"Foundation in jsPsych​","type":1,"pageTitle":"Introduction","url":"/docs/2.x/#foundation-in-jspsych","content":"jsPsych tasks can be converted to the Honeycomb structure to take advantage of the flexible deployment and automated GitHub Actions workflow that Honeycomb provides. ","version":"2.x","tagName":"h3"},{"title":"Deploy online","type":0,"sectionRef":"#","url":"/docs/1.1.0/online_integration","content":"","keywords":"javascript  jspsych","version":"1.1.0"},{"title":"Usage with PsiTurk​","type":1,"pageTitle":"Deploy online","url":"/docs/1.1.0/online_integration#usage-with-psiturk","content":"While this set up is optimized for Electron, we added functionality that will make use with PsiTurk easy. The application will detect if it's being used in a Turk environment and will: Save the data to the default PsiTurk SQLite database. Switch the language to Turk specific, if src/language/&lt;locale&gt;.mturk.json exists. Use the Turk specific timeline if different than the primary timeline.  ","version":"1.1.0","tagName":"h2"},{"title":"Prebuilt version​","type":1,"pageTitle":"Deploy online","url":"/docs/1.1.0/online_integration#prebuilt-version","content":"When GitHub Actions is run, a psiturk build will be created automatically, and can be downloaded from its artifacts (skip next step if using). The workflows responsible for building the PsiTurk application are .github/workflows/package-home-all.yml and .github/workflows/release-home-all.yml. The first one has to be triggered manually, the latter is triggered when you tag a release. ","version":"1.1.0","tagName":"h3"},{"title":"Build instructions​","type":1,"pageTitle":"Deploy online","url":"/docs/1.1.0/online_integration#build-instructions","content":"To set up your PsiTurk project, we provide a script that does the conversion. PsiTurk is a Python package used to manage HITs in Mechanical Turk. Before using the provided script, install PsiTurk. You'll need to follow these steps (the path to the PsiTurk project should be a directory you wish to be created): Build the application: npm run build Move to the psiturkit directory: cd psiturkit If it's the first time you're running the script: ./psiturk-it -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt; To update an existing PsiTurk project (the path to the PsiTurk project should already exist from the previous steps): ./psiturk-it -u -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt; ","version":"1.1.0","tagName":"h3"},{"title":"Running psiturk​","type":1,"pageTitle":"Deploy online","url":"/docs/1.1.0/online_integration#running-psiturk","content":"After that, just navigate to your newly created PsiTurk project directory. shell&gt; psiturk #start psiturk psiturk&gt; server on #start server psiturk&gt; debug #debug mode  ","version":"1.1.0","tagName":"h3"},{"title":"Running on the Web​","type":1,"pageTitle":"Deploy online","url":"/docs/1.1.0/online_integration#running-on-the-web","content":"Running npm run build generates static content into the build directory that can be served using any static contents hosting service. The workflow .github/workflows/release-home-all.yml uploads the build directory to the gh-branch to serve the application on GitHub pages as an example. After a creating a tag, the workflow will run and your application will be served at &lt;githubuser&gt;.github.io/&lt;repository&gt;. For this step to succeed you will need to create a deploy key and enable GitHub Pages for your repository. Generate a new SSH key.By default, your public key should have been created in ~/.ssh/id_rsa.pub or use the name you've provided.Copy key to clipboard with xclip -sel clip &lt; ~/.ssh/id_rsa.pub and paste it as a deploy key in your repository. Copy file content if the command line doesn't work for you. Check the box for Allow write access before saving your deployment key.You'll need your private key as a GitHub secret to allow the workflow to run the deployment for you.To create the secret copy your private key e.g. xclip -sel clip &lt; ~/.ssh/id_rsa and paste a GitHub secret with name GH_PAGES_DEPLOY. Copy file content if the command line doesn't work for you. Save your secret.Make sure the publishing source for your repository is configured for gh-pages branch. ","version":"1.1.0","tagName":"h2"},{"title":"Automated Builds","type":0,"sectionRef":"#","url":"/docs/2.x/ci","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"What is CI/CD:​","type":1,"pageTitle":"Automated Builds","url":"/docs/2.x/ci#what-is-cicd","content":"Continuous Integration, Continuous Deployment: CI/CD or CICD refers to continuous integration and either continuous delivery or continuous deployment. CI/CD enforces the automated building of bundled executables so that tasks can be easily installed without dependencies. In Honeycomb, CI/CD is managed by GitHub Actions. ","version":"2.x","tagName":"h2"},{"title":"What are Github Actions​","type":1,"pageTitle":"Automated Builds","url":"/docs/2.x/ci#what-are-github-actions","content":"GitHub Actions automate tasks within the development life cycle of your software. GitHub Actions consist of a series of commands that run after a specified event has occurred. For example, every time someone creates a pull request for a repository, you can automatically run a command to build and test your software. You can learn more about the events that trigger workflows in GitHub's documentation GitHub Actions are written as YML files inside a .github/worflows/ folder in your repository. ","version":"2.x","tagName":"h2"},{"title":"Building the executables​","type":1,"pageTitle":"Automated Builds","url":"/docs/2.x/ci#building-the-executables","content":"Honeycomb includes workflows to build and create installers for Windows. Mac and Linux. These workflows exist for two configurations of the tasks: Home: The app does not expect event code triggers and photodiode spots. Clinic: The app expects event code triggers and photodiode spots.  More specifically, the following workflows are included: build.yaml: Every time an Pull Request (PR) is opened, or a push is made to the main branch, the software is built and tests are run for all platforms and home and clinic settings. This workflow does not build and upload desktop installerspackage.yaml: Create installers for any/all platforms for the home and clinic setting on demand 1. The installers/executables are uploaded as artifacts and are available for download from the GitHub Actions tab. This also builds PsiTurk version when linux or all operating systems are selectedrelease.yml: Every time a Tag is released, installers are created and uploaded as packages. This also builds PsiTurk version, and deploys to GitHub pages a web version of the application.  1 On-demand workflows are triggered manually from the GitHub Actions tab. Each GitHub organization/individual has a quota on storage on private repositories. Uploading artifacts counts against your quota. You may consider configuring your workflows to only upload what you need. You can learn more about GitHub's storage limits in their [official documentation](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#about-billing-for-github-actions). ","version":"2.x","tagName":"h2"},{"title":"Software Prerequisites","type":0,"sectionRef":"#","url":"/docs/1.1.0/software_prerecs","content":"","keywords":"javascript  jspsych","version":"1.1.0"},{"title":"Windows​","type":1,"pageTitle":"Software Prerequisites","url":"/docs/1.1.0/software_prerecs#windows","content":"Visual Studio​ Install the latest version of Visual Studio (https://visualstudio.microsoft.com/downloads/) with the Desktop Development for C++ Workflow. To add the workflow, follow the instructions linked below:https://docs.microsoft.com/en-us/cpp/build/vscpp-step-0-installation?view=msvc-160#:~:text=If%20you%20have%20Visual%20Studio,Then%2C%20choose%20Modify. Python​ Install Python. For new Python users, we recommend installing via Anaconda: https://docs.anaconda.com/anaconda/install/windows/ Node.js​ Install Node.js: https://nodejs.org/en/download/ Git bash​ Install git bash: https://git-scm.com/downloads Note: restart computer after all installs are complete​ ","version":"1.1.0","tagName":"h2"},{"title":"Github Actions for firebase hosting​","type":1,"pageTitle":"Automated Builds","url":"/docs/2.x/ci#github-actions-for-firebase-hosting","content":"Automatic deployment on a firebase hosting site can also be setup with github actions. Before proceeding with the follwing steps, please make sure that firebase is configured by following the Getting started with firebase section under Set Up Firebase Run firebase init hosting:github in the terminal and follow the CLI prompts to start setting up the github actions. For the github directory question, select your task github directory.When prompted with the npm command, type npm install &amp;&amp; npm run build:firebase There should be two new .yml files, firebase-hosting-pull-request.yml and firebase-hosting-merge.yml, created in the .github/workflows directory for a deployment preview for each pull request and the official deployment when merged onto the main branch. ","version":"2.x","tagName":"h2"},{"title":"Download your bundled executable to install and run your task​","type":1,"pageTitle":"Automated Builds","url":"/docs/2.x/ci#download-your-bundled-executable-to-install-and-run-your-task","content":"You can download the executable file from either the tagged release page or the GitHub actions page. To install, unzip the downloaded file, install and run. The executable does not require installation of any additional software. ","version":"2.x","tagName":"h2"},{"title":"Uninstall the task​","type":1,"pageTitle":"Automated Builds","url":"/docs/2.x/ci#uninstall-the-task","content":"Windows​ Go to System Settings: Add or remove programs. Look for the name of your task in the installed programs list, and uninstall. ","version":"2.x","tagName":"h2"},{"title":"Version Control","type":0,"sectionRef":"#","url":"/docs/1.1.0/version_control","content":"","keywords":"javascript  jspsych","version":"1.1.0"},{"title":"Git Overview​","type":1,"pageTitle":"Version Control","url":"/docs/1.1.0/version_control#git-overview","content":"Git is a version control system that enables you to track changes to files. With Git, you are able to revert files back to previous versions, restore deleted files, remove added files and even track down where a particular line of code was introduced. Git creates a hidden .git folder (in the current folder) to store the details of the file system - this folder contains all the data required to track your files and is known as a repository, or repo. Git tracks file changes by the user creating a save point, or in Git terms a commit. Each commit takes a snapshot of the current file system. Commits are uniquely identified by a SHA–1 hash. This is a 40 character string which may along the lines of ded7a0db6422d59e9893e975e32275fc36f853daThis hash can be used to track a particular commit within the repository. Nearly all operations that are performed by Git are in you local computing environment, for the exception of few used purely to synchronize with a remote. Some of the most common git operations are depicted below. In summary, a typical flow consists of making changes to your files, staging them via git add, marking a save point via git commit, then finally syncing to your remote (e.g., GitHub) via git push. If you are pushing changes to your remote from multiple places, you can bring changes your most recent version using git pull, which is the equivalent of doing git fetch followed by a git merge operation  ","version":"1.1.0","tagName":"h2"},{"title":"Cheatsheet​","type":1,"pageTitle":"Version Control","url":"/docs/1.1.0/version_control#cheatsheet","content":"Command\tBriefgit add &lt;files&gt;\tadd a file to next commit (stage) git commit -m &lt;message&gt;\tcommit staged files git push\tupload staged commit to repo git pull\tget remote repo commits and download (try and resolve conflicts) git clone &lt;url&gt;\tdownload entire repository ","version":"1.1.0","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Version Control","url":"/docs/1.1.0/version_control#best-practices","content":"","version":"1.1.0","tagName":"h2"},{"title":"Workflow​","type":1,"pageTitle":"Version Control","url":"/docs/1.1.0/version_control#workflow","content":"We recommend a simple flow based on following rules: Use topic/feature branches, no direct commits on main.Perform tests and code reviews before merges into main, not afterwards.Everyone starts from main, and targets main.Commit messages reflect intent. ","version":"1.1.0","tagName":"h3"},{"title":"Branches​","type":1,"pageTitle":"Version Control","url":"/docs/1.1.0/version_control#branches","content":"main is the default branch and where releases are made off. This branch should be in clean/working conditions at all times. This branch is protected and can only be merged from Pull Requests for topic branchestopic branches are created for new features, fixes, or really any changes ","version":"1.1.0","tagName":"h3"},{"title":"Comment styles​","type":1,"pageTitle":"Version Control","url":"/docs/1.1.0/version_control#comment-styles","content":"We encourage using Commitizen, a great tool for writing angular commits - this will create a standardized commit format which makes for easier change logging and more sane messages. ","version":"1.1.0","tagName":"h3"},{"title":"Configuration","type":0,"sectionRef":"#","url":"/docs/2.x/configuration","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"Environment Variables​","type":1,"pageTitle":"Configuration","url":"/docs/2.x/configuration#environment-variables","content":"Honeycomb uses environment variables during build and run time to control the different configurations. Below we list the environment variables used by the app and indicate whether they are mandatory, optional and needed during build (npm build) or run time (using the application executable or npm run dev) ELECTRON_START_URL : URL (e.g. http://localhost:3000) where the front end of the app is being hosted - also used in electron.js to indicate the app is running in dev mode.EVENT_MARKER_PRODUCT_ID: The product ID of the event marker (e.g. 0487). If not set, it will use the productID set in public/config/trigger.js if available, or attempt to connect using the com name.EVENT_MARKER_COM_NAME : The com name of the event marker (e.g. COM3). If not set, it will use the comName set in public/config/trigger.js. If the productID is set (not an empty string), this field will be ignored.REACT_APP_VOLUME: whether the participant is being asked to adjust volume. This can be used on both the desktop (electron) and online settings.REACT_APP_VIDEO: whether the participant is being video recorded. This can be used when the task is running as a desktop app (electron). REACT_APP_USE_EEG: whether the event marker/EEG is available. This can be used when the task is running as a desktop app (electron).REACT_APP_USE_PHOTODIODE: whether the photodiode is in use. This can be used when the task is running as a desktop app (electron).REACT_APP_PARTICIPANT_ID : The default participant id to show when authorizing a participant. If not set, user will need to enter the value in the provided input box.REACT_APP_STUDY_ID : The default study id to show when authorizing a participant. If not set, user will need to enter the value in the provided input box. Here are details on some of the badges: : Run-time environment variable. Set at the system level. See this tutorial for OS specific instructions. : Build-time environment variable. Set in a .env file before building. Can also be defined in a separate file under the env/ directory and called with the dotenv-cli before building. NOTE: The dotenv command will not work directly from the command line. Instead, to set build-time environment variables, either run an existing npm script (e.g., npm run build:clinic, which sets clinic variables) or add a new script to package.json with the following format: &quot;[build|dev]:&lt;script name&gt;&quot;: &quot;dotenv -e env/&lt;your env file&gt; npm run [build|dev]&quot;  Or, to add your new variables to an existing environment configuration, e.g. .env.clinic, create a script in the following format: &quot;[build|dev]:&lt;script name&gt;&quot;: &quot;dotenv -e env/&lt;your env file&gt; npm run [build|dev]:clinic&quot;  Then run the script like so: npm run [build|dev]:&lt;script name&gt;. ","version":"2.x","tagName":"h2"},{"title":"Set up event triggers","type":0,"sectionRef":"#","url":"/docs/2.x/event_triggers","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"BrainVision Trigger Box setup​","type":1,"pageTitle":"Set up event triggers","url":"/docs/2.x/event_triggers#brainvision-trigger-box-setup","content":"Follow the TriggerBox setup instructions in the BrainVision Trigger Box manual. Plug the TriggerBox into the computer running the task. Check your operating system’s device list to identify the COM port that the TriggerBox is connected to. Create a new system environment variable: COMNAME  and set to the COM port to the correct value (e.g., COM3). ","version":"2.x","tagName":"h2"},{"title":"Open Source Event Trigger setup​","type":1,"pageTitle":"Set up event triggers","url":"/docs/2.x/event_triggers#open-source-event-trigger-setup","content":"Details on how to make the open source event trigger and photodiode can be found here: https://github.com/neuromotion/USB-event-markerConnect the open source event trigger to the computer running the task using a USB to micro-USB cable. Check your operating system’s USB device list to identify the product ID of the teensyduino event marker. Create a new system environment variable: EVENT_MARKER_PRODUCT_ID and set to the product ID of the event marker. ","version":"2.x","tagName":"h2"},{"title":"Send event code triggers​","type":1,"pageTitle":"Set up event triggers","url":"/docs/2.x/event_triggers#send-event-code-triggers","content":"Change the eventCodes values listed in the src/config/trigger.js file to the desired values. Import eventCodes from./trigger and export as eventCodes Whenever you would like to send an event code in a trial, load eventCodes from ../config/main/, and call pdSpotEncodewith the proper eventCode (e.g. eventCode.Fixation) as input. ","version":"2.x","tagName":"h2"},{"title":"Run the task with event triggers​","type":1,"pageTitle":"Set up event triggers","url":"/docs/2.x/event_triggers#run-the-task-with-event-triggers","content":"Honeycomb automatically checks whether your event marker is connected and running at the start of the task. If it is not connected, the task will present an error and will not be able to run. ","version":"2.x","tagName":"h2"},{"title":"Set up Firebase","type":0,"sectionRef":"#","url":"/docs/2.x/firebase","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"Getting Started​","type":1,"pageTitle":"Set up Firebase","url":"/docs/2.x/firebase#getting-started","content":"Follow these steps to create a firebase project and link it with the current task. 1. Initializing firebase account and project​ Create and login to a firebase account on the Firebase website.Create a firebase project by clicking add project and enter a Project Name. 2. Linking firebase to task​ Install Firebase CLI on your local computer.Login to firebase using firebase login command in the terminal.Navigate to the .firebaserc file home directory and edit the &quot;default&quot; field with the project name given in part 1. { &quot;projects&quot;: { &quot;default&quot;: &quot;&lt;your project name&gt;&quot; } }  3. Copying web app credentials.​ Navigate to the firebase console and select the project.Create a new Web App by clicking on Add App or the &lt;/&gt; code symbol and following the prompts.Enter the a name for the Firebase app (could be the same as your Honeycomb task repo name).Check &quot;Also set up Firebase Hosting for this app.&quot;Click Register App. This should auto-generate a script with several values that you need to copy into the next step.Copy the auto-generated values from the Firebase console to the corresponding variables in the .env.firebase file in the env folder of your Honeycomb task repo: REACT_APP_apiKey= REACT_APP_authDomain= REACT_APP_projectId= REACT_APP_storageBucket= REACT_APP_messagingSenderId= REACT_APP_appId= You can skip running firebase init if prompted to do so. The results of firebase init are already saved into the Honeycomb template repo. Firebase is now set up! ","version":"2.x","tagName":"h2"},{"title":"Setting up firestore.​","type":1,"pageTitle":"Set up Firebase","url":"/docs/2.x/firebase#setting-up-firestore","content":"Honeycomb includes cloud storage for task data using Firestore. Follow these steps to initialize firestore: Navigate to the current project in the developer console and select Firestore Database from the sidebar.Click Create Database, select production mode and choose the current location for the cloud storage bucket. ","version":"2.x","tagName":"h2"},{"title":"Firestore security rules.​","type":1,"pageTitle":"Set up Firebase","url":"/docs/2.x/firebase#firestore-security-rules","content":"Firestore Security Rules provides easy server-side authorization to the database. For a honeycomb task, we use the security rules to allow access to only authorized participants for a specified study. Honeycomb's default set of rules is included in the firestore.rules file in the home directory. This file can be edited to change the rules. To deploy the rules in the file, type the following line of code in the terminal: firebase deploy --only firestore:rules  Alternatively, Editing the rules directly in the console is also possible. To do so, navigate to the Rules tab in the Firestore Database section from the firebase console sidebar then copy and paste the code that is in the firestore.rules file. Firestore database and rules are now both deployed. For Honeycomb's default set of rules, to add an authorized participant for a study, create a collection named registered_studies, add a study with the study ID as the document name in that collection. For each registered study, add an array field named registered_participants where each element in the array will be an authorized participant for that study.  ","version":"2.x","tagName":"h3"},{"title":"Project Organization","type":0,"sectionRef":"#","url":"/docs/2.x/folders","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"package.json​","type":1,"pageTitle":"Project Organization","url":"/docs/2.x/folders#packagejson","content":"The package.json file contains metadata about your project and scripts to run tasks related to your task. The name should be updated to your task's name and scripts can be added as desired, but otherwise this file should not be edited manually. To remove or add a dependency use npm install or npm uninstall with the -D flag if installing a dev dependency. The package-lock.json contains metadata about the package installation. It should never be manually updated. ","version":"2.x","tagName":"h3"},{"title":"assets/​","type":1,"pageTitle":"Project Organization","url":"/docs/2.x/folders#assets","content":"The icons used for the installed applications are put here. ","version":"2.x","tagName":"h3"},{"title":"env/​","type":1,"pageTitle":"Project Organization","url":"/docs/2.x/folders#env","content":"This folder contains different .env files with presets for common use cases. These files can be loaded with dotenv, which is explained in greater detail in the Configuration section. ","version":"2.x","tagName":"h3"},{"title":"public/​","type":1,"pageTitle":"Project Organization","url":"/docs/2.x/folders#public","content":"The public directory contains files that are used as assets in the built app. The favicon.ico is the small icon you can see in the browser tab (on Chrome) - it is set to Brown's logo in the project. The index.html contains the shell of your website - the name displayed on the tab can be changed here, otherwise it shouldn't need to be edited. The scripts included in the file are for psiturk as are the files in the lib/ directory. electron.js​ This file contains all of the code relating to the electron app. This includes the event-marker, throwing errors via dialog windows, saving data, and reading files. config/​ The config directory contains the config files needed for the electron app. This includes the event-marker details and event codes. Note: the productId can be overwritten by the environment variable EVENT_MARKER_PRODUCT_ID ","version":"2.x","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"Project Organization","url":"/docs/2.x/folders#src","content":"This folder contains the code for the app, the vast majority of changes and code should go here. App.jsx​ This is the starting point for the app. The &lt;Login&gt; component handles user authentication in the different use cases and the &lt;JsPsychExperiment&gt; component initializes the jspsych experiment. This is also where communication is set up with the electron and psiturk processes. App.css​ This is where styling for the app is housed. If colors, fonts, spacing, etc. need to be set, do it here. assets/​ This folder contains any static files that are used by the app, such as images. components/​ This folder contains the components referenced in App.jsx. config/​ In the config/ directory, there are .js files which contain settings for the different parts of the task. Every task should have a main config and a trigger config (assuming use of the event marker). The main config has all global settings for the task (such as whether it is in mturk mode or not), load the appropriate language file, and set up a default (or only) configuration object for the task. Different in-task features can be loaded from .env files and is set in the main config. For example, we have included some of these files in the env directory (e.g. env.clinic file enables event marker, photodiode and volume adjustment). The trigger config has settings specific to the event marker and uses a slightly different style of javascript as it is imported both in the React app as well as the electron process. Other config files can be used to add settings for specific blocks or sub-sections of the experiment. language/​ Any language that is displayed in the experiment should be stored in this folder. Usage of language json files allows for easy internationalization of the task (e.g. english and spanish) as well as allows for mturk specific language. This also makes it easy to re-use common phrases in many places in the task. lib/​ The lib/ directory contains utility functions and markup that is used in the tasks. This allows for functions and html to be re-used wherever needed. The lib/utils.js file contains functions that are generally useful across many tasks, whereas lib/taskUtils.js contains functions specific to this task. lib/markup​ markup files should contain primarily templates for HTML that is used throughout the task. Typically this will be a function that takes in some parameters and then returns a string with html. timelines​ jspsych uses timelines to control what trials are displayed in what order. timelines can contain other timelines, which is why there may be several files in this directory. The main.js file should have the timeline that is called by App.jsx in the &lt;JsPsychExperiment&gt; component. trials​ jspsych uses trials as its base unit of an experiment. These trials do things such as display some stimulus or request a response. ","version":"2.x","tagName":"h3"},{"title":"NPM Scripts","type":0,"sectionRef":"#","url":"/docs/2.x/npm_scripts","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"npm run dev​","type":1,"pageTitle":"NPM Scripts","url":"/docs/2.x/npm_scripts#npm-run-dev","content":"Runs npm start and npm run electron-dev concurrently. This may not play nicely with windows. If it doesn't, run npm start and npm run electron-dev from different terminal windows. ","version":"2.x","tagName":"h3"},{"title":"npm start​","type":1,"pageTitle":"NPM Scripts","url":"/docs/2.x/npm_scripts#npm-start","content":"Runs the app in the development mode. Open http://localhost:3000 to view it in the browser. The page will reload if you make edits. You will also see any lint errors in the console. ","version":"2.x","tagName":"h3"},{"title":"npm test​","type":1,"pageTitle":"NPM Scripts","url":"/docs/2.x/npm_scripts#npm-test","content":"Launches the test runner in the interactive watch mode. See the section about running tests for more information. ","version":"2.x","tagName":"h3"},{"title":"npm build​","type":1,"pageTitle":"NPM Scripts","url":"/docs/2.x/npm_scripts#npm-build","content":"Creates a production build of the app (renderer). This must be done before running package:platform or the psiturk build instructions. ","version":"2.x","tagName":"h3"},{"title":"npm run package:platform​","type":1,"pageTitle":"NPM Scripts","url":"/docs/2.x/npm_scripts#npm-run-packageplatform","content":"It correctly bundles creates electron packages for the given platform. It then creates an installer for that platform. The output can be found in /distplatforms: windows, mac, linux. Prerequisites​ If not running this command on a windows machine, must have mono and wine installed. ","version":"2.x","tagName":"h3"},{"title":"npm run eject​","type":1,"pageTitle":"NPM Scripts","url":"/docs/2.x/npm_scripts#npm-run-eject","content":"Note: this is a one-way operation. Once you eject, you can’t go back! If you aren’t satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (Webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own. You don’t have to ever use eject. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it. ","version":"2.x","tagName":"h3"},{"title":"Run Electron​","type":1,"pageTitle":"NPM Scripts","url":"/docs/2.x/npm_scripts#run-electron","content":"npm run electron​ Run the built app. npm run electron-dev​ Run the current state of the code (un-built). ","version":"2.x","tagName":"h3"},{"title":"Software Prerequisites","type":0,"sectionRef":"#","url":"/docs/2.x/software_prerecs","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"Windows​","type":1,"pageTitle":"Software Prerequisites","url":"/docs/2.x/software_prerecs#windows","content":"Visual Studio​ Install the latest version of Visual Studio (https://visualstudio.microsoft.com/downloads/) with the Desktop Development for C++ Workflow. To add the workflow, follow the instructions linked below:https://docs.microsoft.com/en-us/cpp/build/vscpp-step-0-installation?view=msvc-160#:~:text=If%20you%20have%20Visual%20Studio,Then%2C%20choose%20Modify. Python​ Install Python. For new Python users, we recommend installing via Anaconda: https://docs.anaconda.com/anaconda/install/windows/ Node.js​ Install Node.js: https://nodejs.org/en/download/ Git bash​ Install git bash: https://git-scm.com/downloads Note: restart computer after all installs are complete​ ","version":"2.x","tagName":"h2"},{"title":"Deploy online","type":0,"sectionRef":"#","url":"/docs/2.x/online_integration","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"Usage with PsiTurk​","type":1,"pageTitle":"Deploy online","url":"/docs/2.x/online_integration#usage-with-psiturk","content":"While this set up is optimized for Electron, we added functionality that will make use with PsiTurk easy. The application will detect if it's being used in a Turk environment and will: Save the data to the default PsiTurk SQLite database. Switch the language to Turk specific, if src/language/&lt;locale&gt;.mturk.json exists. Use the Turk specific timeline if different than the primary timeline.  ","version":"2.x","tagName":"h2"},{"title":"Prebuilt version​","type":1,"pageTitle":"Deploy online","url":"/docs/2.x/online_integration#prebuilt-version","content":"When GitHub Actions is run, a psiturk build will be created automatically, and can be downloaded from its artifacts (skip next step if using). The workflows responsible for building the PsiTurk application are .github/workflows/package-home-all.yml and .github/workflows/release-home-all.yml. The first one has to be triggered manually, the latter is triggered when you tag a release. ","version":"2.x","tagName":"h3"},{"title":"Build instructions​","type":1,"pageTitle":"Deploy online","url":"/docs/2.x/online_integration#build-instructions","content":"To set up your PsiTurk project, we provide a script that does the conversion. PsiTurk is a Python package used to manage HITs in Mechanical Turk. Before using the provided script, install PsiTurk. You'll need to follow these steps (the path to the PsiTurk project should be a directory you wish to be created): Build the application: npm run build Move to the psiturkit directory: cd psiturkit If it's the first time you're running the script: ./psiturk-it -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt; To update an existing PsiTurk project (the path to the PsiTurk project should already exist from the previous steps): ./psiturk-it -u -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt; ","version":"2.x","tagName":"h3"},{"title":"Running psiturk​","type":1,"pageTitle":"Deploy online","url":"/docs/2.x/online_integration#running-psiturk","content":"After that, just navigate to your newly created PsiTurk project directory. shell&gt; psiturk #start psiturk psiturk&gt; server on #start server psiturk&gt; debug #debug mode  ","version":"2.x","tagName":"h3"},{"title":"Running on the Web​","type":1,"pageTitle":"Deploy online","url":"/docs/2.x/online_integration#running-on-the-web","content":"","version":"2.x","tagName":"h2"},{"title":"Using Github Pages​","type":1,"pageTitle":"Deploy online","url":"/docs/2.x/online_integration#using-github-pages","content":"Running npm run build generates static content into the build directory that can be served using any static contents hosting service. The workflow .github/workflows/release-home-all.yml uploads the build directory to the gh-branch to serve the application on GitHub pages as an example. After a creating a tag, the workflow will run and your application will be served at &lt;githubuser&gt;.github.io/&lt;repository&gt;. For this step to succeed you will need to create a deploy key and enable GitHub Pages for your repository. Generate a new SSH key.By default, your public key should have been created in ~/.ssh/id_rsa.pub or use the name you've provided.Copy key to clipboard with xclip -sel clip &lt; ~/.ssh/id_rsa.pub and paste it as a deploy key in your repository. Copy file content if the command line doesn't work for you. Check the box for Allow write access before saving your deployment key.You'll need your private key as a GitHub secret to allow the workflow to run the deployment for you.To create the secret copy your private key e.g. xclip -sel clip &lt; ~/.ssh/id_rsa and paste a GitHub secret with name GH_PAGES_DEPLOY. Copy file content if the command line doesn't work for you. Save your secret.Make sure the publishing source for your repository is configured for gh-pages branch. ","version":"2.x","tagName":"h3"},{"title":"Using Firebase​","type":1,"pageTitle":"Deploy online","url":"/docs/2.x/online_integration#using-firebase","content":"We have included methods and configurations for close integration with firebase. Before proceeding with the follwing steps, please make sure that firebase is configured by following the Getting started with firebase section under Set Up Firebase. Run npm run build:firebase in the terminal to create a production build for firebase.Run firebase deploy in the terminal to deploy the production build.The production build is now deployed to the firebase project domain.  To automate firebase deployments, we have included instructions on setting up firebase github actions on our Automated Builds page ","version":"2.x","tagName":"h3"},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"/docs/2.x/troubleshooting","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"Potential Issues​","type":1,"pageTitle":"Troubleshooting","url":"/docs/2.x/troubleshooting#potential-issues","content":"Package not found or other error related to npm​ Try deleting your node_modules folder and the package-lock.json then running npm install then npm run rebuild. ","version":"2.x","tagName":"h3"},{"title":"Inspecting Errors​","type":1,"pageTitle":"Troubleshooting","url":"/docs/2.x/troubleshooting#inspecting-errors","content":"In case you want to find out where the error is coming from when running the app locally: Try reviewing logs in the terminalInspect element in your browser by openning your developer tools. For instance, in Chrome, this can be done via the menu View -&gt; Developer or right-clicking and pressing inspect. ","version":"2.x","tagName":"h3"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/docs/2.x/quick_start","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"1. Start your new task from our template repository​","type":1,"pageTitle":"Quick Start","url":"/docs/2.x/quick_start#1-start-your-new-task-from-our-template-repository","content":"The simplest way to get started is creating a new repository using Honeycomb as a template. Go to https://github.com/brown-ccv/honeycomb and click on Use this template on the top right. Then select the organization and the name of your repository and click on create repository from template Alternatively, you can use GitHub CLI to create a new project based on the Honeycomb template repository. First, install GitHub CLI (https://cli.github.com/), then simply run on your terminal: gh repo create your-new-task-name --template brown-ccv/honeycomb  You can now move into the directory that was just created cd your-new-task-name  ","version":"2.x","tagName":"h3"},{"title":"2. Change name and description​","type":1,"pageTitle":"Quick Start","url":"/docs/2.x/quick_start#2-change-name-and-description","content":"Update the package.json fields to reflect your app name and description, e.g. name, author, repository ","version":"2.x","tagName":"h3"},{"title":"3. Install the dependencies.​","type":1,"pageTitle":"Quick Start","url":"/docs/2.x/quick_start#3-install-the-dependencies","content":"Electron DependenciesHoneycomb relies on Electron to package the cross-platform desktop applications. Before starting, you will need to install Electron's pre-requisites below. You can find the full instructions on the electron documentation for your specific OS. Windows​ Visual Studio: Install the latest version of Visual Studio with the Desktop Development for C++ Workflow. To add the workflow, follow these instructions. Node.js: Install Node.js Git bash (Git 2.20.0 or later with support for &quot;--show-current&quot;): Install git bash Note: restart computer after all installs are complete​ MacOS​ Command Line Tools: Type in the terminal xcode-select --install  Node.js: Install Node.js Git 2.20.0 or later (with support for &quot;--show-current&quot;): Install git Python 3.7 or later (with support for TLS 1.2): Follow the guide on electron docs to install and configure python and its modules Linux​ Node.js: Dowload Node.js source code and compile it: Git 2.20.0 or later (with support for &quot;--show-current&quot;): Install git Python 3.7 or later (with support for TLS 1.2): Install Python Clang: Install Clang or follow installation instructions on the electron docs Development headers of GTK 3 and libnotify: Follow installation instructions on the electron docs Honeycomb npm packagesOnce Node.js is installed you will able to use npm commands in the terminal. To install the dependencies for HoneyComb run the following command at the terminal (remember you need cd your-new-task-name before) npm install  ","version":"2.x","tagName":"h3"},{"title":"4. Run the task in dev mode​","type":1,"pageTitle":"Quick Start","url":"/docs/2.x/quick_start#4-run-the-task-in-dev-mode","content":"To launch an electron window with the task with the inspector open to the console and will hot-reload when changes are made to the app For Mac and Linux: npm run dev For Windows: You will need to open 2 terminals. In the first -and make sure you are in the task-&lt;TASK NAME&gt; repo directory- run the command: npm start In the second terminal - make sure you are in the task-&lt;TASK NAME&gt; repo directory-, run: npm run electron-dev  ","version":"2.x","tagName":"h3"},{"title":"5. Run the task with preset environment variables​","type":1,"pageTitle":"Quick Start","url":"/docs/2.x/quick_start#5-run-the-task-with-preset-environment-variables","content":"We have provided various .env files and npm scripts to run the task in common settings like home or clinic. Here are the possible commands: npm run dev:home  npm run dev:home:video  npm run dev:clinic  npm run dev:clinic:video  npm run dev:firebase  ","version":"2.x","tagName":"h3"},{"title":"6. Check out the data​","type":1,"pageTitle":"Quick Start","url":"/docs/2.x/quick_start#6-check-out-the-data","content":"The data is saved throughout the task to the users's app directory. This is logged at the beginning of the task wherever you ran npm run dev (for windows, instead in two different terminals ran npm start and npm run electron-dev). It is also stored in a folder that is generated by the app, which should be found on the desktop. ","version":"2.x","tagName":"h3"},{"title":"7. Quit The Task​","type":1,"pageTitle":"Quick Start","url":"/docs/2.x/quick_start#7-quit-the-task","content":"If you want to quit in the middle of the task, you can use these keyboard shortcuts: Ctrl+W (for PC/Windows)  Cmd+Q (for Mac)  Partial data will be saved. ","version":"2.x","tagName":"h3"},{"title":"7. Merge updates from honeycomb template repo​","type":1,"pageTitle":"Quick Start","url":"/docs/2.x/quick_start#7-merge-updates-from-honeycomb-template-repo","content":"Honeycomb is an active project, and will be updated with new features over time. To merge the honeycomb template repository updates with your task, follow the following steps: First time only: git remote add honeycomb https://github.com/brown-ccv/honeycomb.git  Every time: git fetch --all  git merge honeycomb/main --allow-unrelated histories  If there are any conflicts: git stash  To merge: git commit -a -m &quot;merge honeycomb latest&quot;  ","version":"2.x","tagName":"h3"},{"title":"8. Run automated tests​","type":1,"pageTitle":"Quick Start","url":"/docs/2.x/quick_start#8-run-automated-tests","content":"When getting started, merging updates, or making custom changes, it's a good idea to run automated tests. These can tell you if things are working or if recent changes broke something that previously worked. To run the tests interactively: npm test  Or non-interactively: CI=true npm test  Linux​ When running npm test on Linux, you might get an error that mentions ENOSPC. This is because the test runer creates &quot;watchers&quot; for files in the project repo in order to automatically re-run tests as the files change. Linux limits the number of watchers that can be created at a time and the default limit may be smaller than the number of files in the repo. This is a &quot;known issue&quot; with some test runners on Linux, as in discussions here and here. One simple workaround is to increase the number of allowed watchers (100000 seems to be sufficient): Command that initially fails with ENOSPC: npm testCheck the configured limit on &quot;watchers&quot;: cat /proc/sys/fs/inotify/max_user_watchesEdit the relevant Linux config file: sudo vim /etc/sysctl.confAdd a line at the end of the config file: fs.inotify.max_user_watches=100000Save, exit, and reload the config file: sudo sysctl -pCheck that the limit has changed: cat /proc/sys/fs/inotify/max_user_watchesRetry the initial command, which should now succeed: npm test ","version":"2.x","tagName":"h3"},{"title":"Version Control","type":0,"sectionRef":"#","url":"/docs/2.x/version_control","content":"","keywords":"javascript  jspsych","version":"2.x"},{"title":"Git Overview​","type":1,"pageTitle":"Version Control","url":"/docs/2.x/version_control#git-overview","content":"Git is a version control system that enables you to track changes to files. With Git, you are able to revert files back to previous versions, restore deleted files, remove added files and even track down where a particular line of code was introduced. Git creates a hidden .git folder (in the current folder) to store the details of the file system - this folder contains all the data required to track your files and is known as a repository, or repo. Git tracks file changes by the user creating a save point, or in Git terms a commit. Each commit takes a snapshot of the current file system. Commits are uniquely identified by a SHA–1 hash. This is a 40 character string which may along the lines of ded7a0db6422d59e9893e975e32275fc36f853daThis hash can be used to track a particular commit within the repository. Nearly all operations that are performed by Git are in you local computing environment, for the exception of few used purely to synchronize with a remote. Some of the most common git operations are depicted below. In summary, a typical flow consists of making changes to your files, staging them via git add, marking a save point via git commit, then finally syncing to your remote (e.g., GitHub) via git push. If you are pushing changes to your remote from multiple places, you can bring changes your most recent version using git pull, which is the equivalent of doing git fetch followed by a git merge operation  ","version":"2.x","tagName":"h2"},{"title":"Cheatsheet​","type":1,"pageTitle":"Version Control","url":"/docs/2.x/version_control#cheatsheet","content":"Command\tBriefgit add &lt;files&gt;\tadd a file to next commit (stage) git commit -m &lt;message&gt;\tcommit staged files git push\tupload staged commit to repo git pull\tget remote repo commits and download (try and resolve conflicts) git clone &lt;url&gt;\tdownload entire repository ","version":"2.x","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Version Control","url":"/docs/2.x/version_control#best-practices","content":"","version":"2.x","tagName":"h2"},{"title":"Workflow​","type":1,"pageTitle":"Version Control","url":"/docs/2.x/version_control#workflow","content":"We recommend a simple flow based on following rules: Use topic/feature branches, no direct commits on main.Perform tests and code reviews before merges into main, not afterwards.Everyone starts from main, and targets main.Commit messages reflect intent. ","version":"2.x","tagName":"h3"},{"title":"Branches​","type":1,"pageTitle":"Version Control","url":"/docs/2.x/version_control#branches","content":"main is the default branch and where releases are made off. This branch should be in clean/working conditions at all times. This branch is protected and can only be merged from Pull Requests for topic branchestopic branches are created for new features, fixes, or really any changes ","version":"2.x","tagName":"h3"},{"title":"Comment styles​","type":1,"pageTitle":"Version Control","url":"/docs/2.x/version_control#comment-styles","content":"We encourage using Commitizen, a great tool for writing angular commits - this will create a standardized commit format which makes for easier change logging and more sane messages. ","version":"2.x","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/3.0.0/","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"Flexible deployment online and in the lab​","type":1,"pageTitle":"Introduction","url":"/docs/3.0.0/#flexible-deployment-online-and-in-the-lab","content":"Honeycomb provides the ability to write one codebase and use it flexibly across settings (with guaranteed consistency in instructions, timing, etc.). The same code-base is used to maintain and deploy the identical task on Mechanical Turk, Prolific, and in research settings during concurrent electrophysiological recordings. ","version":"3.0.0","tagName":"h3"},{"title":"Easy to install executables​","type":1,"pageTitle":"Introduction","url":"/docs/3.0.0/#easy-to-install-executables","content":"Deployment specifications are abstracted as parameters that are easy to configure, and application building is automated via GitHub actions providing continuous delivery of easy-to-download executables, easing setup burden across research sites. ","version":"3.0.0","tagName":"h3"},{"title":"Foundation in jsPsych​","type":1,"pageTitle":"Introduction","url":"/docs/3.0.0/#foundation-in-jspsych","content":"jsPsych 7 tasks can be converted to the Honeycomb structure to take advantage of the flexible deployment and automated GitHub Actions workflow that Honeycomb provides. ","version":"3.0.0","tagName":"h3"},{"title":"Community Driven​","type":1,"pageTitle":"Introduction","url":"/docs/3.0.0/#community-driven","content":"Honeycomb additionally provides a Behavioral Task Hub at our Beehive website. These tasks are built in Honeycomb and are ready to be deployed. ","version":"3.0.0","tagName":"h3"},{"title":"Cite this work​","type":1,"pageTitle":"Introduction","url":"/docs/3.0.0/#cite-this-work","content":"If you use Honeycomb in your work, please cite Provenza, N.R., Gelin, L.F.F., Mahaphanit, W., McGrath, M.C., Dastin-van Rijn, E.M., Fan, Y., Dhar, R., Frank, M.J., Restrepo, M.I., Goodman, W.K. and Borton, D.A., 2021. Honeycomb: a template for reproducible psychophysiological tasks for clinic, laboratory, and home use. Brazilian Journal of Psychiatry, 44, pp.147-155. ","version":"3.0.0","tagName":"h3"},{"title":"Configuration","type":0,"sectionRef":"#","url":"/docs/3.0.0/configuration","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"Environment Variables​","type":1,"pageTitle":"Configuration","url":"/docs/3.0.0/configuration#environment-variables","content":"Honeycomb uses environment variables during build and run time to control the different configurations. Below we list the environment variables used by the app and indicate their properties via badges and text. Optional variables are labeled with the badge and mandatory variables are labeled with the badge with their default value specified. The badge indicates the variable is used during the build/compilation phase (npm build) while the badge indicates the variable is used during the executable run (npm run dev). ","version":"3.0.0","tagName":"h2"},{"title":"Dev Mode Only​","type":1,"pageTitle":"Configuration","url":"/docs/3.0.0/configuration#dev-mode-only","content":"ELECTRON_START_URL : URL (e.g. http://localhost:3000) where the front end of the app is being hosted - also used in electron.js to indicate the app is running in dev mode. ","version":"3.0.0","tagName":"h3"},{"title":"Desktop Only​","type":1,"pageTitle":"Configuration","url":"/docs/3.0.0/configuration#desktop-only","content":"EVENT_MARKER_PRODUCT_ID: The product ID of the event marker (e.g. 0487). If not set, it will use the productID set in public/config/trigger.js if available, or attempt to connect using the com name.EVENT_MARKER_COM_NAME : The com name of the event marker (e.g. COM3). If not set, it will use the comName set in public/config/trigger.js. If the productID is set (not an empty string), this field will be ignored.REACT_APP_VIDEO: whether the participant is being video recorded. This can be used when the task is running as a desktop app (electron).REACT_APP_USE_EEG: whether the event marker/EEG is available. This can be used when the task is running as a desktop app (electron).REACT_APP_USE_PHOTODIODE: whether the photodiode is in use. This can be used when the task is running as a desktop app (electron). ","version":"3.0.0","tagName":"h3"},{"title":"Desktop and Online​","type":1,"pageTitle":"Configuration","url":"/docs/3.0.0/configuration#desktop-and-online","content":"REACT_APP_VOLUME: whether the participant is being asked to adjust volume. This can be used on both the desktop (electron) and online settings.REACT_APP_PARTICIPANT_ID : The default participant id to show when authorizing a participant. If not set, user will need to enter the value in the provided input box.REACT_APP_STUDY_ID : The default study id to show when authorizing a participant. If not set, user will need to enter the value in the provided input box. ","version":"3.0.0","tagName":"h3"},{"title":"Understanding Build Time and Run Time Variables​","type":1,"pageTitle":"Configuration","url":"/docs/3.0.0/configuration#understanding-build-time-and-run-time-variables","content":": Run-time environment variables allow for quick changes before running the task. They are convenient since they don't require building a whole different executable. For a Desktop Application, these are set at the system level and must be available at the time where the task runs. See this tutorial for OS specific instructions.. For a Firebase Application, these must be stored in the Firestore. : Build-time environment variable are configured before the application is built and cannot be changed at run-time. They are configured via .env files before building. Instead of using a single .env file, we prefer to defined separate files under the env/ directory, and use a package called dotenv-cli before building`. The dotenv-cli comes with the dotenv command that can be used to properly load the needed variables. This command does not run directly from the command line (terminal). Instead, to set build-time environment variables, we need to add a script to package.json with the following format: &quot;[build|dev]:&lt;script name&gt;&quot;: &quot;dotenv -e env/&lt;your env file&gt; npm run [build|dev]&quot;  Honeycomb includes so scripts for common scenarios. For instance, you can run: npm run dev:home  npm run dev:home:video  npm run dev:clinic  npm run dev:clinic:video  npm run dev:firebase  ","version":"3.0.0","tagName":"h3"},{"title":"Automated Builds","type":0,"sectionRef":"#","url":"/docs/3.0.0/ci","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"What is CI/CD?​","type":1,"pageTitle":"Automated Builds","url":"/docs/3.0.0/ci#what-is-cicd","content":"CI/CD refers to Continuous Integration and either Continuous Delivery or Continuous Deployment. CI/CD enforces the automated building of bundled executables so that tasks can be easily installed without dependencies. In Honeycomb, CI/CD is managed by GitHub Actions. ","version":"3.0.0","tagName":"h2"},{"title":"What are Github Actions​","type":1,"pageTitle":"Automated Builds","url":"/docs/3.0.0/ci#what-are-github-actions","content":"GitHub Actions automate tasks within the development life cycle of your software. GitHub Actions consist of a series of commands that run after a specified event has occurred. For example, every time someone creates a pull request for a repository, you can automatically run a command to build and test your software. You can learn more about the events that trigger workflows in GitHub's documentation GitHub Actions are written as YML files inside a .github/worflows/ folder in your repository. ","version":"3.0.0","tagName":"h2"},{"title":"Building the executables​","type":1,"pageTitle":"Automated Builds","url":"/docs/3.0.0/ci#building-the-executables","content":"Honeycomb includes workflows to build and create installers for Windows. Mac and Linux. These workflows exist for two configurations of the tasks: Home: The app does not expect event code triggers and photodiode spots.Clinic: The app expects event code triggers and photodiode spots. More specifically, the following workflows are included: build.yaml: Every time an Pull Request (PR) is opened, or a push is made to the main branch, the software is built and tests are run for all platforms and home and clinic settings. This workflow does not build and upload desktop installerspackage.yaml: Create installers for any/all platforms for the home and clinic setting on demand 1. The installers/executables are uploaded as artifacts and are available for download from the GitHub Actions tab. This also builds PsiTurk version when linux or all operating systems are selectedrelease.yml: Every time a Tag is released, installers are created and uploaded as packages. This also builds PsiTurk version, and deploys to GitHub pages a web version of the application. 1 On-demand workflows are triggered manually from the GitHub Actions tab. Each GitHub organization/individual has a quota on storage on private repositories. Uploading artifacts counts against your quota. You may consider configuring your workflows to only upload what you need. You can learn more about GitHub's storage limits in their [official documentation](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#about-billing-for-github-actions). ","version":"3.0.0","tagName":"h2"},{"title":"Download your bundled executable to install and run your task​","type":1,"pageTitle":"Automated Builds","url":"/docs/3.0.0/ci#download-your-bundled-executable-to-install-and-run-your-task","content":"You can download the executable file from either the tagged release page or the GitHub actions page. To install, unzip the downloaded file, install and run. The executable does not require installation of any additional software. ","version":"3.0.0","tagName":"h3"},{"title":"Uninstall the task​","type":1,"pageTitle":"Automated Builds","url":"/docs/3.0.0/ci#uninstall-the-task","content":"Windows​ Go to System Settings: Add or remove programs. Look for the name of your task in the installed programs list, and Uninstall. The executable does not require installation of any additional software. ","version":"3.0.0","tagName":"h3"},{"title":"Firebase Hosting​","type":1,"pageTitle":"Automated Builds","url":"/docs/3.0.0/ci#firebase-hosting","content":"Automatic deployment on a firebase hosting site can also be setup with github actions. Before proceeding with the following steps, please make sure that firebase is configured by following the Getting started with firebase section under Set Up Firebase. Then run the following command in the terminal: firebase init hosting:github  Be sure to type &quot;&lt;username&gt;/&lt;repository name&gt;&quot; exactly as it appears in GitHub when the prompt &quot;For which GitHub repository would you like to set up a GitHub workflow?&quot; appears. When you see the prompt &quot;Set up the workflow to run a build script before every deploy?&quot; enter y Enter the following command for the prompt &quot;What script should be run before every deploy?&quot;: npm install &amp;&amp; npm run build:firebase When you see the prompt &quot;Set up automatic deployment to your site's live channel when a PR is merged?&quot; enter y Enter &quot;main&quot; for the prompt &quot;What is the name of the GitHub branch associated with your site's live channel?&quot; There should be two new .yml files, firebase-hosting-pull-request.yml and firebase-hosting-merge.yml, created in the .github/workflows directory for a deployment preview for each pull request and the official deployment when merged onto the main branch. Double check that the correct run script is present in both files.  ","version":"3.0.0","tagName":"h2"},{"title":"Set up event triggers","type":0,"sectionRef":"#","url":"/docs/3.0.0/event_triggers","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"BrainVision Trigger Box setup​","type":1,"pageTitle":"Set up event triggers","url":"/docs/3.0.0/event_triggers#brainvision-trigger-box-setup","content":"Follow the TriggerBox setup instructions in the BrainVision Trigger Box manual. Plug the TriggerBox into the computer running the task. Check your operating system’s device list to identify the COM port that the TriggerBox is connected to. Create a new system environment variable: COMNAME  and set to the COM port to the correct value (e.g., COM3). ","version":"3.0.0","tagName":"h2"},{"title":"Open Source Event Trigger setup​","type":1,"pageTitle":"Set up event triggers","url":"/docs/3.0.0/event_triggers#open-source-event-trigger-setup","content":"Details on how to make the open source event trigger and photodiode can be found here. Connect the open source event trigger to the computer running the task using a USB to micro-USB cable. Check your operating system’s USB device list to identify the product ID of the teensyduino event marker. Create a new system environment variable: EVENT_MARKER_PRODUCT_ID and set to the product ID of the event marker. ","version":"3.0.0","tagName":"h2"},{"title":"Send event code triggers​","type":1,"pageTitle":"Set up event triggers","url":"/docs/3.0.0/event_triggers#send-event-code-triggers","content":"Change the eventCodes values listed in the src/config/trigger.js file to the desired values. Import eventCodes from ./trigger and export as eventCodes. Whenever you would like to send an event code in a trial, load eventCodes from ../config/main/, and call pdSpotEncodewith the proper eventCode (e.g. eventCode.Fixation) as input. ","version":"3.0.0","tagName":"h2"},{"title":"Run the task with event triggers​","type":1,"pageTitle":"Set up event triggers","url":"/docs/3.0.0/event_triggers#run-the-task-with-event-triggers","content":"Honeycomb automatically checks whether your event marker is connected and running at the start of the task. If it is not connected, the task will present an error and will not be able to run. ","version":"3.0.0","tagName":"h2"},{"title":"Set up Firebase","type":0,"sectionRef":"#","url":"/docs/3.0.0/firebase","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"Setting up Firebase​","type":1,"pageTitle":"Set up Firebase","url":"/docs/3.0.0/firebase#setting-up-firebase","content":"","version":"3.0.0","tagName":"h2"},{"title":"0. Installing the Firebase Command Line Interface​","type":1,"pageTitle":"Set up Firebase","url":"/docs/3.0.0/firebase#0-installing-the-firebase-command-line-interface","content":"To check if firebase has been installed, type firebase into a terminal window. firebase  If a list of options are printed on the terminal then the firebase tool has already been installed. If not, you will get an error - something along the lines of &quot;Command not found.&quot; The firebase-cli can then be installed using npm: npm install -g firebase-tools  The -g flag installs an npm package globally on your system, as opposed to the current project ","version":"3.0.0","tagName":"h3"},{"title":"1. Initializing Firebase account and project​","type":1,"pageTitle":"Set up Firebase","url":"/docs/3.0.0/firebase#1-initializing-firebase-account-and-project","content":"Create and login to a Firebase account on the Firebase website. Create a Firebase project by clicking add project and enter a Project Name. ","version":"3.0.0","tagName":"h3"},{"title":"2. Linking firebase to task​","type":1,"pageTitle":"Set up Firebase","url":"/docs/3.0.0/firebase#2-linking-firebase-to-task","content":"Login to Firebase using firebase login command in the terminal. Navigate to the .firebaserc file home directory and edit the &quot;default&quot; field with the project name given in part 1. { &quot;projects&quot;: { &quot;default&quot;: &quot;&lt;your project name&gt;&quot; } }  ","version":"3.0.0","tagName":"h3"},{"title":"3. Copying web app credentials​","type":1,"pageTitle":"Set up Firebase","url":"/docs/3.0.0/firebase#3-copying-web-app-credentials","content":"Navigate to the firebase console and select the project.Create a new Web App by clicking on Add App or the &lt;/&gt; code symbol and following the prompts.Enter the a name for the Firebase app (could be the same as your Honeycomb task repo name).Check &quot;Also set up Firebase Hosting for this app.&quot;Click Register App. This should auto-generate a script with several values that you need to copy into the next step.Copy the auto-generated values from the Firebase console to the corresponding variables in the .env.firebase file in the env folder of your Honeycomb task repo: REACT_APP_FIREBASE=&quot;true&quot; REACT_APP_apiKey= REACT_APP_authDomain= REACT_APP_projectId= REACT_APP_storageBucket= REACT_APP_messagingSenderId= REACT_APP_appId=  Copy the auto-generated values from the Firebase console to the corresponding variables in the .env.firebase you just created. You only need to copy the variables referenced here. If you enabled Google Analytics during project creation, additional variables may be printed in the console. You don't need to copy those. Firebase is now set up! ","version":"3.0.0","tagName":"h3"},{"title":"Setting up Firestore​","type":1,"pageTitle":"Set up Firebase","url":"/docs/3.0.0/firebase#setting-up-firestore","content":"Honeycomb includes cloud storage for task data using Firestore. Follow these steps to initialize Firestore: Navigate to the current project in the developer console and select Firestore Database from the sidebar.Click Create Database, select production mode and choose the current location for the cloud storage bucket. ","version":"3.0.0","tagName":"h2"},{"title":"Firestore security rules​","type":1,"pageTitle":"Set up Firebase","url":"/docs/3.0.0/firebase#firestore-security-rules","content":"Firestore Security Rules provides easy server-side authorization to the database. For a honeycomb task, we use the security rules to allow access to only authorized participants for a specified study. Honeycomb's default set of rules is included in the firestore.rules file in the home directory. This file can be edited to change the rules. To deploy the rules in the file, type the following line of code in the terminal: firebase deploy --only firestore:rules  Alternatively, Editing the rules directly in the console is also possible. To do so, navigate to the Rules tab in the Firestore Database section from the firebase console sidebar then copy and paste the code that is in the firestore.rules file. Firestore database and rules are now both deployed. For Honeycomb's default set of rules, to add an authorized participant for a study, create a collection named registered_studies, add a study with the study ID as the document name in that collection. For each registered study, add an array field named registered_participants where each element in the array will be an authorized participant for that study.  ","version":"3.0.0","tagName":"h3"},{"title":"NPM Scripts","type":0,"sectionRef":"#","url":"/docs/3.0.0/npm_scripts","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"npm run dev​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.0.0/npm_scripts#npm-run-dev","content":"Runs npm start and npm run electron-dev concurrently. This may not play nicely with windows. If it doesn't, run npm start and npm run electron-dev from different terminal windows. ","version":"3.0.0","tagName":"h3"},{"title":"npm start​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.0.0/npm_scripts#npm-start","content":"Runs the app in the development mode. Open http://localhost:3000 to view it in the browser. The page will reload if you make edits. You will also see any lint errors in the console. ","version":"3.0.0","tagName":"h3"},{"title":"npm test​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.0.0/npm_scripts#npm-test","content":"Launches the test runner in the interactive watch mode. See the section about running tests for more information. ","version":"3.0.0","tagName":"h3"},{"title":"npm build​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.0.0/npm_scripts#npm-build","content":"Creates a production build of the app (renderer). This must be done before running package:platform or the psiturk build instructions. ","version":"3.0.0","tagName":"h3"},{"title":"npm run package:platform​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.0.0/npm_scripts#npm-run-packageplatform","content":"Uses Electron to build the app and create a standalone installer for the given platform. Supported platforms are: npm run package:windowsnpm run package:linuxnpm run package:mac The output can be found in the ./out subfolder. Note: Packaging for windows on a non-windows machine requires mono and wine to be installed. ","version":"3.0.0","tagName":"h3"},{"title":"npm run eject​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.0.0/npm_scripts#npm-run-eject","content":"Note: this is a one-way operation. Once you eject, you can’t go back! If you aren’t satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (Webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own. You don’t have to ever use eject. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it. ","version":"3.0.0","tagName":"h3"},{"title":"Run Electron​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.0.0/npm_scripts#run-electron","content":"npm run electron​ Run the built app. npm run electron-dev​ Run the current state of the code (un-built). ","version":"3.0.0","tagName":"h3"},{"title":"Deploy online","type":0,"sectionRef":"#","url":"/docs/3.0.0/online_integration","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"Usage with PsiTurk​","type":1,"pageTitle":"Deploy online","url":"/docs/3.0.0/online_integration#usage-with-psiturk","content":"While this set up is optimized for Electron, we added functionality that will make use with PsiTurk easy. The application will detect if it's being used in a Turk environment and will: Save the data to the default PsiTurk SQLite database. Switch the language to Turk specific, if src/language/&lt;locale&gt;.mturk.json exists. Use the Turk specific timeline if different than the primary timeline.  ","version":"3.0.0","tagName":"h2"},{"title":"Prebuilt version​","type":1,"pageTitle":"Deploy online","url":"/docs/3.0.0/online_integration#prebuilt-version","content":"When GitHub Actions is run, a psiturk build will be created automatically, and can be downloaded from its artifacts (skip next step if using). The workflows responsible for building the PsiTurk application are .github/workflows/package-home-all.yml and .github/workflows/release-home-all.yml. The first one has to be triggered manually, the latter is triggered when you tag a release. ","version":"3.0.0","tagName":"h3"},{"title":"Build instructions​","type":1,"pageTitle":"Deploy online","url":"/docs/3.0.0/online_integration#build-instructions","content":"To set up your PsiTurk project, we provide a script that does the conversion. PsiTurk is a Python package used to manage HITs in Mechanical Turk. Before using the provided script, install PsiTurk. You'll need to follow these steps (the path to the PsiTurk project should be a directory you wish to be created): Build the application: npm run build Move to the psiturkit directory: cd psiturkit If it's the first time you're running the script: ./psiturk-it -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt; To update an existing PsiTurk project (the path to the PsiTurk project should already exist from the previous steps): ./psiturk-it -u -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt; ","version":"3.0.0","tagName":"h3"},{"title":"Running psiturk​","type":1,"pageTitle":"Deploy online","url":"/docs/3.0.0/online_integration#running-psiturk","content":"After that, just navigate to your newly created PsiTurk project directory. shell&gt; psiturk #start psiturk psiturk&gt; server on #start server psiturk&gt; debug #debug mode  ","version":"3.0.0","tagName":"h3"},{"title":"Running on the Web​","type":1,"pageTitle":"Deploy online","url":"/docs/3.0.0/online_integration#running-on-the-web","content":"","version":"3.0.0","tagName":"h2"},{"title":"Using Github Pages​","type":1,"pageTitle":"Deploy online","url":"/docs/3.0.0/online_integration#using-github-pages","content":"Running npm run build generates static content into the build directory that can be served using any static contents hosting service. The workflow .github/workflows/release-home-all.yml uploads the build directory to the gh-branch to serve the application on GitHub pages as an example. After a creating a tag, the workflow will run and your application will be served at &lt;githubuser&gt;.github.io/&lt;repository&gt;. For this step to succeed you will need to create a deploy key and enable GitHub Pages for your repository. Generate a new SSH key.By default, your public key should have been created in ~/.ssh/id_rsa.pub or use the name you've provided.Copy key to clipboard with xclip -sel clip &lt; ~/.ssh/id_rsa.pub and paste it as a deploy key in your repository. Copy file content if the command line doesn't work for you. Check the box for Allow write access before saving your deployment key.You'll need your private key as a GitHub secret to allow the workflow to run the deployment for you.To create the secret copy your private key e.g. xclip -sel clip &lt; ~/.ssh/id_rsa and paste a GitHub secret with name GH_PAGES_DEPLOY. Copy file content if the command line doesn't work for you. Save your secret.Make sure the publishing source for your repository is configured for gh-pages branch. ","version":"3.0.0","tagName":"h3"},{"title":"Using Firebase​","type":1,"pageTitle":"Deploy online","url":"/docs/3.0.0/online_integration#using-firebase","content":"We have included methods and configurations for close integration with firebase. Before proceeding with the follwing steps, please make sure that firebase is configured by following the Getting started with firebase section under Set Up Firebase. Run npm run build:firebase in the terminal to create a production build for firebase.Run firebase deploy in the terminal to deploy the production build.The production build is now deployed to the firebase project domain. To automate firebase deployments, we have included instructions on setting up firebase github actions on our Automated Builds page ","version":"3.0.0","tagName":"h3"},{"title":"Project Organization","type":0,"sectionRef":"#","url":"/docs/3.0.0/folders","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"package.json​","type":1,"pageTitle":"Project Organization","url":"/docs/3.0.0/folders#packagejson","content":"The package.json file contains metadata about your project and scripts to run tasks related to your task. The name should be updated to your task's name and scripts can be added as desired, but otherwise this file should not be edited manually. To remove or add a dependency use npm install or npm uninstall with the -D flag if installing a dev dependency. The package-lock.json contains metadata about the package installation. It should never be manually updated. ","version":"3.0.0","tagName":"h3"},{"title":"assets/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.0.0/folders#assets","content":"This folder contains any static files that are used by the app, such as the images used as icons for the installed applications. ","version":"3.0.0","tagName":"h3"},{"title":"env/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.0.0/folders#env","content":"This folder contains different .env files with presets for common use cases. These files can be loaded with dotenv, which is explained in greater detail in the Configuration section. ","version":"3.0.0","tagName":"h3"},{"title":".github/workflows/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.0.0/folders#githubworkflows","content":"This folder contains different .yaml files which are used to configure the build tests (build.yaml) following a push and to create task executables either in a single instance (package.yaml) or for a full release (release.yaml). ","version":"3.0.0","tagName":"h3"},{"title":"public/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.0.0/folders#public","content":"The public directory contains files that are used as assets in the built app. The favicon.ico is the small icon you can see in the browser tab (on Chrome) - it is set to Brown's logo in the project. The index.html contains the shell of your website - the name displayed on the tab can be changed here, otherwise it shouldn't need to be edited. The scripts included in the file are for psiturk as are the files in the lib/ directory. electron.js​ This file contains all of the code relating to the Electron app. This includes the event-marker, throwing errors via dialog windows, saving data, and reading files. config/​ The config directory contains the config files needed for the electron app. This includes the event-marker details and event codes. In the config/ directory, there are .js files which contain settings for the different parts of the task. Every task should have a main config and a trigger config (assuming use of the event marker). The main config has all global settings for the task (such as whether it is in mturk mode or not), load the appropriate language file, and set up a default (or only) configuration object for the task. Different in-task features can be loaded from .env files and is set in the main config. For example, we have included some of these files in the env directory (e.g. env.clinic file enables event marker, photodiode and volume adjustment). The trigger config has settings specific to the event marker and uses a slightly different style of javascript as it is imported both in the React app as well as the electron process. Other config files can be used to add settings for specific blocks or sub-sections of the experiment. Also, note that the productId can be overwritten by the environment variable EVENT_MARKER_PRODUCT_ID. ","version":"3.0.0","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.0.0/folders#src","content":"This folder contains the code for the app, the vast majority of changes and code should go here. App.jsx​ This is the starting point for the app. The &lt;Login&gt; component handles user authentication in the different use cases and the &lt;JsPsychExperiment&gt; component initializes the jspsych 7 experiment. This is also where communication is set up with the electron and psiturk processes. App.css​ This is where styling for the app is housed. If colors, fonts, spacing, etc. need to be set, do it here. components/​ This folder contains the components referenced in App.jsx. This includes the Honeycomb &lt;JsPsychExperiment&gt; component which connects the Honyecomb login page to your jspsych 7 experiment. language/​ Any language that is displayed in the experiment should be stored in this folder. Usage of language json files allows for easy internationalization of the task (e.g. English and Spanish) as well as allows for mturk-specific language. This also makes it easy to re-use common phrases in many places in the task. lib/​ The lib/ directory contains utility functions and markup that is used in the tasks. This allows for functions and html to be re-used wherever needed. The lib/utils.js file contains functions that are generally useful across many tasks, whereas lib/taskUtils.js contains functions specific to this task. lib/markup​ markup files should contain primarily templates for HTML that are used throughout the task. Typically this will be a function that takes in some parameters and then returns a string with html. timelines​ jspsych uses timelines to control what trials are displayed in what order. timelines can contain other timelines, which is why there may be several files in this directory. The main.js file should have the timeline that is called by App.jsx in the &lt;JsPsychExperiment&gt; component. trials​ jspsych uses trials as its base unit of an experiment. These trials do things such as display some stimulus or request a response. ","version":"3.0.0","tagName":"h3"},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"/docs/3.0.0/troubleshooting","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"Inspecting Errors​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.0.0/troubleshooting#inspecting-errors","content":"When developing electron apps there are two processes: main, and renderer. In this case main corresponds to electron-starter.js and its console is wherever you called npm run dev or electron . from. renderer corresponds to the React App - this is everything else. The react app's console is in the electron/browser window and can be seen by using dev tools to inspect the window. When running npm run dev, it should open by default. In case you want to find out where the error is coming from when running the app locally: Try reviewing logs in the terminalInspect element in your browser by openning your developer tools. For instance, in Chrome, this can be done via the menu View -&gt; Developer or right-clicking and pressing inspect. ","version":"3.0.0","tagName":"h2"},{"title":"Package not found or other error related to npm​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.0.0/troubleshooting#package-not-found-or-other-error-related-to-npm","content":"Try deleting your node_modules folder and the package-lock.json then running npm install then npm run rebuild. ","version":"3.0.0","tagName":"h2"},{"title":"Testing in Linux​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.0.0/troubleshooting#testing-in-linux","content":"When running npm test on Linux, you might get an error that mentions ENOSPC. This is because the test runer creates &quot;watchers&quot; for files in the project repo in order to automatically re-run tests as the files change. Linux limits the number of watchers that can be created at a time and the default limit may be smaller than the number of files in the repo. This is a &quot;known issue&quot; with some test runners on Linux, as in discussions here and here. One simple workaround is to increase the number of allowed watchers (100000 seems to be sufficient): Command that initially fails with ENOSPC: npm testCheck the configured limit on &quot;watchers&quot;: cat /proc/sys/fs/inotify/max_user_watchesEdit the relevant Linux config file: sudo vim /etc/sysctl.confAdd a line at the end of the config file: fs.inotify.max_user_watches=100000Save, exit, and reload the config file: sudo sysctl -pCheck that the limit has changed: cat /proc/sys/fs/inotify/max_user_watchesRetry the initial command, which should now succeed: npm test ","version":"3.0.0","tagName":"h2"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/docs/3.0.0/quick_start","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"1. Install a Package Manager​","type":1,"pageTitle":"Quick Start","url":"/docs/3.0.0/quick_start#1-install-a-package-manager","content":"There are some prerequisites that are required across all operating systems to run Honeycomb. We will be using a package manager to install these dependencies. MacOS Package Manager (Homebrew)​ Paste the following in a macOS Terminal and press enter to install Homebrew, then follow the steps in the terminal screen. /bin/bash -c '$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)'  When this command is run, additional installations may be automatically added by Homebrew based on your machine's configurations. Homebrew will prompt you to Press RETURN to continue or any other key to abort. Please continue with these installations by pressing Return Set up Homebrew on your PATH​ To make Homebrew available in your shell, we need to add the Homebrew installation location to our PATH. This should be done automatically on macOS 10.14 Mojave or newer. For older versions, or to do it manually run the following command in your terminal. echo 'PATH=&quot;/usr/local/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile  If you're using zsh, also add to your ~/.zshrc file. Windows Package Manager (Chocolatey)​ Chocolatey is a package manager for Windows - essentially the equivalent of Homebrew for MacOs. It installs software from the command line and makes updates much easier. Run Powershell with administrator privileges and paste the following command:  Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))  ","version":"3.0.0","tagName":"h3"},{"title":"2. Start your new task from our template repository​","type":1,"pageTitle":"Quick Start","url":"/docs/3.0.0/quick_start#2-start-your-new-task-from-our-template-repository","content":"To start a new task locally, in development mode follow these steps: The simplest way to get started is creating a new repository using Honeycomb as a template. This option will allow you to generate a new repository with the same directory structure and files as an existing repository. Creating a repository from a template is similar to forking a repository, but there are important differences: A new fork includes the entire commit history of the parent repository, while a repository created from a template starts with a single commit.Commits to a fork don't appear in your contributions graph, while commits to a repository created from a template do appear in your contribution graph.A fork can be a temporary way to contribute code to an existing project, while creating a repository from a template starts a new project quickly. Go to https://github.com/brown-ccv/honeycomb and click on Use this template on the top right.  Then select the organization and the name of your repository and click on create repository from template.  Alternatively, you can use GitHub CLI to create a new project based on the Honeycomb template repository. First, install GitHub CLI (https://cli.github.com/), then run on your terminal: gh repo create your-new-task-name --template brown-ccv/honeycomb  You can now move into the directory that was just created cd your-new-task-name  ","version":"3.0.0","tagName":"h3"},{"title":"3. Install Prerequisites​","type":1,"pageTitle":"Quick Start","url":"/docs/3.0.0/quick_start#3-install-prerequisites","content":"Running Brewfile (macOS)​ A Brewfile is a script that developers can use to install multiple software tools that are required to run an application. brew bundle  This will call the brew command which will install all the listed packages to your project. Using Chocolatey (Windows)​ Chocolatey will install multiple software packages if given a configuration file. The honeycomb template repository includes one! See Setup Details for more information about using chocolatey. choco install chocolatey.config  Python on Windows​ In addition to the packages installed by Chocolatey you need to complete your Python installation using pyenv. Please complete the steps in Python on Windows before continuing. ","version":"3.0.0","tagName":"h3"},{"title":"4. Change name and description​","type":1,"pageTitle":"Quick Start","url":"/docs/3.0.0/quick_start#4-change-name-and-description","content":"It's best practice to create a new branch whenever we look to make changes and/or add a new feature. Your IDE may have a way to do this or it can always be done on the command line. git checkout -b &lt;branch-name&gt;  Open package.json and edit it to reflect your app name and description (e.g. name, author, repository). Save your changes and commit them to git: git commit -m &quot;Commit message goes here!&quot;  Checkout the Version Control page for more information about working with git ","version":"3.0.0","tagName":"h3"},{"title":"5. Install NPM Packages​","type":1,"pageTitle":"Quick Start","url":"/docs/3.0.0/quick_start#5-install-npm-packages","content":"npm is a command-line utility for Node.js that makes it easy for you to install packages and maintain them throughout the lifecycle of your application. With Node.js installed in Step 0, we are now able to utilize the npm command in the terminal. Please run the following command to trigger the installation of all the dependencies relevant to this project: npm install  Honeycomb, like most applications, contains a template called package.json. This file contains three distinctive parts that we interact with using a series of npm commands. Metadata​ { &quot;name&quot;: &quot;honeycomb&quot;, &quot;description&quot;: &quot;all-in-one task starter app with jsPsych + React + Electron + psiturk &quot;, &quot;author&quot;: { &quot;name&quot;: &quot;Brown CCV&quot;, &quot;email&quot;: &quot;ccv-bot@brown.edu&quot;, &quot;url&quot;: &quot;ccv.brown.edu&quot; } }  The metadata provides information about the project such as the name, author and description. Dependencies​ &quot;dependencies&quot;: { &quot;@brown-ccv/behavioral-task-trials&quot;: &quot;^2.0.0&quot;, &quot;@fortawesome/fontawesome-free&quot;: &quot;^5.9.0&quot;, &quot;bootstrap&quot;: &quot;^5.2.0-beta1&quot;, &quot;electron-log&quot;: &quot;^4.4.8&quot;, &quot;electron-squirrel-startup&quot;: &quot;^1.0.0&quot;, &quot;event-marker&quot;: &quot;git+https://github.com/brown-ccv/event-marker.git&quot;, ... }  Dependencies are packages that the project rely on for it to function properly. They are formatted in specific key/value pairs where every key is a name of the package and the value is the version range that’s acceptable. Note: If any changes are made to the dependencies section of the package.json, you must run npm install again to download the newly updated list of dependencies. Scripts​ &quot;scripts&quot;: { &quot;commit&quot;: &quot;git-cz&quot;, &quot;postinstall&quot;: &quot;node version.js &amp;&amp; npm run rebuild&quot;, &quot;start&quot;: &quot;cross-env BROWSER=\\&quot;none\\&quot; NODE_PATH=\\&quot;./src\\&quot; react-scripts start&quot;, &quot;start:browser&quot;: &quot;react-scripts start&quot;, &quot;test&quot;: &quot;react-scripts test&quot;, &quot;prebuild&quot;: &quot;electron-rebuild&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, ... }  The scripts section contains a number of commands you can run. Check out the NPM Scripts page for more information about the different scripts you can run. ","version":"3.0.0","tagName":"h3"},{"title":"6. Run the task in dev mode​","type":1,"pageTitle":"Quick Start","url":"/docs/3.0.0/quick_start#6-run-the-task-in-dev-mode","content":"npm run dev  This will launch an electron window with the task and inspector open. It will hot-reload whenever changes are made to the app. Scripts on Windows​ Windows users must use a Git Bash terminal to execute scripts such as npm run dev. This is because node scripts are designed to execute on a Unix style command line environment but neither Command Prompt nor PowerShell are Unix based. Check out these instructions to set git bash as your default terminal on VS Code. ","version":"3.0.0","tagName":"h3"},{"title":"7. Learn about configuring your task for different environments​","type":1,"pageTitle":"Quick Start","url":"/docs/3.0.0/quick_start#7-learn-about-configuring-your-task-for-different-environments","content":"HoneyComb tasks can be configured to run as a web app in Firebase, as desktop application via electron, to receive port signals from EEG, cameras, foot pedals and more. To learn more about how to configure your task for these different scenarios, see the Configuration Section. ","version":"3.0.0","tagName":"h3"},{"title":"8. Check out the data​","type":1,"pageTitle":"Quick Start","url":"/docs/3.0.0/quick_start#8-check-out-the-data","content":"The data is saved throughout the task. When running as a Desktop App, data is saved to the user's app directory. When running as Web App in Firebase, data is stored in the FireStore. For a Desktop App, the location of the is logged at the beginning of the task wherever you ran npm run dev. Data is also stored in a folder that is generated by the app, which should be found on the desktop. ","version":"3.0.0","tagName":"h3"},{"title":"9. Quit the task​","type":1,"pageTitle":"Quick Start","url":"/docs/3.0.0/quick_start#9-quit-the-task","content":"If you want to quit in the middle of the task, you can use these keyboard shortcuts: Ctrl+W (for PC/Windows)  Cmd+Q (for Mac)  Partial data will be saved. ","version":"3.0.0","tagName":"h3"},{"title":"10. Run automated tests​","type":1,"pageTitle":"Quick Start","url":"/docs/3.0.0/quick_start#10-run-automated-tests","content":"Automated tests can tell a user whether the code is working as expected or if recent changes have broken previous functionality. Running automated tests is a good idea whenever you're getting started, merging updates, or making custom changes. To run the tests interactively: npm test  Or non-interactively: CI=true npm test  Testing on Linux​ When running npm test on Linux, you might get an error that mentions ENOSPC. This is because the test runner creates &quot;watchers&quot; for files in the project repo in order to automatically re-run tests as the files change. Linux limits the number of watchers that can be created at a time and the default limit may be smaller than the number of files in the repo. This is a &quot;known issue&quot; with some test runners on Linux, as in discussions here and here. One simple workaround is to increase the number of allowed watchers (100000 seems to be sufficient): Command that initially fails with ENOSPC: npm testCheck the configured limit on &quot;watchers&quot;: cat /proc/sys/fs/inotify/max_user_watchesEdit the relevant Linux config file: sudo vim /etc/sysctl.confAdd a line at the end of the config file: fs.inotify.max_user_watches=100000Save, exit, and reload the config file: sudo sysctl -pCheck that the limit has changed: cat /proc/sys/fs/inotify/max_user_watchesRetry the initial command, which should now succeed: npm test ","version":"3.0.0","tagName":"h3"},{"title":"Setup Details","type":0,"sectionRef":"#","url":"/docs/3.0.0/setup_details","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"Prerequisites​","type":1,"pageTitle":"Setup Details","url":"/docs/3.0.0/setup_details#prerequisites","content":"It is important that your computer is set up with the necessary packages before you begin development. You will come across a variety of errors if these prerequisites are not installed. First we need the following programs git (version control and GitHub integration)nodejs (web development - we recommend the latest long term support version)python (3.7 or later)An Integrated Development Environment (we recommend VS Code) In addition, Honeycomb relies on Electron to package the cross-platform desktop applications. Some of electron's prerequisites are platform dependant - listed below are the prerequisites for each operating system along with resources for manually installing them. ","version":"3.0.0","tagName":"h2"},{"title":"MacOS​","type":1,"pageTitle":"Setup Details","url":"/docs/3.0.0/setup_details#macos","content":"","version":"3.0.0","tagName":"h2"},{"title":"Brew​","type":1,"pageTitle":"Setup Details","url":"/docs/3.0.0/setup_details#brew","content":"All of the required dependencies for honeycomb on MacOS can be installed via the brewfile. See the quick start for more information. ","version":"3.0.0","tagName":"h3"},{"title":"Manual Installation (MacOS)​","type":1,"pageTitle":"Setup Details","url":"/docs/3.0.0/setup_details#manual-installation-macos","content":"XCode must be installed from the terminal: xcode-select --install Git 2.20.0 or later with support for &quot;--show-current&quot; Node.js To install Python (3.7 or later with support for TLS 1.2) follow the guide on electron docs to install and configure python and its modules ","version":"3.0.0","tagName":"h3"},{"title":"Windows​","type":1,"pageTitle":"Setup Details","url":"/docs/3.0.0/setup_details#windows","content":"Note that Windows occasionally requires a restart after package installations complete. If you are running into issues after installing the packages please restart your terminal and/or your entire computer. This should resolve most issues. ","version":"3.0.0","tagName":"h2"},{"title":"chocolatey​","type":1,"pageTitle":"Setup Details","url":"/docs/3.0.0/setup_details#chocolatey","content":"chocolatey.config​ A Chocolatey configuration file looks something like this: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;packages&gt; &lt;package id=&quot;git&quot; /&gt; &lt;package id=&quot;nodejs-lts&quot; /&gt; &lt;package id=&quot;vscode&quot; /&gt; &lt;package id=&quot;pyenv-win&quot; /&gt; &lt;package id=&quot;visualstudio2022community&quot; /&gt; &lt;package id=&quot;visualstudio2022-workload-nativedesktop&quot; /&gt; &lt;package id=&quot;electron&quot; /&gt; &lt;/packages&gt;  Running choco install chocolatey.config is the equivalent of calling choco install &lt;id&gt; for every package in the file. ","version":"3.0.0","tagName":"h3"},{"title":"Python on Windows (pyenv)​","type":1,"pageTitle":"Setup Details","url":"/docs/3.0.0/setup_details#python-on-windows-pyenv","content":"Installing and managing Python on Windows is a notoriously difficult task even for advanced developers. It is best practice to have exactly 1 tool for managing python on your system, which is a rule for most things in software development (this is what npm does for node packages). We highly recommend uninstalling Python and using pyenv even if you never anticipate using python again. We promise the extra setup today will pay great dividends in the future! First and foremost, turn off both Python App Installers in the &quot;App Execution Aliases&quot; settings. Please complete this step even if you already have a Python manager  Now we can set up our python management system1. We recommend pyenv as it is small and intuitive for newer developers. It lets us install python globally AND switch between different versions for individual projects. It does this (and only this) extremely well. Complete the following steps to install pyenv for Windows and set up your global python environment: Ensure Python is completely uninstalled from your system2 Type python on the command line and ensure you get a &quot;Command 'python' not found&quot; error python If the command executes, locate the installation (check &quot;Add or Remove programs&quot; in the settings) and remove it. Continue until the error appears If the Microsoft Store launches check again to ensure &quot;Manage App execution aliases&quot; is turned off for python.exe and python3.exe Install pyenv-win pyenv-win will install with chocolatey.config - enter pyenv on the command line to see if it's already on your system. You should see a list of commands printed to your terminal. pyenv If not: choco install pyenv-win Install your python version pyenv install &lt;version&gt; If you're using a different Python version for another project that version will work fine so long as it is at least version &gt; 3.0.0 Otherwise install the newest version that includes exactly 3 numbers, e.g. 3.10.6 pyenv install --list Use that version as your global install pyenv global &lt;version&gt;  1 _If you are already using [Anaconda](https://www.anaconda.com) for Python and it's various other tools that is okay! You already have python manager installed on your system and can skip this section._ 2 _Any &quot;solo&quot; installations can and will cause major conflicts with `pyenv`. It can cause issues when you try to change your version, when another program checks for python, when you update Windows... so on and so forth. Perhaps you've already run into something unexpected like this! This is why it's essential python is completely uninstalled from your computer before beginning._ ","version":"3.0.0","tagName":"h3"},{"title":"Manual Installation (Windows)​","type":1,"pageTitle":"Setup Details","url":"/docs/3.0.0/setup_details#manual-installation-windows","content":"GitNode.js We recommend installing the &quot;LTS&quot; option for better stability VS CodeVisual Studio: Visual Studio 2022 CommunityInstall the Native C++ Workflow pyenv for Windows ","version":"3.0.0","tagName":"h3"},{"title":"Linux​","type":1,"pageTitle":"Setup Details","url":"/docs/3.0.0/setup_details#linux","content":"We recommend using Ubuntu (18.10 or later) as your distro but any distro new enough to support GLIBC_2.28 should work. Download the Node.js source code and compile itGit 2.20.0 or later with support for &quot;--show-current&quot;Python 3.7 or later (with support for TLS 1.2)Install Clang or follow installation instructions on the electron docsDevelopment headers of GTK 3 and libnotify (Follow installation instructions on the electron docs) ","version":"3.0.0","tagName":"h2"},{"title":"Further Help​","type":1,"pageTitle":"Setup Details","url":"/docs/3.0.0/setup_details#further-help","content":"If you are still having issues setting up your computer you can find the full instructions on the electron documentation for your specific OS. ","version":"3.0.0","tagName":"h2"},{"title":"Version Control","type":0,"sectionRef":"#","url":"/docs/3.0.0/version_control","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"Git Overview​","type":1,"pageTitle":"Version Control","url":"/docs/3.0.0/version_control#git-overview","content":"Git is a version control system that enables you to track changes to files. With Git, you are able to revert files back to previous versions, restore deleted files, remove added files and even track down where a particular line of code was introduced. Nearly all operations that are performed by Git are in you local computing environment, for the exception of few used purely to synchronize with a remote. Some of the most common git operations are depicted below.  If you would like to make any changes to current repository, it is always good to start with creating a feature branch, where you can save all the changes.  ","version":"3.0.0","tagName":"h2"},{"title":"Comment styles​","type":1,"pageTitle":"Version Control","url":"/docs/3.0.0/version_control#comment-styles","content":"We encourage using Commitizen, a great tool for recording descriptions of commits in a standardized format which makes it easier for people to understand what changed in the code. ","version":"3.0.0","tagName":"h3"},{"title":"Cheatsheet​","type":1,"pageTitle":"Version Control","url":"/docs/3.0.0/version_control#cheatsheet","content":"Command\tBriefgit add &lt;files&gt;\tadd a file to next commit (stage) git commit -m &lt;message&gt;\tcommit staged files git push\tupload staged commit to repo git pull\tget remote repo commits and download (try and resolve conflicts) git clone &lt;url&gt;\tdownload entire repository git checkout &lt;branch&gt;\tcheckout and create the branch you want to use # create branch with your feature git checkout -b feature_name # check the status of your repositoey git status # commit file contents to the local repository git commit -am &quot;My feature is ready&quot; # specific message # push file contents to the remote (i.e. cloud) repository git push origin feature_name  ","version":"3.0.0","tagName":"h2"},{"title":"Alternative options​","type":1,"pageTitle":"Version Control","url":"/docs/3.0.0/version_control#alternative-options","content":"Instead of using commands in the terminal, you can also download GitHub desktop. It is very intuitive to use. Clone repository​  Select a branch or create a new branch​  Commit changes and push​  ","version":"3.0.0","tagName":"h3"},{"title":"Create a Pull Request​","type":1,"pageTitle":"Version Control","url":"/docs/3.0.0/version_control#create-a-pull-request","content":"Pull requests are useful before you merge your branch with the main branch. You can request a review from your colleagues and check for any conflicts with the main branch. After you pushed all the changes to your branch, you can go to the original GitHub repository and click on the pull request.   ","version":"3.0.0","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Version Control","url":"/docs/3.0.0/version_control#best-practices","content":"","version":"3.0.0","tagName":"h2"},{"title":"Git Workflow​","type":1,"pageTitle":"Version Control","url":"/docs/3.0.0/version_control#git-workflow","content":"We recommend using a simple flow based on following rules: Use topic/feature branches, no direct commits on main.Perform tests and code reviews before merges into main, not afterwards.Every branch starts from main, and targets main.Commit messages reflect intent. Git Branches​ main is the default branch and where releases are made off. This branch should be in clean/working conditions at all times. This branch is protected and can only be merged from Pull Requests for topic branchestopic branches are created for new features, fixes, or really any changes. E.g, fix-task-trial2-stuck-button This flow is sometimes referred to as Feature Branch Workflow ","version":"3.0.0","tagName":"h3"},{"title":"Stay up-to-date with Honeycomb template repo​","type":1,"pageTitle":"Version Control","url":"/docs/3.0.0/version_control#stay-up-to-date-with-honeycomb-template-repo","content":"Honeycomb is an active project, and will be updated with new features over time. To bring changes from the honeycomb template repository to your task, follow the following steps: ","version":"3.0.0","tagName":"h2"},{"title":"Add honeycomb as an additional remote​","type":1,"pageTitle":"Version Control","url":"/docs/3.0.0/version_control#add-honeycomb-as-an-additional-remote","content":"By default, your repository is configured to only sync with your remote, which typically is referred to as origin. You can add Honeycomb as an additional remote as follows: git remote add honeycomb https://github.com/brown-ccv/honeycomb.git  Adding a remote is a one time operation. At that point you can pull content from the honeycomb remote as follows: git fetch --all git merge honeycomb/main --allow-unrelated histories  If there are any conflicts, you'll need to resolve those, then commit the merge: git commit -a -m &quot;merge honeycomb latest&quot;  ","version":"3.0.0","tagName":"h3"},{"title":"Variants","type":0,"sectionRef":"#","url":"/docs/3.0.0/variants","content":"","keywords":"javascript  jspsych","version":"3.0.0"},{"title":"Variant Specific Executables​","type":1,"pageTitle":"Variants","url":"/docs/3.0.0/variants#variant-specific-executables","content":"In order to create multiple variants of a task that can be co-installed, it is necessary to add new scripts to the package.json file in addition to creating the necessary environment variables for configuration. Each variant must have a unique, lowercase name. Optionally, a unique icon can be used for each variant by saving multiple icons to the icons directories with the same names as the variants. Example scripts for Windows, Mac, and Linux are shown below. Windows: &quot;package:windows:&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform win32 --arch x64 --icon ./assets/icons/win/&lt;task_name&gt; --out dist/ --overwrite --asar&quot;  &quot;postpackage:windows:&lt;task_name&gt;&quot;: &quot;electron-installer-windows --src dist/&lt;task_name&gt;-win32-x64/ --dest dist/installers/ --overwrite --homepage https://ccv.brown.edu/ --name &lt;task_name&gt; --exe &lt;task_name&gt;.exe --productName &lt;task_name&gt;&quot;  Mac: &quot;package:mac:,&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform darwin --arch x64 --out dist/ --icon ./assets/icons/mac/&lt;task_name&gt;.icns --overwrite&quot;  &quot;installer:mac:&lt;task_name&gt;&quot;: &quot;electron-installer-dmg ./dist/&lt;task_name&gt;-darwin-x64/&lt;task_name&gt;.app &lt;task_name&gt;-${npm_package_version} --out ./dist/installers/ --icon ./assets/icons/mac/&lt;task_name&gt;.icns --overwrite&quot;  Linux: &quot;package:linux:&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform linux --arch x64 --icon ./assets/icons/mac/&lt;task_name&gt; --out dist/ --overwrite&quot;  &quot;postpackage:linux:&lt;task_name&gt;&quot;: &quot;electron-installer-debian --src dist/&lt;task_name&gt;-linux-x64/ --dest dist/installers/ --arch x64 --overwrite --name &lt;task_name&gt; --productName &lt;task_name&gt; --genericName &lt;task_name&gt; --bin &lt;task_name&gt;&quot;  ","version":"3.0.0","tagName":"h2"},{"title":"Variant Specific Workflows​","type":1,"pageTitle":"Variants","url":"/docs/3.0.0/variants#variant-specific-workflows","content":"In order to use Github workflows to build and upload executables for each variant, the build.yaml, package.yaml, and release.yaml files must be modified as well. For all three files, a new row should be added to the matrix variable as follows: variant: [&lt;comma_separated_list_of_variant_names&gt;]  Add the following before npm build in the steps section of build.yaml, package.yaml, and release.yaml: - name: Load .env file for variant uses: xom9ikk/dotenv@v1.0.2 with: path: ./env mode: ${{matrix.variant}}  In package.yaml and release.yaml, replace the # Build electron app package installers section with the following code: - name: package electron - windows if: startsWith(matrix.os, 'windows') run: npm run package:windows:${{ matrix.variant }} - name: package electron - linux if: startsWith(matrix.os, 'ubuntu') run: npm run package:linux:${{ matrix.variant }} - name: package electron - mac if: startsWith(matrix.os, 'mac') run: npm run package:mac:${{ matrix.variant }} - name: npm rebuild - mac if: startsWith(matrix.os, 'mac') run: npm rebuild - name: Mac installer if: startsWith(matrix.os, 'mac') run: npm run installer:mac:${{ matrix.variant }}  Replace the # Upload installers to github action section in package.yaml with the following code: - name: upload win-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'windows') with: name: ${{ format('win-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-setup.exe - name: upload mac-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'mac') with: name: ${{ format('mac-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}.dmg - name: upload linux-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'ubuntu') with: name: ${{ format('linux-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_x64.deb  Replace the # Upload installers to github release section in release.yaml with the following code: - name: Upload app to release - windows if: startsWith(matrix.os, 'windows') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-setup.exe asset_name: ${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-${{ matrix.setting }}-setup.exe tag: ${{ github.ref }} - name: Upload app to release - linux if: startsWith(matrix.os, 'ubuntu') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_x64.deb asset_name: ${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_${{ matrix.setting }}_x64.deb tag: ${{ github.ref }} - name: Upload app to release - mac if: startsWith(matrix.os, 'mac') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}.dmg asset_name: ${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-${{ matrix.setting }}.dmg tag: ${{ github.ref }}  ","version":"3.0.0","tagName":"h2"},{"title":"Continuous Integration","type":0,"sectionRef":"#","url":"/docs/3.1.x/ci","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"What is CI/CD?​","type":1,"pageTitle":"Continuous Integration","url":"/docs/3.1.x/ci#what-is-cicd","content":"CI/CD refers to Continuous Integration and either Continuous Delivery or Continuous Deployment. CI/CD enforces the automated building of bundled executables so that tasks can be easily installed without dependencies. In Honeycomb, CI/CD is managed by GitHub Actions. ","version":"3.1.x","tagName":"h2"},{"title":"What are Github Actions​","type":1,"pageTitle":"Continuous Integration","url":"/docs/3.1.x/ci#what-are-github-actions","content":"GitHub Actions automate tasks within the development life cycle of your software. GitHub Actions consist of a series of commands that run after a specified event has occurred. For example, every time someone creates a pull request for a repository, you can automatically run a command to build and test your software. You can learn more about the events that trigger workflows in GitHub's documentation GitHub Actions are written as YML files inside a .github/workflows/ folder in your repository. ","version":"3.1.x","tagName":"h2"},{"title":"Building the executables​","type":1,"pageTitle":"Continuous Integration","url":"/docs/3.1.x/ci#building-the-executables","content":"Honeycomb includes workflows to build and create installers for Windows, Mac and Linux. These workflows exist for two configurations of the tasks: Home: The app does not expect event code triggers and photodiode spots.Clinic: The app expects event code triggers and photodiode spots. More specifically, the following workflows are included: build.yaml: Every time an Pull Request (PR) is opened, or a push is made to the main branch, the software is built and tests are run for all platforms and home and clinic settings. This workflow does not build and upload desktop installerspackage.yaml: Create installers for any/all platforms for the home and clinic setting on demand 1. The installers/executables are uploaded as artifacts and are available for download from the GitHub Actions tab. This also builds a PsiTurk version when linux or all operating systems are selected.release.yml: Every time a Tag is released, installers are created and uploaded as packages. This also builds a PsiTurk version, and deploys to GitHub pages a web version of the application. 1 On-demand workflows are triggered manually from the GitHub Actions tab. Each GitHub organization/individual has a quota on storage in private repositories. Uploading artifacts counts against your quota. You may consider configuring your workflows to only upload what you need. You can learn more about GitHub's storage limits in their [official documentation](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#about-billing-for-github-actions). ","version":"3.1.x","tagName":"h2"},{"title":"Download your bundled executable to install and run your task​","type":1,"pageTitle":"Continuous Integration","url":"/docs/3.1.x/ci#download-your-bundled-executable-to-install-and-run-your-task","content":"You can download the executable file from either the tagged release page or the GitHub actions page. To install, unzip the downloaded file, install, and run. The executable does not require installation of any additional software. ","version":"3.1.x","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/3.1.x/","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"Flexible deployment online and in the lab​","type":1,"pageTitle":"Introduction","url":"/docs/3.1.x/#flexible-deployment-online-and-in-the-lab","content":"Honeycomb provides the ability to write one codebase and use it flexibly across settings (with guaranteed consistency in instructions, timing, etc.). The same code-base is used to maintain and deploy the identical task on Mechanical Turk, Prolific, and in research settings during concurrent electrophysiological recordings. ","version":"3.1.x","tagName":"h3"},{"title":"Easy-to-install executables​","type":1,"pageTitle":"Introduction","url":"/docs/3.1.x/#easy-to-install-executables","content":"Deployment specifications are abstracted as parameters that are easy to configure, and application building is automated via GitHub actions providing continuous delivery of easy-to-download executables, easing setup burden across research sites. ","version":"3.1.x","tagName":"h3"},{"title":"Foundation in jsPsych​","type":1,"pageTitle":"Introduction","url":"/docs/3.1.x/#foundation-in-jspsych","content":"jsPsych 7 tasks can be converted to the Honeycomb structure to take advantage of the flexible deployment and automated GitHub Actions workflow that Honeycomb provides. ","version":"3.1.x","tagName":"h3"},{"title":"Community Driven​","type":1,"pageTitle":"Introduction","url":"/docs/3.1.x/#community-driven","content":"Honeycomb additionally provides a Behavioral Task Hub at our Beehive website. These tasks are built in Honeycomb and are ready to be deployed. ","version":"3.1.x","tagName":"h3"},{"title":"Cite this work​","type":1,"pageTitle":"Introduction","url":"/docs/3.1.x/#cite-this-work","content":"If you use Honeycomb in your work, please cite Provenza, N.R., Gelin, L.F.F., Mahaphanit, W., McGrath, M.C., Dastin-van Rijn, E.M., Fan, Y., Dhar, R., Frank, M.J., Restrepo, M.I., Goodman, W.K. and Borton, D.A., 2021. Honeycomb: a template for reproducible psychophysiological tasks for clinic, laboratory, and home use. Brazilian Journal of Psychiatry, 44, pp.147-155. ","version":"3.1.x","tagName":"h3"},{"title":"Deploy online","type":0,"sectionRef":"#","url":"/docs/3.1.x/deploy_online","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"Usage with PsiTurk​","type":1,"pageTitle":"Deploy online","url":"/docs/3.1.x/deploy_online#usage-with-psiturk","content":"While this set up is optimized for Electron, we added functionality that will make use with PsiTurk easy. The application will detect if it's being used in a Turk environment and will: Save the data to the default PsiTurk SQLite database.Switch the language to Turk specific, if src/language/&lt;locale&gt;.mturk.json exists.Use the Turk-specific timeline if different than the primary timeline. ","version":"3.1.x","tagName":"h2"},{"title":"Prebuilt version​","type":1,"pageTitle":"Deploy online","url":"/docs/3.1.x/deploy_online#prebuilt-version","content":"When GitHub Actions is run, a PsiTurk build will be created automatically, and can be downloaded from its artifacts (skip next step if using). The workflows responsible for building the PsiTurk application are .github/workflows/package-home-all.yml and .github/workflows/release-home-all.yml. The first one has to be triggered manually, the latter is triggered when you tag a release. ","version":"3.1.x","tagName":"h3"},{"title":"Build instructions​","type":1,"pageTitle":"Deploy online","url":"/docs/3.1.x/deploy_online#build-instructions","content":"To set up your PsiTurk project, we provide a script that does the conversion. PsiTurk is a Python package used to manage HITs in Mechanical Turk. Before using the provided script, install PsiTurk. You'll need to follow these steps (the path to the PsiTurk project should be a directory you wish to be created): Build the application: npm run build Move to the psiturkit directory: cd psiturkit If it's the first time you're running the script: ./psiturk-it -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt; To update an existing PsiTurk project (the path to the PsiTurk project should already exist from the previous steps): ./psiturk-it -u -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt; ","version":"3.1.x","tagName":"h3"},{"title":"Running PsiTurk​","type":1,"pageTitle":"Deploy online","url":"/docs/3.1.x/deploy_online#running-psiturk","content":"After that, just navigate to your newly created PsiTurk project directory. shell&gt; psiturk #start psiturk psiturk&gt; server on #start server psiturk&gt; debug #debug mode  ","version":"3.1.x","tagName":"h3"},{"title":"Running on the Web​","type":1,"pageTitle":"Deploy online","url":"/docs/3.1.x/deploy_online#running-on-the-web","content":"","version":"3.1.x","tagName":"h2"},{"title":"Using Github Pages​","type":1,"pageTitle":"Deploy online","url":"/docs/3.1.x/deploy_online#using-github-pages","content":"Running npm run build generates static content into the build directory that can be served using any static contents hosting service. The workflow .github/workflows/release-home-all.yml uploads the build directory to the gh-branch to serve the application on GitHub pages as an example. After a creating a tag, the workflow will run and your application will be served at &lt;github user&gt;.github.io/&lt;repository&gt;. For this step to succeed you will need to create a deploy key and enable GitHub Pages for your repository. Generate a new SSH key. By default, your public key should have been created in ~/.ssh/id_rsa.pub or use the name you've provided. Copy key to clipboard with xclip -sel clip &lt; ~/.ssh/id_rsa.pub and paste it as a deploy key in your repository. Copy file content if the command line doesn't work for you. Check the box for Allow write access before saving your deployment key. You'll need your private key as a GitHub secret to allow the workflow to run the deployment for you. To create the secret, copy your private key (e.g., xclip -sel clip &lt; ~/.ssh/id_rsa) and paste a GitHub secret with name GH_PAGES_DEPLOY. Copy file content if the command line doesn't work for you. Save your secret. Make sure the publishing source for your repository is configured for gh-pages branch. ","version":"3.1.x","tagName":"h3"},{"title":"Set up event triggers","type":0,"sectionRef":"#","url":"/docs/3.1.x/event_triggers","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"BrainVision Trigger Box setup​","type":1,"pageTitle":"Set up event triggers","url":"/docs/3.1.x/event_triggers#brainvision-trigger-box-setup","content":"Follow the TriggerBox setup instructions in the BrainVision Trigger Box manual. Plug the TriggerBox into the computer running the task. Check your operating system’s device list to identify the COM port that the TriggerBox is connected to. Create a new system environment variable: COMNAME  and set the COM port to the correct value (e.g., COM3). ","version":"3.1.x","tagName":"h2"},{"title":"Open Source Event Trigger setup​","type":1,"pageTitle":"Set up event triggers","url":"/docs/3.1.x/event_triggers#open-source-event-trigger-setup","content":"Details on how to make the open source event trigger and photodiode can be found here. Connect the open source event trigger to the computer running the task using a USB to micro-USB cable. Check your operating system’s USB device list to identify the product ID of the teensyduino event marker. Create a new system environment variable: EVENT_MARKER_PRODUCT_ID and set to the product ID of the event marker. ","version":"3.1.x","tagName":"h2"},{"title":"Send event code triggers​","type":1,"pageTitle":"Set up event triggers","url":"/docs/3.1.x/event_triggers#send-event-code-triggers","content":"Change the eventCodes values listed in the src/config/trigger.js file to the desired values. Import eventCodes from ./trigger and export as eventCodes. Whenever you would like to send an event code in a trial, load eventCodes from ../config/main/, and call pdSpotEncode with the proper eventCode (e.g. eventCode.Fixation) as input. ","version":"3.1.x","tagName":"h2"},{"title":"Run the task with event triggers​","type":1,"pageTitle":"Set up event triggers","url":"/docs/3.1.x/event_triggers#run-the-task-with-event-triggers","content":"Honeycomb automatically checks whether your event marker is connected and running at the start of the task. If it is not connected, the task will present an error and will not be able to run. ","version":"3.1.x","tagName":"h2"},{"title":"JavaScript","type":0,"sectionRef":"#","url":"/docs/3.1.x/javascript","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"Learning JavaScript​","type":1,"pageTitle":"JavaScript","url":"/docs/3.1.x/javascript#learning-javascript","content":"The Mozilla Developer Network Web Docs is the gold standard for programming on the web. The JavaScript page is an excellent place for further reading about JavaScript. ","version":"3.1.x","tagName":"h2"},{"title":"Interactive Tutorials​","type":1,"pageTitle":"JavaScript","url":"/docs/3.1.x/javascript#interactive-tutorials","content":"Learn JavaScript is an excellent platform for beginning to learn the JavaScript programming language. It is full of interactive tutorials and small projects. ","version":"3.1.x","tagName":"h2"},{"title":"Environment Variables","type":0,"sectionRef":"#","url":"/docs/3.1.x/environment_variables","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"Dev Mode Only​","type":1,"pageTitle":"Environment Variables","url":"/docs/3.1.x/environment_variables#dev-mode-only","content":"ELECTRON_START_URL : URL (e.g. http://localhost:3000) where the front end of the app is being hosted - also used in electron.js to indicate the app is running in dev mode. ","version":"3.1.x","tagName":"h3"},{"title":"Desktop Only​","type":1,"pageTitle":"Environment Variables","url":"/docs/3.1.x/environment_variables#desktop-only","content":"EVENT_MARKER_PRODUCT_ID: The product ID of the event marker (e.g. 0487). If not set, it will use the productID set in public/config/trigger.js if available, or attempt to connect using the com name.EVENT_MARKER_COM_NAME : The com name of the event marker (e.g. COM3). If not set, it will use the comName set in public/config/trigger.js. If the productID is set (not an empty string), this field will be ignored.REACT_APP_VIDEO: whether the participant is being video recorded. This can be used when the task is running as a desktop app (electron).REACT_APP_USE_EEG: whether the event marker/EEG is available. This can be used when the task is running as a desktop app (electron).REACT_APP_USE_PHOTODIODE: whether the photodiode is in use. This can be used when the task is running as a desktop app (electron). ","version":"3.1.x","tagName":"h2"},{"title":"Desktop and Online​","type":1,"pageTitle":"Environment Variables","url":"/docs/3.1.x/environment_variables#desktop-and-online","content":"REACT_APP_VOLUME: whether the participant is being asked to adjust volume. This can be used on both the desktop (electron) and online settings.REACT_APP_PARTICIPANT_ID : The default participant id to show when authorizing a participant. If not set, user will need to enter the value in the provided input box.REACT_APP_STUDY_ID : The default study id to show when authorizing a participant. If not set, user will need to enter the value in the provided input box. ","version":"3.1.x","tagName":"h2"},{"title":"Understanding Build-Time and Run-Time Variables​","type":1,"pageTitle":"Environment Variables","url":"/docs/3.1.x/environment_variables#understanding-build-time-and-run-time-variables","content":": Run-time environment variables allow for quick changes before running the task. They are convenient since they don't require building a whole different executable. For a Desktop Application, these are set at the system level and must be available at the time where the task runs. See this tutorial for OS specific instructions.. For a Firebase Application, these must be stored in the Firestore. : Build-time environment variables are configured before the application is built and cannot be changed at run-time. They are configured via .env files before building. Instead of using a single .env file, we prefer to define separate files under the env/ directory, and use a package called dotenv-cli before building`. The dotenv-cli comes with the dotenv command that can be used to properly load the needed variables. We write our npm scripts with the following format: package.json &quot;[build|dev]:&lt;env name&gt;&quot;: &quot;dotenv -e env/&lt;env name&gt; npm run [build|dev]:&lt;env name&gt;&quot;  See NPM Scripts for more ","version":"3.1.x","tagName":"h2"},{"title":"Prerequisites","type":0,"sectionRef":"#","url":"/docs/3.1.x/prerequisites","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"OS Independent​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#os-independent","content":"","version":"3.1.x","tagName":"h2"},{"title":"Git​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#git","content":"git is an open-sourced version control system. It is used to track changes, revert mistakes, and enable peer code reviews! GitHub Desktop is a GUI application used to interact with git and GitHub directly from your computer. It is not strictly needed but many folks find it easier to work with than using git directly from the command line. ","version":"3.1.x","tagName":"h3"},{"title":"Node Version Manager​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#node-version-manager","content":"NodeJS is a cross-platform runtime environment for JavaScript code. Almost every web application today builds on top of node. Node Version Manager manages running multiple versions of node on the same system. The .nvmrc denotes the version of node that Honeycomb uses. ","version":"3.1.x","tagName":"h3"},{"title":"Python​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#python","content":"Python is a high-level programming language. Some &quot;under the hood&quot; tools needed by Honeycomb are written in python so it must be installed on your system. note Honeycomb needs version 3.7 or later to run - the installers use version 3.11. ","version":"3.1.x","tagName":"h3"},{"title":"Oracle JDk​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#oracle-jdk","content":"Java is another high-level programming languages that some tools are written in (namely, the Firebase Emulators). We must install a JDK (Java Development Kit) for it to run. note Honeycomb needs version 11 or later to run - the installers use version 18. ","version":"3.1.x","tagName":"h3"},{"title":"Visual Studio Code​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#visual-studio-code","content":"Visual Studio Code is a well-loved and easy to use integrated development environment (IDE). This is the program you'll use to write your task. ","version":"3.1.x","tagName":"h3"},{"title":"Mac-specific Installs​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#mac-specific-installs","content":"","version":"3.1.x","tagName":"h2"},{"title":"X-Code​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#x-code","content":"XCode is a special IDE for the Apple platform. It comes with everything needed to compile desktop applications from an Apple computer. It must be installed from the terminal: Installing XCode xcode-select --install  ","version":"3.1.x","tagName":"h3"},{"title":"Rosetta​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#rosetta","content":"Rosetta is a translation layer built for Mac computers with Apple Silicon. It should ask to be installed if any of the prerequisite tools need it. Otherwise, this guide can be used to make sure it is on your Apple silicon system. ","version":"3.1.x","tagName":"h3"},{"title":"Windows-specific Install​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#windows-specific-install","content":"","version":"3.1.x","tagName":"h2"},{"title":"Visual Studio​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#visual-studio","content":"Visual Studio is a special IDE for the Windows platform. It comes with everything needed to compile desktop applications from a PC. Visual Studio Community is a free to use platform. caution The &quot;Desktop development with C++&quot; workload must also be installed with Visual Studio. The automated installers should preselect this but you should double check to be certain! ","version":"3.1.x","tagName":"h3"},{"title":"Manual Installation (macOS)​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#manual-installation-macos","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. GitGitHub DesktopNVMPythonOracle JDKVS CodeXcode ","version":"3.1.x","tagName":"h2"},{"title":"Manual Installation (Windows)​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#manual-installation-windows","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. GitGitHub DesktopNVMPythonOracle JDKVS CodeVisual Studio: Visual Studio 2022 CommunityInstall the Native C++ Workflow ","version":"3.1.x","tagName":"h2"},{"title":"Manual Installation (Linux)​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#manual-installation-linux","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. Your preferred installation method for the programs listed above should get you up and running on any Linux distro new enough to support GLIBC_2.28. GitGitHub DesktopNVMPythonOracle JDKVS CodeInstall Clang or follow installation instructions on the electron docsDevelopment headers of GTK 3 and libnotify (Follow installation instructions on the electron docs) ","version":"3.1.x","tagName":"h2"},{"title":"Further Help​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.1.x/prerequisites#further-help","content":"If you are still having issues setting up your computer you can find the full instructions on the electron documentation for your specific OS. ","version":"3.1.x","tagName":"h2"},{"title":"NPM Scripts","type":0,"sectionRef":"#","url":"/docs/3.1.x/npm_scripts","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"Start​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.1.x/npm_scripts#start","content":"electron starts an electron process with the built application.electron-dev starts an electron process with the current code. Note that the script waits for http://localhost:3000 to be available before launching the electron process. start runs the app in development mode and does NOT open a browser. This makes working with electron easier as it creates its own browser for development.start:browser runs the app in development mode and automatically opens a new browser tab. It uses your system's default browser. The page will reload if you make edits. ","version":"3.1.x","tagName":"h2"},{"title":"Firebase​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.1.x/npm_scripts#firebase","content":"firebase:emulators:start starts the Firebase emulators with the data found in emulator_data/firebase:emulators:save saves the current state of the Firebase emulators into emulator_data/ caution There's no way to revert to what used to be in `emulator_data/ once it's overwritten! firebase:download runs the firebase-download-script.js script, saving certain data in Firebase to your local machine. ","version":"3.1.x","tagName":"h2"},{"title":"Dev​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.1.x/npm_scripts#dev","content":"npm run dev runs the task in development mode on Electron. It executes npm start and npm run electron-dev concurrently. Note that this is a base script that other scripts build on top of - you should always run one of the scripts below while developing your task. dev:home executes npm run dev with equipment disabled (env/.env.home)dev:home:video executes npm run dev with equipment disabled (env/.env.home) and video enabled (env/.env.video)dev:clinic executes npm run dev with equipment enabled (env/.env.clinic)dev:clinic:video executes npm run dev with equipment enabled (env/.env.clinic) and video enabled (env/.env.video)dev:firebase executes npm run start:browser with Firebase enabled (env/.env.firebase) info firebase:emulators:start must be run in its own terminal in order for npm run firebase:dev to work ","version":"3.1.x","tagName":"h2"},{"title":"Build​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.1.x/npm_scripts#build","content":"npm run build creates a production build of the app in the build/ folder. Note that this is a base script that other scripts build on top of - you should always run one of the scripts below while developing your task. dev:home executes npm run build with equipment disabled (env/.env.home)dev:home:video executes npm run build with equipment disabled (env/.env.home) and video enabled (env/.env.video)dev:clinic executes npm run build with equipment enabled (env/.env.clinic)dev:clinic:video executes npm run build with equipment enabled (env/.env.clinic) and video enabled (env/.env.video)dev:firebase executes npm run build with Firebase enabled (env/.env.firebase) ","version":"3.1.x","tagName":"h2"},{"title":"Package​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.1.x/npm_scripts#package","content":"npm run package:[platform] creates a standalone installer for the given platform using electron-forge. The installer is created in out/. Note that the scripts build the app before creating the installers npm run package:windowsnpm run package:linuxnpm run package:mac note Packaging for windows on a non-windows machine requires mono and wine to be installed. ","version":"3.1.x","tagName":"h2"},{"title":"Miscellaneous​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.1.x/npm_scripts#miscellaneous","content":"commit runs commitizen in the console. It is useful for ensuring your Git commit messages are easy to follow.lint uses Eslint to find problems in the codeformat uses Eslint to find and fix problems in the code that it can automaticallytest launches the test runner in the interactive watch mode. See running tests for more information. ","version":"3.1.x","tagName":"h2"},{"title":"Project Organization","type":0,"sectionRef":"#","url":"/docs/3.1.x/project_organization","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"assets/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#assets","content":"This folder contains any static files that are used by the app. Honeycomb starts with a few images used as icons for the installed applications. ","version":"3.1.x","tagName":"h2"},{"title":"build/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#build","content":"The build scripts automatically create a build folder at the root of the repository and update it on subsequent builds. build/ should be left alone! caution The build folder is in Honeycomb's .gitignore and as such should never be added to git ","version":"3.1.x","tagName":"h2"},{"title":"emulator_data/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#emulator_data","content":"This folder contains starter data for the Firebase Emulators to use while developing locally. See the Firebase Scripts to use the data - emulator_data/ should be left alone! ","version":"3.1.x","tagName":"h2"},{"title":"env/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#env","content":"This folder contains different .env files used to pass environment variables (secrets and/or settings) into Honeycomb. Honeycomb starts with presets for common use cases and is explained in greater detail in the Environment Variables section. ","version":"3.1.x","tagName":"h2"},{"title":"node_modules/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#node_modules","content":"danger node_modules/ is written to when running npm install and should never be manually edited. ","version":"3.1.x","tagName":"h2"},{"title":"psiturkit/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#psiturkit","content":"The file psiturk-it inside psiturkit/ is a bash script used to instal PsiTurk locally - see Deploy Online for more information. psiturkit/ should be left alone! ","version":"3.1.x","tagName":"h2"},{"title":"public/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#public","content":"The public directory contains files that are used as assets in the built app. favicon.ico is the small icon you can see in the browser tab.index.html is the entry point of the website Changing &lt;title&gt;Honeycomb&lt;/title&gt; will update the name you can see in the browser tab. electron.js contains all of the code related to the electron app. ","version":"3.1.x","tagName":"h2"},{"title":"lib/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#lib","content":"The lib/ directory contains the files PsiTurk needs to run. Note that index.html references these files inside the &lt;script&gt; tags ","version":"3.1.x","tagName":"h3"},{"title":"config/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#config","content":"The config directory contains the config files needed for the electron app. This includes the event-marker details and event codes. version.json keeps track of the current git commit, which Honeycomb uses to keep track of the version of your task used for a given experiment. ","version":"3.1.x","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#src","content":"This folder contains the source code for the Honeycomb application. ","version":"3.1.x","tagName":"h2"},{"title":"__tests__/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#__tests__","content":"Automated test cases should be created in this folder. ","version":"3.1.x","tagName":"h3"},{"title":"assets/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#assets-1","content":"Any assets used by your task should be stored here, such as images and videos. note These assets are not statically generated like the root assets/ folder. Only assets needed by your task should go here. ","version":"3.1.x","tagName":"h3"},{"title":"components/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#components","content":"The React components that make up Honeycomb are located here. App.jsx initializes and maintains the state of the application. It is also where communication is set up between the electron and psiturk processes.Error.jsx displays a small error message. It is rendered when the App.jsx detects an issue in state.JsPsychExperiment.jsx initializes the JsPsych experimentLogin.jsx handles user authentication based on the environment variables passed to Honeycomb ","version":"3.1.x","tagName":"h3"},{"title":"config/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#config-1","content":"Each file in the config directory contains settings for a different part of the task. main.js contains the global settings (e.g. whether Honeycomb is running online or in the clinic) passed from env variables and logic for loading the appropriate language file.trigger.js for equipment-related settings (e.g. event markers). It uses a slightly different style of javascript as it is imported both in the React app as well as the electron process. Other config files can be used to add settings for specific blocks or sub-sections of the experiment. ","version":"3.1.x","tagName":"h3"},{"title":"language/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#language","content":"Any language that is displayed in the experiment should be stored in this folder. Usage of language json files allows for easy internationalization of the task (e.g. english and spanish) and mturk-specific language. Common phrases can be written once in a language file and re-used throughout the task. ","version":"3.1.x","tagName":"h3"},{"title":"lib/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#lib-1","content":"The utility functions and markup used in the tasks are located here. This allows for functions and html to be re-used wherever needed. markup files contain HTML templates used throughout the task. Typically this will be a function that takes in some parameters and then returns a string with html. tip Be sure to look through utils.js for functions you might be able to use in your task ","version":"3.1.x","tagName":"h3"},{"title":"timelines/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#timelines","content":"A timeline is a collection of trials that JsPsych displays in the given order. Timelines can contain timelines themselves; you may want to break this nesting into multiple files in this folder. main.js contains the root timeline which App.jsx loads into the &lt;JsPsychExperiment&gt; component. ","version":"3.1.x","tagName":"h3"},{"title":"trials/​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#trials","content":"A trial is the base unit of a JsPsych experiment. Each trial should be its own file within this folder - the files in src/timelines/ will combine these trials into the full experiment. ","version":"3.1.x","tagName":"h3"},{"title":"firebase.js​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#firebasejs","content":"firebase.js contains all of the logic for creating, reading, and updating data in Firebase. You should not have to update this file. ","version":"3.1.x","tagName":"h3"},{"title":"index.css​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#indexcss","content":"index.css contains all of the styling in the application. Classes can be defined here and referenced in your markup. ","version":"3.1.x","tagName":"h3"},{"title":"index.js​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#indexjs","content":"index.js is the entry point for React in our application. Note that the id 'root' corresponds with a tag in public/index.html: &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  ","version":"3.1.x","tagName":"h3"},{"title":"Other Files​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#other-files","content":".github/workflows/ contains .yaml files used to build Honeycomb on a pull request (build.yaml) and create task executables either in a single instance (package.yaml) or for a full release (release.yaml) package.json contains metadata about your project, a list of the dependencies needed for the project, and scripts to run tasks related to your task. The Quick Start lists which metadata should be changed. download-response-data.js is the script used to download data stored in Firestore to your local machine. version.js is the script used to keep track of which version of the task a given experiment is using danger package-lock.json is written to when running npm install and should never be manually edited. ","version":"3.1.x","tagName":"h2"},{"title":"Git Files​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#git-files","content":".gitignore lists the folders and files that should be excluded from Git. Make sure all of your secrets and tokens are listed here! ","version":"3.1.x","tagName":"h3"},{"title":"Eslint Files​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#eslint-files","content":".eslintrc.js contains the Eslint settings for Honeycomb. We recommend it's left alone but can be adjusted for personal settings..eslintignore lists the folders and files that eslint shouldn't touch, similar to .gitignore. ","version":"3.1.x","tagName":"h3"},{"title":"Prettier Files​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#prettier-files","content":".prettierrc.js contains the Prettier settings for Honeycomb. We recommend it's left alone but can be adjusted for personal settings. ","version":"3.1.x","tagName":"h3"},{"title":"Firebase Files​","type":1,"pageTitle":"Project Organization","url":"/docs/3.1.x/project_organization#firebase-files","content":".firebaserc contains the name of the project Firebase should connect to. Be sure to update the default project to the one you created!firebase.json contains the Firebase settings for Honeycomb. It should be left alone!firestore.indexes.json contains the Firestore index settings for Honeycomb. It should be left alone!firestore.rules contains the Firestore rules for creating/editing data. It should be left alone! ","version":"3.1.x","tagName":"h2"},{"title":"Firebase","type":0,"sectionRef":"#","url":"/docs/3.1.x/firebase","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"Setting up Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#setting-up-firebase","content":"info Members of Brown University should submit a support ticket to have their Firebase project created. Members of other institutions should check to see if their university has access to Google Cloud. Otherwise, a personal Firebase account can be created for free. Please follow the firebase documentation for creating a new project. ","version":"3.1.x","tagName":"h2"},{"title":"Adding Products​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#adding-products","content":"First we'll configure Firebase Hosting and Cloud Firestore on your project. Log in to Firebase with your Google account on the Firebase console. Navigate to your project from the console Register a new web app to your project (Register your app) note We recommend giving your web app the same name as your task's repository Add Firestore Database to your project (Create a Cloud Firestore database) note Chose production mode for the starting mode and the default &quot;Cloud Firestore Location&quot; The Firebase project is now fully set up! Now we'll connect your task to that project from your computer. ","version":"3.1.x","tagName":"h3"},{"title":"Installing the Command Line Interface​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#installing-the-command-line-interface","content":"The Firebase CLI can be installed with the node package manager just like the rest of Honeycomb's dependencies. Be sure to log in with same account you used when logging into the console! Install the Firebase CLI npm install -g firebase-tools  Login to Firebase firebase login  A &quot;command not found&quot; error usually indicates firebase-tools has not been installed correctly ","version":"3.1.x","tagName":"h3"},{"title":"Connecting Your Firebase Project​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#connecting-your-firebase-project","content":"Change the default project name of your task in .firebaserc .firebaserc { &quot;projects&quot;: { &quot;default&quot;: &quot;&lt;your project name&gt;&quot; } }  Copy the web app credentials from the Firebase console to the corresponding variables in .env.firebase Return to your project on the Firebase console. Navigate to your project setting Scroll down and copy the auto-generated values from the Firebase console to the corresponding variables in the .env.firebase file in the env folder of your Honeycomb task repo env/.env.firebase REACT_APP_FIREBASE=&quot;true&quot; REACT_APP_apiKey= REACT_APP_authDomain= REACT_APP_projectId= REACT_APP_storageBucket= REACT_APP_messagingSenderId= REACT_APP_appId= Additional variables may be present in the console, they do not need to be copied. Deploy the default Firestore security rules Deploy Firestore rules firebase deploy --only firestore:rules  Your task is now connected to an initialized Firebase project! ","version":"3.1.x","tagName":"h3"},{"title":"Registering Studies​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#registering-studies","content":"caution This step must be followed exactly. See Security Rules for more information. Navigate to your Firestore Database in the console.Click &quot;Start collection&quot;Enter registered_studies for the collection id and click &quot;next&quot;Enter the id of your study for the document idAdd a field named registered_participants with the type &quot;array&quot;Add the id of each study participant as a string inside the array   The study should like this when you're finished:    Additional studies must be created inside the registered_studies collection ","version":"3.1.x","tagName":"h2"},{"title":"Developing With Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#developing-with-firebase","content":"Two terminal windows must be used while developing for Firebase. Instructions splitting terminals in VSCode can be found here. Run Honeycomb with Firebase Enabled npm run dev:firebase  Start the Firebase Emulators npm run firebase:emulators:start  Honeycomb is now running in the browser and connected to data on an emulated instance of Firestore. That data can be viewed at http://localhost:4000/firestore. info Honeycomb populates the Firestore emulators with the study s1 and participant p1. ","version":"3.1.x","tagName":"h2"},{"title":"Deploying on Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#deploying-on-firebase","content":"Firebase deployments are handled automatically following Continuous Integration Continuous Development practices using GitHub Actions. Here we will connect create custom actions that are connected to the task's Firebase project. Execute the following command to begin initializing Firebase hosting via GitHub actions. Be sure to follow the instructions below as the prompts appear. Initialize Firebase hosting via Github actions firebase init hosting:github  The window should log you in automatically. If not, follow the prompts to log in with the same account you used in the console.&lt;username&gt;/&lt;repository name&gt; refers to the name of your repository in Github. Be sure it's typed correctly!Enter y for the prompt &quot;Set up the workflow to run a build script before every deploy?&quot;Enter npm install &amp;&amp; npm run build:firebase for the prompt &quot;What script should be run before every deploy?&quot;Enter y to overwrite the current workflow fileEnter y for the prompt &quot;Set up automatic deployment to your site's live channel when a PR is merged?&quot;Enter main for the prompt &quot;What is the name of the GitHub branch associated with your site's live channel?&quot;Enter y to overwrite the current workflow file Firebase will update the files firebase-hosting-pull-request.yml and firebase-hosting-merge.yml inside the .github/workflows/ directory. Ensure the correct run script is present in both files.  ","version":"3.1.x","tagName":"h2"},{"title":"Downloading Data​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#downloading-data","content":"Honeycomb ships with a script for downloading data from Firebase onto a computer. A local service account must be created in order to use it. ","version":"3.1.x","tagName":"h2"},{"title":"Setting up a Service Account​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#setting-up-a-service-account","content":"Service accounts are accounts that are not attached to a human user. They authorize access to a Firebase project without someone physically logging in online. We use a service account to give the download script access to the Firestore database automatically. Return to the project settings your project on the Firebase console. Click on the &quot;Service accounts&quot; tab Near the bottom, click &quot;Generate new Private key&quot; and &quot;Generate Key&quot; Rename the key firebase-service-account.json and move it to the root directory of your task. Be sure the file looks grayed out and is not picked up by git! danger A service account has total administrative access to ts Firebase project. The file and keys inside should never be shared and never committed to GitHub. ","version":"3.1.x","tagName":"h3"},{"title":"Using the Download Script​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#using-the-download-script","content":"Honeycomb comes with a download script. It will programmatically access Firestore to download the experiment data you choose Script Usage npm run firebase:download -- &lt;studyID&gt; &lt;participantID&gt; [sessionNumber] [outputRoot]  studyID: The ID of a given studyparticipantID: The ID of a given participant on the studyID studysessionNumber: Optional number to select which session to download, defaults to the most recent sessionoutputRoot: Optional path to the folder where data should be saved, defaults to the current folder Running the script without sessionNumber list all of the available sessions. For example: Found 3 sessions: 0: 2022-07-26T22:04:55.544Z 1: 2022-07-27T14:16:36.301Z 2: 2022-07-27T19:56:26.229Z  sessionNumber​ Adding a sessionNumber will download that sessions data: Download data for session 2022-07-26T22:04:55.544Z npm run firebase:download -- &lt;studyID&gt; &lt;participantID&gt; 0 [outputRoot]  outputRoot​ Session data is stored in the current directory by default. The folders and file name are chosen to avoid naming collisions: ./participant_responses/&lt;studyID&gt;/&lt;participantID&gt;/&lt;sessionID&gt;.json Adding an outputRoot will download that data in a custom location: Download data for session 2022-07-26T22:04:55.544Z at /path/to/my/data npm run firebase:download -- &lt;studyID&gt; &lt;participantID&gt; 0 /path/to/my/data  This will result in data saved to /path/to/my/data/participant_responses/&lt;studyID&gt;/&lt;participantID&gt;/&lt;sessionID&gt;.json ","version":"3.1.x","tagName":"h3"},{"title":"Further Reading​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#further-reading","content":"The Firebase Documentation details its Emulator Suite in much greater detail. ","version":"3.1.x","tagName":"h2"},{"title":"Security Rules​","type":1,"pageTitle":"Firebase","url":"/docs/3.1.x/firebase#security-rules","content":"Honeycomb uses security rules to authenticate participants and studies for each task. By default participants must be registered to each study in order to complete the task. Firestore rules are defined in the firestore.rules file in the home directory. Note the highlighted lines: firestore.rules rules_version = '2'; service cloud.firestore { match /databases/{database}/documents { match /participant_responses/{studyID}/participants/{participantID} { allow create, read: if participantID in get(/databases/$(database)/documents/registered_studies/$(studyID)).data.registered_participants; // ... } } }  Lines 3 and 4 indicate that Honeycomb attempts to connect to a document at /databases/{database}/documents/participant_responses/{studyID}/participants/{participantID} where studyID is a given study and participantID is a given participant within that study. Line 6 defines our rule - it must pass for Honeycomb to connect to the document. participantID must be found in an array called registered_participants inside of a document at /databases/{database}/documents/registered_studies/{studyID}. Line 5 indicates how Honeycomb can interact with that document. Note that Honeycomb cannot update or delete data! You must manually make these changes from the Firestore console. danger Firestore rules must define every match pattern in your project. Attempting to connect anywhere other than /participant_responses/{studyID}/participants/{participantID} will be automatically denied even if you add other collections to your database. This is why firestore.rules contains additional nested rules - these should be left alone. ","version":"3.1.x","tagName":"h3"},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"/docs/3.1.x/troubleshooting","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"Inspecting Errors​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.1.x/troubleshooting#inspecting-errors","content":"When developing Electron apps there are two processes: main, and renderer. In this case main corresponds to electron-starter.js and its console is wherever you called npm run dev or electron . from. renderer corresponds to the React App - this is everything else. The React app's console is in the electron/browser window and can be seen by using dev tools to inspect the window. When running npm run dev, it should open by default. In case you want to find out where the error is coming from when running the app locally: Try reviewing logs in the terminalInspect element in your browser by opening your developer tools. For instance, in Chrome, this can be done via the menu View -&gt; Developer or right-clicking and pressing inspect. ","version":"3.1.x","tagName":"h2"},{"title":"Testing in Linux​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.1.x/troubleshooting#testing-in-linux","content":"When running npm test on Linux, you might get an error that mentions ENOSPC. This is because the test runner creates &quot;watchers&quot; for files in the project repo in order to automatically re-run tests as the files change. Linux limits the number of watchers that can be created at a time and the default limit may be smaller than the number of files in the repo. This is a &quot;known issue&quot; with some test runners on Linux, as in discussions here and here. One simple workaround is to increase the number of allowed watchers (100000 seems to be sufficient): Command that initially fails with ENOSPC: npm testCheck the configured limit on &quot;watchers&quot;: cat /proc/sys/fs/inotify/max_user_watchesEdit the relevant Linux config file: sudo vim /etc/sysctl.confAdd a line at the end of the config file: fs.inotify.max_user_watches=100000Save, exit, and reload the config file: sudo sysctl -pCheck that the limit has changed: cat /proc/sys/fs/inotify/max_user_watchesRetry the initial command, which should now succeed: npm test ","version":"3.1.x","tagName":"h2"},{"title":"Common issues​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.1.x/troubleshooting#common-issues","content":"","version":"3.1.x","tagName":"h2"},{"title":"Installing Dependencies​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.1.x/troubleshooting#installing-dependencies","content":"Brew Not Available​ If you run into issues installing Homebrew in step 1 of Installing Prerequisites it may be because Homebrew is not available on your shell. Older versions of macOS (under 10.14) do not do this automatically. Run the following command to manually add the Homebrew installation location to your PATH so it is available in your shell. echo 'PATH=&quot;/usr/local/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile  note If you're using zsh, also add to your ~/.zshrc file. ","version":"3.1.x","tagName":"h3"},{"title":"NPM Errors​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.1.x/troubleshooting#npm-errors","content":"Try deleting your node_modules folder and the package-lock.json then running npm install then npm run rebuild. This should fix most issues. ","version":"3.1.x","tagName":"h3"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/docs/3.1.x/quick_start","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"Creating Your Task Repository​","type":1,"pageTitle":"Quick Start","url":"/docs/3.1.x/quick_start#creating-your-task-repository","content":"The Honeycomb repository is a template and serves as the starting point for all tasks. Creating your repository from the template starts your project with the same directory structure and files as an existing repository. Go to the Honeycomb repository Click on Use this template and select Create a new repository. Enter the owner, name, and description of your repository and click on Create repository from template. note We recommend creating a public repository and leaving Include all branches unchecked Ensure the repositories workflow permissions are set to &quot;Read and write permissions&quot; Settings -&gt; Actions -&gt; General -&gt; Workflow permissions Additional details about template repositories can be found on the Github Docs. ","version":"3.1.x","tagName":"h2"},{"title":"Cloning the Repository​","type":1,"pageTitle":"Quick Start","url":"/docs/3.1.x/quick_start#cloning-the-repository","content":"With the repository now setup it can be cloned onto your computer. Navigate to the repository on GitHub. Click the Code button and copy the URL Open a terminal and navigate to where you want the cloned directory WindowsmacOS Terminal.app cd 'path/to/directory'  Clone the repo with the following command Paste the URL you copied earlier git clone https://github.com/&lt;YOUR-USERNAME&gt;/&lt;YOUR-REPOSITORY&gt;  note Git can be downloaded here if it is not already on your system. Additional details and alternative methods for cloning a repository can be found on the Github Docs. ","version":"3.1.x","tagName":"h2"},{"title":"Installing Prerequisites​","type":1,"pageTitle":"Quick Start","url":"/docs/3.1.x/quick_start#installing-prerequisites","content":"All of the needed programs for Honeycomb must be installed before we can develop our task. We will use a package manager to automatically install them. See Prerequisites for more information about these programs. ","version":"3.1.x","tagName":"h2"},{"title":"Initial Install​","type":1,"pageTitle":"Quick Start","url":"/docs/3.1.x/quick_start#initial-install","content":"WindowsmacOS The most commonly used package manager on macOS is Homebrew. Paste the following command in a macOS Terminal and follow the prompts to install Homebrew. /bin/bash -c '$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)' Paste the following command and follow the prompts to install the listed programs: brew bundle Install Xcode (not available on Homebrew) xcode-select --install  note If you are running into issues after installing the packages please restart your terminal and/or reboot your computer. This should resolve most issues. ","version":"3.1.x","tagName":"h3"},{"title":"Setting Up Node​","type":1,"pageTitle":"Quick Start","url":"/docs/3.1.x/quick_start#setting-up-node","content":"NVM (Node Version Manager) is a tool for installing and using multiple versions on node on your computer. It must first be installed: Install NVM WindowsmacOS curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash Copy the version number listed in .nvmrc. The version may be different than the screenshot below. Install that version. nvm install [version] Use the needed version. This will automatically check the version listed in the .nvmrc file. nvm use Set the current version as your default nvm alias default node  note You can skip step 4 if you've already set a default node version in a different project. ","version":"3.1.x","tagName":"h3"},{"title":"Install Dependencies​","type":1,"pageTitle":"Quick Start","url":"/docs/3.1.x/quick_start#install-dependencies","content":"There are many node packages used by Honeycomb that also need to be installed. Node (installed in the previous step) comes with its own package manager to install, update, and maintain these dependencies throughout the development lifecycle. Install Honeycomb's dependencies npm install  Certain dependencies are best installed globally within node. These tools will be available from the command line anywhere on your system. Install Honeycomb's global dependencies npm install -g electron firebase-tools dotenv-cli  ","version":"3.1.x","tagName":"h2"},{"title":"Run the Task in Development Mode​","type":1,"pageTitle":"Quick Start","url":"/docs/3.1.x/quick_start#run-the-task-in-development-mode","content":"Running the task in development mode causes it to hot-reload whenever changes are made to the app. This is how you'll run the project while building your task. Run the task in dev mode npm run dev  This script launches an electron window with the task and inspector open. You can quit the task in the middle of development if needed: WindowsmacOSLinux ⌘ + Q ","version":"3.1.x","tagName":"h2"},{"title":"Saving data​","type":1,"pageTitle":"Quick Start","url":"/docs/3.1.x/quick_start#saving-data","content":"Data is saved throughout the task, even when running in development mode. The location of the task is logged at the beginning of the task wherever you ran npm run dev. Note how the data is organized by study and participant. Every run through of the task will save the data somewhere within this folder! ","version":"3.1.x","tagName":"h3"},{"title":"Edit the Task​","type":1,"pageTitle":"Quick Start","url":"/docs/3.1.x/quick_start#edit-the-task","content":"Now that the task is up and running we can make our first changes to the code! We'll edit the package.json file to reflect your information. Create a new branch git checkout -b &lt;branch-name&gt; Open package.json and edit it to reflect your app: name is your task's name, generally this is the name of our repositorydescription should be rewritten to better match your taskauthor is your lab (or PIs) name, email, and websiteversion should be reset to 1.0.0repository is the link the GitHub repository you created earlier. Save your changes and commit them to git: git commit -m &quot;Commit message goes here!&quot; Create a pull request to bring your changes into the main branch ","version":"3.1.x","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Quick Start","url":"/docs/3.1.x/quick_start#next-steps","content":"Honeycomb tasks can be configured to run as a web app in Firebase, or as desktop application via electron. The desktop application can receive port signals from EEG, cameras, foot pedals, and more. The Firebase page explains how to set up your task with Firebase. To learn more about how to configure your task for these different scenarios, see Environment Variables. The NPM Scripts page lists every script you can run and which environment they use. ","version":"3.1.x","tagName":"h2"},{"title":"Variants","type":0,"sectionRef":"#","url":"/docs/3.1.x/variants","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"Variant-specific Executables​","type":1,"pageTitle":"Variants","url":"/docs/3.1.x/variants#variant-specific-executables","content":"In order to create multiple variants of a task that can be co-installed, it is necessary to add new scripts to the package.json file in addition to creating the necessary environment variables for configuration. Each variant must have a unique, lowercase name. Optionally, a unique icon can be used for each variant by saving multiple icons to the icons directories with the same names as the variants. Example scripts for Windows, Mac, and Linux are shown below. Windows: &quot;package:windows:&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform win32 --arch x64 --icon ./assets/icons/win/&lt;task_name&gt; --out dist/ --overwrite --asar&quot;  &quot;postpackage:windows:&lt;task_name&gt;&quot;: &quot;electron-installer-windows --src dist/&lt;task_name&gt;-win32-x64/ --dest dist/installers/ --overwrite --homepage https://ccv.brown.edu/ --name &lt;task_name&gt; --exe &lt;task_name&gt;.exe --productName &lt;task_name&gt;&quot;  Mac: &quot;package:mac:,&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform darwin --arch x64 --out dist/ --icon ./assets/icons/mac/&lt;task_name&gt;.icns --overwrite&quot;  &quot;installer:mac:&lt;task_name&gt;&quot;: &quot;electron-installer-dmg ./dist/&lt;task_name&gt;-darwin-x64/&lt;task_name&gt;.app &lt;task_name&gt;-${npm_package_version} --out ./dist/installers/ --icon ./assets/icons/mac/&lt;task_name&gt;.icns --overwrite&quot;  Linux: &quot;package:linux:&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform linux --arch x64 --icon ./assets/icons/mac/&lt;task_name&gt; --out dist/ --overwrite&quot;  &quot;postpackage:linux:&lt;task_name&gt;&quot;: &quot;electron-installer-debian --src dist/&lt;task_name&gt;-linux-x64/ --dest dist/installers/ --arch x64 --overwrite --name &lt;task_name&gt; --productName &lt;task_name&gt; --genericName &lt;task_name&gt; --bin &lt;task_name&gt;&quot;  ","version":"3.1.x","tagName":"h2"},{"title":"Variant-specific Workflows​","type":1,"pageTitle":"Variants","url":"/docs/3.1.x/variants#variant-specific-workflows","content":"In order to use Github workflows to build and upload executables for each variant, the build.yaml, package.yaml, and release.yaml files must be modified as well. For all three files, a new row should be added to the matrix variable as follows: variant: [&lt;comma_separated_list_of_variant_names&gt;]  Add the following before npm build in the steps section of build.yaml, package.yaml, and release.yaml: - name: Load .env file for variant uses: xom9ikk/dotenv@v1.0.2 with: path: ./env mode: ${{matrix.variant}}  In package.yaml and release.yaml, replace the # Build electron app package installers section with the following code: - name: package electron - windows if: startsWith(matrix.os, 'windows') run: npm run package:windows:${{ matrix.variant }} - name: package electron - linux if: startsWith(matrix.os, 'ubuntu') run: npm run package:linux:${{ matrix.variant }} - name: package electron - mac if: startsWith(matrix.os, 'mac') run: npm run package:mac:${{ matrix.variant }} - name: npm rebuild - mac if: startsWith(matrix.os, 'mac') run: npm rebuild - name: Mac installer if: startsWith(matrix.os, 'mac') run: npm run installer:mac:${{ matrix.variant }}  Replace the # Upload installers to github action section in package.yaml with the following code: - name: upload win-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'windows') with: name: ${{ format('win-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-setup.exe - name: upload mac-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'mac') with: name: ${{ format('mac-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}.dmg - name: upload linux-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'ubuntu') with: name: ${{ format('linux-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_x64.deb  Replace the # Upload installers to github release section in release.yaml with the following code: - name: Upload app to release - windows if: startsWith(matrix.os, 'windows') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-setup.exe asset_name: ${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-${{ matrix.setting }}-setup.exe tag: ${{ github.ref }} - name: Upload app to release - linux if: startsWith(matrix.os, 'ubuntu') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_x64.deb asset_name: ${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_${{ matrix.setting }}_x64.deb tag: ${{ github.ref }} - name: Upload app to release - mac if: startsWith(matrix.os, 'mac') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}.dmg asset_name: ${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-${{ matrix.setting }}.dmg tag: ${{ github.ref }}  ","version":"3.1.x","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/3.2.x/","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Flexible deployment online and in the lab​","type":1,"pageTitle":"Introduction","url":"/docs/3.2.x/#flexible-deployment-online-and-in-the-lab","content":"Honeycomb provides the ability to write one codebase and use it flexibly across settings (with guaranteed consistency in instructions, timing, etc.). The same code-base is used to maintain and deploy the identical task on Mechanical Turk, Prolific, and in research settings during concurrent electrophysiological recordings. ","version":"3.2.x","tagName":"h3"},{"title":"Easy-to-install executables​","type":1,"pageTitle":"Introduction","url":"/docs/3.2.x/#easy-to-install-executables","content":"Deployment specifications are abstracted as parameters that are easy to configure, and application building is automated via GitHub actions providing continuous delivery of easy-to-download executables, easing setup burden across research sites. ","version":"3.2.x","tagName":"h3"},{"title":"Foundation in jsPsych​","type":1,"pageTitle":"Introduction","url":"/docs/3.2.x/#foundation-in-jspsych","content":"jsPsych 7 tasks can be converted to the Honeycomb structure to take advantage of the flexible deployment and automated GitHub Actions workflow that Honeycomb provides. ","version":"3.2.x","tagName":"h3"},{"title":"Community Driven​","type":1,"pageTitle":"Introduction","url":"/docs/3.2.x/#community-driven","content":"Honeycomb additionally provides a Behavioral Task Hub at our Beehive website. These tasks are built in Honeycomb and are ready to be deployed. ","version":"3.2.x","tagName":"h3"},{"title":"Cite this work​","type":1,"pageTitle":"Introduction","url":"/docs/3.2.x/#cite-this-work","content":"If you use Honeycomb in your work, please cite Provenza, N.R., Gelin, L.F.F., Mahaphanit, W., McGrath, M.C., Dastin-van Rijn, E.M., Fan, Y., Dhar, R., Frank, M.J., Restrepo, M.I., Goodman, W.K. and Borton, D.A., 2021. Honeycomb: a template for reproducible psychophysiological tasks for clinic, laboratory, and home use. Brazilian Journal of Psychiatry, 44, pp.147-155. ","version":"3.2.x","tagName":"h3"},{"title":"Continuous Integration / Deployment","type":0,"sectionRef":"#","url":"/docs/3.2.x/ci_cd","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"What are Github Actions​","type":1,"pageTitle":"Continuous Integration / Deployment","url":"/docs/3.2.x/ci_cd#what-are-github-actions","content":"GitHub Actions automate tasks within the development life cycle of your software. GitHub Actions consist of a series of commands that run after a specified event has occurred. For example, every time someone creates a pull request for a repository, you can automatically run a command to build and test your software. You can learn more about the events that trigger workflows in GitHub's documentation GitHub Actions are written as YML files inside the .github/workflows/ folder of your repository. ","version":"3.2.x","tagName":"h2"},{"title":"Honeycomb's CI/CD Workflows​","type":1,"pageTitle":"Continuous Integration / Deployment","url":"/docs/3.2.x/ci_cd#honeycombs-cicd-workflows","content":"Honeycomb includes workflows to build and create installers for Windows, Mac and Linux, as well as for deploying to Firebase. These workflows exist for two configurations of the tasks: Home: The app does not expect event code triggers and photodiode spots.Clinic: The app expects event code triggers and photodiode spots. tip Event code triggers and photodiode spots can only be used on local applications! They will not appear when Honeycomb is deployed on the web. pull_request.yaml: Every time an Pull Request (PR) is opened the software is built and tests are run for all platforms with home and clinic settings. This workflow does not upload desktop installers. release.yml: Every time a release is created, edited, or published installers for the Honeycomb app are created and uploaded to the release. This also builds a PsiTurk version and deploys the app to GitHub pages. workflow-package.yaml: Create installers for any/all platforms for the home and/or clinic setting on demand. The installers/executables are uploaded as artifacts and are available for download from the GitHub Actions tab. This also builds a PsiTurk version when linux or all operating systems are selected. note On-demand workflows are triggered manually from the GitHub Actions tab. Each GitHub organization/individual has a quota on storage in private repositories. Uploading artifacts counts against your quota. You may consider configuring your workflows to only upload what you need. You can learn more about GitHub's storage limits in their official documentation. workflow-delete-artifacts.yaml: On demand workflow for deleting artifacts form your GitHub repository. This can be useful when the package.yaml workflow is run multiple times and you want to delete the artifacts from previous runs. ","version":"3.2.x","tagName":"h2"},{"title":"Firebase​","type":1,"pageTitle":"Continuous Integration / Deployment","url":"/docs/3.2.x/ci_cd#firebase","content":"firebase-hosting-merge.yaml: Deploys the web version of the application to Firebase when a PR is merged into the main branch.firebase-hosting-pull-request.yaml: Creates a preview version of the application with Firebase when a PR is opened. danger While this workflow uses a preview link it does use the production database. Ensure you use a test study to not conflict with your participant data. note If you are not planning on ever using Firebase these workflows may be safely deleted. ","version":"3.2.x","tagName":"h3"},{"title":"Version Control","type":0,"sectionRef":"#","url":"/docs/3.1.x/version_control","content":"","keywords":"javascript  jspsych","version":"3.1.x"},{"title":"Git Overview​","type":1,"pageTitle":"Version Control","url":"/docs/3.1.x/version_control#git-overview","content":"Git is a version control system that enables you to track changes to files. With Git, you are able to revert files back to previous versions, restore deleted files, remove added files and even track down where a particular line of code was introduced. Nearly all operations that are performed by Git are in your local computing environment, for the exception of few used purely to synchronize with a remote. Some of the most common git operations are depicted below.  If you would like to make any changes to current repository, it is always good to start with creating a feature branch, where you can save all the changes.  ","version":"3.1.x","tagName":"h2"},{"title":"Create a Pull Request​","type":1,"pageTitle":"Version Control","url":"/docs/3.1.x/version_control#create-a-pull-request","content":"Pull requests are useful before you merge your branch with the main branch. You can request a review from your colleagues and check for any conflicts with the main branch. After you pushed all the changes to your branch, you can go to the original GitHub repository and click on the pull request.   ","version":"3.1.x","tagName":"h2"},{"title":"Stay up-to-date with Honeycomb template repo​","type":1,"pageTitle":"Version Control","url":"/docs/3.1.x/version_control#stay-up-to-date-with-honeycomb-template-repo","content":"Honeycomb is an active project, and will be updated with new features over time. To bring changes from the Honeycomb template repository to your task: Add Honeycomb as an additional remote as follows: git remote add honeycomb https://github.com/brown-ccv/honeycomb.git Fetch the changes made to Honeycomb git fetch --all Merge the current Honeycomb repo git merge honeycomb/main --allow-unrelated histories  caution There will almost certainly be many &quot;merge conflicts&quot; when merging in changes form the template repository. It is tedious but extremely import to not accidentally overwrite your task when resolving these conflicts ","version":"3.1.x","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Version Control","url":"/docs/3.1.x/version_control#best-practices","content":"","version":"3.1.x","tagName":"h2"},{"title":"Git Branches​","type":1,"pageTitle":"Version Control","url":"/docs/3.1.x/version_control#git-branches","content":"main is the default branch and where releases are made from. This branch should be in clean/working conditions at all times. This branch is protected and can only be merged from Pull Requests for topic branches. topic branches are created for new features, fixes, or really any changes. E.g, fix-task-trial2-stuck-button This flow is sometimes referred to as Feature Branch Workflow ","version":"3.1.x","tagName":"h3"},{"title":"Basic Workflow​","type":1,"pageTitle":"Version Control","url":"/docs/3.1.x/version_control#basic-workflow","content":"We recommend using a simple flow based on following rules: Use topic/feature branches, no direct commits on main.Perform tests and code reviews before merges into main, not afterwards.Every branch starts from main, and targets main.Commit messages reflect intent. ","version":"3.1.x","tagName":"h3"},{"title":"Comment styles​","type":1,"pageTitle":"Version Control","url":"/docs/3.1.x/version_control#comment-styles","content":"We encourage using Commitizen, a great tool for recording descriptions of commits in a standardized format which makes it easier for people to understand what changed in the code. ","version":"3.1.x","tagName":"h3"},{"title":"Cheatsheet​","type":1,"pageTitle":"Version Control","url":"/docs/3.1.x/version_control#cheatsheet","content":"","version":"3.1.x","tagName":"h2"},{"title":"Git Commands​","type":1,"pageTitle":"Version Control","url":"/docs/3.1.x/version_control#git-commands","content":"Command\tBriefgit add &lt;files&gt;\tadd a file to next commit (stage) git commit -m &lt;message&gt;\tcommit staged files git push\tupload staged commit to repo git pull\tget remote repo commits and download (try and resolve conflicts) git clone &lt;url&gt;\tdownload entire repository git checkout &lt;branch&gt;\tcheckout and create the branch you want to use # create branch with your feature git checkout -b feature_name # check the status of your repositoey git status # commit file contents to the local repository git commit -m &quot;My feature is ready&quot; # specific message # push file contents to the remote (i.e. cloud) repository git push origin feature_name  ","version":"3.1.x","tagName":"h3"},{"title":"Alternative options​","type":1,"pageTitle":"Version Control","url":"/docs/3.1.x/version_control#alternative-options","content":"VS Code​ Most IDEs have some built in tools for working with Git and VS Code is no exception. Check out this overview of source control in VS Code! GitHub Desktop​ GitHub Desktop is a GUI application for working with git. It is one of the programs installed as a prerequisite of Honeycomb. Check out this overview of source control in GitHub Desktop! ","version":"3.1.x","tagName":"h3"},{"title":"Directory Structure","type":0,"sectionRef":"#","url":"/docs/3.2.x/directory_structure","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"assets/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#assets","content":"This folder contains any static files that are used by the app. Honeycomb starts with a few images used as icons for the installed applications. caution Assets that pertain to your specific task should be added to the public/assets/ folder, not here! ","version":"3.2.x","tagName":"h2"},{"title":"build/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#build","content":"The build scripts automatically create a build folder at the root of the repository and update it on subsequent builds. build/ should be left alone! danger The build folder is in Honeycomb's .gitignore and should never be added to git ","version":"3.2.x","tagName":"h2"},{"title":"emulator_data/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#emulator_data","content":"This folder contains starter data for the Firebase Emulators to use while developing locally. See the Firebase Scripts to use the data. danger emulator_data/ is written to when running npm run firebase:emulators:save and should never be manually edited. ","version":"3.2.x","tagName":"h2"},{"title":"env/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#env","content":"This folder contains different files used to pass environment variables (settings) into Honeycomb. Honeycomb starts with presets for common use cases and is explained in greater detail in the Environment Variables section. ","version":"3.2.x","tagName":"h2"},{"title":"node_modules/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#node_modules","content":"danger node_modules/ is written to when running npm install and should never be manually edited. ","version":"3.2.x","tagName":"h2"},{"title":"psiturkit/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#psiturkit","content":"The file psiturk-it inside psiturkit/ is a bash script used to instal PsiTurk locally - see PsiTurk for more information. caution Nothing in this folder should ever need to be manually edited. ","version":"3.2.x","tagName":"h2"},{"title":"public/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#public","content":"The public directory contains files that are used as assets in the built app. index.html is the entry point of the website Changing &lt;title&gt;Honeycomb&lt;/title&gt; will update the name you can see in the browser tab. favicon.ico is the small icon you can see in the browser tab.electron.js contains all of the code related to the electron app. ","version":"3.2.x","tagName":"h2"},{"title":"assets/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#assets-1","content":"The public/assets/ directory contains all of the images and videos needed to run your task. ","version":"3.2.x","tagName":"h3"},{"title":"lib/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#lib","content":"The public/lib/ directory contains the files PsiTurk needs to run. Note that index.html references these files inside the &lt;script&gt; tags. danger These files are minified versions of dependencies and should never be manually edited. ","version":"3.2.x","tagName":"h3"},{"title":"config/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#config","content":"The public/config/ directory contains the config files needed for the electron app. This includes the event-marker details and event codes. version.json keeps track of the current git commit, which Honeycomb uses to keep track of the version of your task used for a given experiment. ","version":"3.2.x","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#src","content":"This folder contains the source code for the Honeycomb application. ","version":"3.2.x","tagName":"h2"},{"title":"App/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#app","content":"Files relating to the React application. This is the code that runs your JsPsych task and shouldn't need to be changed. components/​ The React components that make up Honeycomb are located here. App.jsx initializes and maintains the state of the application. It is also where communication is set up between the electron and psiturk processes.Error.jsx displays a small error message. It is rendered when the App.jsx detects an issue in state.JsPsychExperiment.jsx initializes the JsPsych experimentLogin.jsx handles user authentication based on the environment variables passed to Honeycomb deployments/​ Custom code used by the various deployments such as Firebase. caution Changes to these files will change how Honeycomb handles data and should be done with great caution. ","version":"3.2.x","tagName":"h3"},{"title":"config/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#config-1","content":"Each file in the config directory contains settings for a different part of the task. main.js contains the global settings (e.g. whether Honeycomb is running online or in the clinic) passed from env variables and logic for loading the appropriate language file.trigger.js for equipment-related settings (e.g. event markers). It uses a slightly different style of javascript as it is imported both in the React app as well as the electron process.config.json contains the settings for your task. Usage of the config file allows for easy updating of task settings. Common settings can be written once in the config file and re-used throughout the task.language.json contains the language used in your task. Usage of language json files allows for easy internationalization of the task (e.g. english and spanish) and mturk-specific language. Common phrases can be written once in a language file and re-used throughout the task. ","version":"3.2.x","tagName":"h3"},{"title":"lib/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#lib-1","content":"A library of utility and markup are located here. This allows for functions and html to be re-used wherever needed. markup/​ src/lib/markup/ files contain HTML templates used throughout the task. stimuli.js contains a baseStimulus function that wraps some markup in a container that takes up 100% of the height and width of the viewportphotodiode.js contains the markup for the photodiode box and spot. It is displayed in the bottom right corner of the scree.tags.js contains functions for wrapping language in common html tags. p('Hello World') will return &lt;p&gt;Hello World&lt;/p&gt;. You should always wrap your language in a tag to ensure it is displayed correctly. tip The tag function inside tags.js can be used to wrap language in any html tag you need. utils.js​ utils.js contains utility functions that can be used across a variety of trials. Be sure to look for functions you might be able to use in your task! ","version":"3.2.x","tagName":"h3"},{"title":"timelines/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#timelines","content":"A timeline is a collection of trials that JsPsych displays in the given order. Timelines can contain timelines themselves; you may want to break this nesting into multiple files in this folder. main.js contains the JsPsych options and root timeline which App.jsx uses to run the experiment.honeycombBlock.js contains the timeline for the Honeycomb block - the &quot;meat&quot; the example reaction-time task. It uses the task settings from config.json.honeycombTimeline.js contains the timeline for the entire Honeycomb task. This includes the block timeline from honeycombBlock.js, as well as individual trials such as the welcome screen, full screen trial, and instructions.preamble.js contains a base timeline for showing the name and welcome screen of an experiment, as well as automatically entering fullscreen mode. It adds the photodiode instructions to the timeline if Honeycomb is using the photodiode. ","version":"3.2.x","tagName":"h3"},{"title":"trials/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#trials","content":"A trial is the base unit of a JsPsych experiment. Each trial should be its own file within this folder - the files in src/timelines/ will combine these trials into the full experiment. honeycombTrials.js contains the individual trials used in the Honeycomb task. These trials are imported into honeycombBlock.js and honeycombTimeline.js.adjustVolume.js prompts the user to adjust the volume on their computer.camera.js contains trials for beginning and ending a camera recording.fullscreen.js contains trials for entering and exiting fullscreen mode.holdUpMarker.js prompts the user to connect their event marker and hold it up to the camera.quizTrial.js contains trials for a quiz/survey.startCode.js emits a start code to a photodiode spot and audible beep ","version":"3.2.x","tagName":"h3"},{"title":"index.js​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#indexjs","content":"index.js is the entry point for React in our application. Note that the id 'root' corresponds with a tag in public/index.html: &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  ","version":"3.2.x","tagName":"h3"},{"title":"Other Folders/Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#other-foldersfiles","content":".nvmrc determines which version of node that Honeycomb is designed to be run on.github/workflows/ contains .yaml files used to build Honeycomb on a pull request (build.yaml) and create task executables either in a single instance (package.yaml) or for a full release (release.yaml)package.json contains metadata about your project, a list of the dependencies needed for the project, and scripts to run tasks related to your task. The Quick Start lists which metadata should be changed.cli.mjs is the script used to download and delete data stored in Firestore.version.js is the script used to keep track of which version of the task a given experiment is using danger package-lock.json is written to when running npm install and should never be manually edited. ","version":"3.2.x","tagName":"h2"},{"title":"Firebase Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#firebase-files","content":".firebaserc contains the name of the project Firebase should connect to. Be sure to update the default project to the one you created!firebase.json contains the Firebase settings for Honeycomb.firestore.indexes.json contains the Firestore index settings for Honeycomb.firestore.rules contains the Firestore rules for creating/editing data. caution firebase.json, firestore.indexes.json, and firestore.rules shouldn't need to be manually edited. ","version":"3.2.x","tagName":"h3"},{"title":"Git Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#git-files","content":".gitignore lists the folders and files that should be excluded from Git. danger Any secrets and/or tokens must be added to .gitignore or they will be visible to anyone with access to the repository! ","version":"3.2.x","tagName":"h3"},{"title":"Eslint Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#eslint-files","content":".eslintrc.js contains the Eslint settings for Honeycomb. We recommend it's left alone but can be adjusted for personal settings..eslintignore lists the folders and files that eslint shouldn't touch, similar to .gitignore. ","version":"3.2.x","tagName":"h3"},{"title":"Prettier Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.2.x/directory_structure#prettier-files","content":".prettierrc.js contains the Prettier settings for Honeycomb. We recommend it's left alone but can be adjusted for personal settings. ","version":"3.2.x","tagName":"h3"},{"title":"GitHub Pages","type":0,"sectionRef":"#","url":"/docs/3.2.x/gh_pages","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Setup​","type":1,"pageTitle":"GitHub Pages","url":"/docs/3.2.x/gh_pages#setup","content":"Please follow the GitHub documentation for setting up GH Pages on your repository and make sure the publishing source for your repository is configured for gh-pages branch. ","version":"3.2.x","tagName":"h3"},{"title":"JavaScript","type":0,"sectionRef":"#","url":"/docs/3.2.x/javascript","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Learning JavaScript​","type":1,"pageTitle":"JavaScript","url":"/docs/3.2.x/javascript#learning-javascript","content":"The Mozilla Developer Network Web Docs is the gold standard for programming on the web. The JavaScript page is an excellent place for further reading about JavaScript. ","version":"3.2.x","tagName":"h2"},{"title":"Interactive Tutorials​","type":1,"pageTitle":"JavaScript","url":"/docs/3.2.x/javascript#interactive-tutorials","content":"Learn JavaScript is an excellent platform for beginning to learn the JavaScript programming language. It is full of interactive tutorials and small projects. ","version":"3.2.x","tagName":"h2"},{"title":"Environment Variables","type":0,"sectionRef":"#","url":"/docs/3.2.x/environment_variables","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Understanding the Environment Variables​","type":1,"pageTitle":"Environment Variables","url":"/docs/3.2.x/environment_variables#understanding-the-environment-variables","content":"","version":"3.2.x","tagName":"h2"},{"title":"Run-time​","type":1,"pageTitle":"Environment Variables","url":"/docs/3.2.x/environment_variables#run-time","content":"The badge indicates the variable is set/determined each time the executable is run. Run-time environment variables allow for quick changes when running the task. They are convenient since they don't require building a whole different executable. Desktop deployments must set these environment variables at the system level. See this tutorial for OS specific instructions.. Online deployments must use Firebase, and store the runtime environment variables in Firestore. ","version":"3.2.x","tagName":"h3"},{"title":"Build-time​","type":1,"pageTitle":"Environment Variables","url":"/docs/3.2.x/environment_variables#build-time","content":"The badge indicates the variable is set during the build phase (npm run build) and cannot be changed at run-time. These variables are configured via .env files in the env folder. The dotenv-cli comes with the dotenv command that can be used to properly load the needed variables. We write our npm scripts with the following format: package.json &quot;[build|dev]:&lt;env name&gt;&quot;: &quot;dotenv -e env/&lt;env name&gt; npm run [build|dev]&quot;  See NPM Scripts for more ","version":"3.2.x","tagName":"h3"},{"title":"Event Triggers","type":0,"sectionRef":"#","url":"/docs/3.2.x/event_triggers","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"BrainVision Trigger Box setup​","type":1,"pageTitle":"Event Triggers","url":"/docs/3.2.x/event_triggers#brainvision-trigger-box-setup","content":"Follow the TriggerBox setup instructions in the BrainVision Trigger Box manual. Plug the TriggerBox into the computer running the task. Check your operating system’s device list to identify the COM port that the TriggerBox is connected to. Create a new system environment variable: COMNAME  and set the COM port to the correct value (e.g., COM3). ","version":"3.2.x","tagName":"h2"},{"title":"Open Source Event Trigger setup​","type":1,"pageTitle":"Event Triggers","url":"/docs/3.2.x/event_triggers#open-source-event-trigger-setup","content":"Details on how to make the open source event trigger and photodiode can be found here. Connect the open source event trigger to the computer running the task using a USB to micro-USB cable. Check your operating system’s USB device list to identify the product ID of the teensyduino event marker. Create a new system environment variable: EVENT_MARKER_PRODUCT_ID and set to the product ID of the event marker. ","version":"3.2.x","tagName":"h2"},{"title":"Send event code triggers​","type":1,"pageTitle":"Event Triggers","url":"/docs/3.2.x/event_triggers#send-event-code-triggers","content":"Change the eventCodes values listed in the src/config/trigger.js file to the desired values. Import eventCodes from ./trigger and export as eventCodes. Whenever you would like to send an event code in a trial, load eventCodes from ../config/main/, and call pdSpotEncode with the proper eventCode (e.g. eventCode.Fixation) as input. ","version":"3.2.x","tagName":"h2"},{"title":"Run the task with event triggers​","type":1,"pageTitle":"Event Triggers","url":"/docs/3.2.x/event_triggers#run-the-task-with-event-triggers","content":"Honeycomb automatically checks whether your event marker is connected and running at the start of the task. If it is not connected, the task will present an error and will not be able to run. ","version":"3.2.x","tagName":"h2"},{"title":"Local Application","type":0,"sectionRef":"#","url":"/docs/3.2.x/local_application","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Creating a Release​","type":1,"pageTitle":"Local Application","url":"/docs/3.2.x/local_application#creating-a-release","content":"Follow the GitHub documentation for creating a release. The tag should be in the format vX.X.X where X.X.X is the version number of the release. For example, if the release is version 1.0.0, the tag should be v1.0.0. danger Your release must included a new tag for the CI/CD workflow to work. ","version":"3.2.x","tagName":"h2"},{"title":"Running the task​","type":1,"pageTitle":"Local Application","url":"/docs/3.2.x/local_application#running-the-task","content":"Navigate to the repository's &quot;Releases&quot; tab and select the tag you just created.Download the installer for your operating system.Double click the installer to run it. Follow the instructions to install the application.The application will automatically start after the first instillation. The executable does not require installation of any additional software! ","version":"3.2.x","tagName":"h2"},{"title":"Working with Data​","type":1,"pageTitle":"Local Application","url":"/docs/3.2.x/local_application#working-with-data","content":"Data is automatically saved to a nested folder structure on the Desktop. Each session will be saved as its own .json file nested under the id of the study and participant. ","version":"3.2.x","tagName":"h2"},{"title":"Firebase","type":0,"sectionRef":"#","url":"/docs/3.2.x/firebase","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Setting up Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#setting-up-firebase","content":"info Members of Brown University should submit a support ticket to have their Firebase project created. Members of other institutions should check to see if their university has access to Google Cloud. Otherwise, a personal Firebase account can be created for free. Please follow the firebase documentation for creating a new project. ","version":"3.2.x","tagName":"h2"},{"title":"Adding Products​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#adding-products","content":"First we'll configure Firebase Hosting and Cloud Firestore on your project. Log in to Firebase with your Google account on the Firebase console. Navigate to your project from the console Register a new web app to your project (Register your app) note We recommend giving your web app the same name as your task's repository Add Firestore Database to your project (Create a Cloud Firestore database) note Chose production mode for the starting mode and the default &quot;Cloud Firestore Location&quot; The Firebase project is now fully set up! Now we'll connect your task to that project from your computer. ","version":"3.2.x","tagName":"h3"},{"title":"Installing the Command Line Interface​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#installing-the-command-line-interface","content":"The Firebase CLI is installed with the node package manager just like the rest of Honeycomb's dependencies. Be sure to log in with same account you used when logging into the console! Install the Firebase CLI npm install -g firebase-tools  Login to Firebase firebase login  A &quot;command not found&quot; error usually indicates firebase-tools has not been installed correctly ","version":"3.2.x","tagName":"h3"},{"title":"Connecting Your Firebase Project​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#connecting-your-firebase-project","content":"Change the default project name of your task in .firebaserc .firebaserc { &quot;projects&quot;: { &quot;default&quot;: &quot;&lt;your project name&gt;&quot; } }  Copy the web app credentials from the Firebase console to the corresponding variables in .env.firebase Return to your project on the Firebase console. Navigate to your project setting Scroll down and copy the auto-generated values from the Firebase console to the corresponding variables in the .env.firebase file in the env folder of your Honeycomb task repo env/.env.firebase REACT_APP_FIREBASE=&quot;true&quot; REACT_APP_apiKey= REACT_APP_authDomain= REACT_APP_projectId= REACT_APP_storageBucket= REACT_APP_messagingSenderId= REACT_APP_appId= Additional variables may be present in the console, they do not need to be copied. Deploy the default Firestore security rules Deploy Firestore rules firebase deploy --only firestore:rules  Your task is now connected to an initialized Firebase project! ","version":"3.2.x","tagName":"h3"},{"title":"Registering Studies​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#registering-studies","content":"caution This step must be followed exactly. See Security Rules for more information. Navigate to your Firestore Database in the console.Click &quot;Start collection&quot;Enter registered_studies for the collection id and click &quot;next&quot;Enter the id of your study for the document idAdd a field named registered_participants with the type &quot;array&quot;Add the id of each study participant as a string inside the array   The study should like this when you're finished:    Additional studies must be created inside the registered_studies collection ","version":"3.2.x","tagName":"h2"},{"title":"Developing With Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#developing-with-firebase","content":"Two terminal windows must be used while developing for Firebase. See here for instructions on splitting terminals in VSCode. Run Honeycomb with Firebase Enabled npm run dev:firebase  Start the Firebase Emulators npm run firebase:emulators:start  Honeycomb is now running in the browser and connected to data on an emulated instance of Firestore. It may be viewed at http://localhost:4000/firestore. info Honeycomb populates the Firestore emulators with the study s1 and participant p1. ","version":"3.2.x","tagName":"h2"},{"title":"Deploying on Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#deploying-on-firebase","content":"Firebase deployments are handled automatically following Continuous Integration Continuous Development (CI/CD) practices using GitHub Actions. Here we will connect create custom actions that are connected to the task's Firebase project. Execute the following command to begin initializing Firebase hosting via GitHub actions. Be sure to follow the instructions below as the prompts appear. Initialize Firebase hosting via Github actions firebase init hosting:github  The window should log you in automatically. If not, follow the prompts to log in with the same account you used in the console.&lt;username&gt;/&lt;repository name&gt; refers to the name of your repository in Github. Be sure it's typed correctly!Enter y for the prompt &quot;Set up the workflow to run a build script before every deploy?&quot;Enter npm install &amp;&amp; npm run build:firebase for the prompt &quot;What script should be run before every deploy?&quot;Enter y to overwrite the current workflow fileEnter y for the prompt &quot;Set up automatic deployment to your site's live channel when a PR is merged?&quot;Enter main for the prompt &quot;What is the name of the GitHub branch associated with your site's live channel?&quot;Enter y to overwrite the current workflow file Firebase will update the files firebase-hosting-pull-request.yml and firebase-hosting-merge.yml inside the .github/workflows/ directory. Ensure the correct run script is present in both files.  ","version":"3.2.x","tagName":"h2"},{"title":"Managing Data​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#managing-data","content":"Honeycomb ships with a CLI script for managing data in Firebase. A local service account must be created in order to use it. ","version":"3.2.x","tagName":"h2"},{"title":"Setting up a Service Account​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#setting-up-a-service-account","content":"Service accounts are accounts that are not attached to a human user. They authorize access to a Firebase project without someone physically logging in online. We use a service account to give the download script access to the Firestore database automatically. Return to the project settings your project on the Firebase console. Click on the &quot;Service accounts&quot; tab Near the bottom, click &quot;Generate new Private key&quot; and &quot;Generate Key&quot; Rename the key firebase-service-account.json and move it to the root directory of your task. Be sure the file looks grayed out and is not picked up by git! danger A service account has total administrative access to ts Firebase project. The file and keys inside should never be shared and never committed to GitHub. ","version":"3.2.x","tagName":"h3"},{"title":"Using the CLI Script​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#using-the-cli-script","content":"Script Usage npm run cli  The CLI script will guide you through the steps needed to manage your data appropriately: Whether you wish to download or delete data Entering the ID of a given study Entering the ID of a given participant on that study Selecting the sessions to download/delete info SPACE selects a single session and A toggles every session note The download script will prompt you for where the data should be saved. It defaults to ., which is your current folder. The folder must exist before running the script. ","version":"3.2.x","tagName":"h3"},{"title":"Further Reading​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#further-reading","content":"The Firebase Documentation details its Emulator Suite in much greater detail. ","version":"3.2.x","tagName":"h2"},{"title":"Security Rules​","type":1,"pageTitle":"Firebase","url":"/docs/3.2.x/firebase#security-rules","content":"Honeycomb uses security rules to authenticate participants and studies for each task. By default participants must be registered to each study in order to complete the task. Firestore rules are defined in the firestore.rules file in the home directory. Note the highlighted lines: firestore.rules rules_version = '2'; service cloud.firestore { match /databases/{database}/documents { match /participant_responses/{studyID}/participants/{participantID} { allow create, read: if participantID in get(/databases/$(database)/documents/registered_studies/$(studyID)).data.registered_participants; // ... } } }  Lines 3 and 4 indicate that Honeycomb attempts to connect to a document at /databases/{database}/documents/participant_responses/{studyID}/participants/{participantID} where studyID is a given study and participantID is a given participant within that study. Line 6 defines our rule - it must pass for Honeycomb to connect to the document. participantID must be found in an array called registered_participants inside of a document at /databases/{database}/documents/registered_studies/{studyID}. Line 5 indicates how Honeycomb can interact with that document. Note that Honeycomb cannot update or delete data! You must manually make these changes from the Firestore console. danger Firestore rules must define every match pattern in your project. Attempting to connect anywhere other than /participant_responses/{studyID}/participants/{participantID} will be automatically denied even if you add other collections to your database. This is why firestore.rules contains additional nested rules - these should be left alone. ","version":"3.2.x","tagName":"h3"},{"title":"PsiTurk","type":0,"sectionRef":"#","url":"/docs/3.2.x/psiturk","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Prebuilt version​","type":1,"pageTitle":"PsiTurk","url":"/docs/3.2.x/psiturk#prebuilt-version","content":"When GitHub Actions is run, a PsiTurk build will be created automatically, and can be downloaded from its artifacts. The workflows responsible for building the PsiTurk application are .github/workflows/package.yml and .github/workflows/release.yml. The first one has to be triggered manually, the latter is triggered when you tag a release. If this is all you need, the build instructions below can be skipped! ","version":"3.2.x","tagName":"h3"},{"title":"Build instructions​","type":1,"pageTitle":"PsiTurk","url":"/docs/3.2.x/psiturk#build-instructions","content":"To set up your PsiTurk project, we provide a script that does the conversion. PsiTurk is a Python package used to manage HITs in Mechanical Turk. Before using the provided script, install PsiTurk. You'll need to follow these steps (the path to the PsiTurk project should be a directory you wish to be created): Build the application: npm run build Move to the psiturkit directory: cd psiturkit If it's the first time you're running the script: ./psiturk-it -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt; To update an existing PsiTurk project (the path to the PsiTurk project should already exist from the previous steps): ./psiturk-it -U -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt;  ","version":"3.2.x","tagName":"h3"},{"title":"Running PsiTurk​","type":1,"pageTitle":"PsiTurk","url":"/docs/3.2.x/psiturk#running-psiturk","content":"After that, just navigate to your newly created PsiTurk project directory. shell&gt; psiturk # start psiturk psiturk&gt; server on # start server psiturk&gt; debug # enter debug mode  ","version":"3.2.x","tagName":"h3"},{"title":"NPM Scripts","type":0,"sectionRef":"#","url":"/docs/3.2.x/npm_scripts","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Start​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.2.x/npm_scripts#start","content":"start runs the app in development mode and does NOT open a browser. This makes working with electron easier as it creates its own browser for development.start:browser runs the app in development mode and automatically opens a new browser tab. It uses your system's default browser. The page will reload if you make edits.start:electron: Waits for the app to be running (from start) and then starts an electron process. ","version":"3.2.x","tagName":"h2"},{"title":"Firebase​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.2.x/npm_scripts#firebase","content":"firebase:emulators:start starts the Firebase emulators with the data found in emulator_data/firebase:emulators:save saves the current state of the Firebase emulators into emulator_data/firebase:download runs the firebase-download-script.js script, saving certain data in Firebase to your local machine. ","version":"3.2.x","tagName":"h2"},{"title":"Dev​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.2.x/npm_scripts#dev","content":"npm run dev runs the app in development mode on Electron. It executes start and start:electron concurrently. Note that this is a base script that other scripts build on top of - you should always run one of the scripts below while developing your app. The additional scripts execute npm run dev with different environment variables. dev:home runs the app with equipment disableddev:home:video runs the app with equipment disabled and video enableddev:clinic runs the app with equipment enableddev:clinic:video runs the app with equipment enabled and video enableddev:turk-prolific runs the app with prolific and PsiTurk enabled ","version":"3.2.x","tagName":"h2"},{"title":"Firebase​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.2.x/npm_scripts#firebase-1","content":"Working with Firebase is slightly different as it is meant to be run on the browser. npm run dev:firebase executes start:browser with Firebase enabled, which will automatically launch the running app in your default browser. It can be found on other browsers by navigating to localhost:3000. dev:firebase must be run in conjunction with firebase:emulators:start to work properly. This runs the Firebase Emulators locally with some dummy data. The emulator data can be viewed at localhost:4000. caution npm run firebase:emulators:start must be run in a separate terminal window that stays during development. tip The dummy study is s1 and the dummy participant is p1. ","version":"3.2.x","tagName":"h3"},{"title":"Build​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.2.x/npm_scripts#build","content":"npm run build creates a production build of the app in the build/ folder. Note that this is a base script that other scripts build on top of - you should always run one of the scripts below while developing your app. The additional scripts execute npm run build with different environment variables. build:home builds the app with equipment disabledbuild:home:video builds the app with equipment disabled and video enabledbuild:clinic builds the app with equipment enabledbuild:clinic:video builds the app with equipment enabled and video enabledbuild:firebase builds the app with Firebase enabledbuild:turk-prolific builds the app with prolific and PsiTurk enabled ","version":"3.2.x","tagName":"h2"},{"title":"Package​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.2.x/npm_scripts#package","content":"npm run package:[platform] creates a standalone installer for the given platform using electron-forge. The installer is created in out/. Note that the scripts build the app before creating the installers npm run package:windowsnpm run package:linuxnpm run package:mac info Packaging for windows on a non-windows machine requires mono and wine to be installed. ","version":"3.2.x","tagName":"h2"},{"title":"Miscellaneous​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.2.x/npm_scripts#miscellaneous","content":"commit runs commitizen in the console. It is useful for ensuring your Git commit messages are easy to follow.lint uses Eslint to find problems in the code.format uses Prettier to style code in a consistent format.test launches the test runner in the interactive watch mode. See running tests for more information. ","version":"3.2.x","tagName":"h2"},{"title":"Prerequisites","type":0,"sectionRef":"#","url":"/docs/3.2.x/prerequisites","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"OS Independent​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#os-independent","content":"","version":"3.2.x","tagName":"h2"},{"title":"Git​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#git","content":"git is an open-sourced version control system. It is used to track changes, revert mistakes, and enable peer code reviews! GitHub Desktop is a GUI application used to interact with git and GitHub directly from your computer. It is not strictly needed but many folks find it easier to work with than using git directly from the command line. ","version":"3.2.x","tagName":"h3"},{"title":"Node Version Manager​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#node-version-manager","content":"NodeJS is a cross-platform runtime environment for JavaScript code. Almost every web application today builds on top of node. Node Version Manager manages running multiple versions of node on the same system. The .nvmrc denotes the version of node that Honeycomb uses. ","version":"3.2.x","tagName":"h3"},{"title":"Python​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#python","content":"Python is a high-level programming language. Some &quot;under the hood&quot; tools needed by Honeycomb are written in python so it must be installed on your system. note Honeycomb needs version 3.7 or later to run - the installers use version 3.11. ","version":"3.2.x","tagName":"h3"},{"title":"Oracle JDk​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#oracle-jdk","content":"Java is another high-level programming languages that some tools are written in (namely, the Firebase Emulators). We must install a JDK (Java Development Kit) for it to run. note Honeycomb needs version 11 or later to run - the installers use version 18. ","version":"3.2.x","tagName":"h3"},{"title":"Visual Studio Code​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#visual-studio-code","content":"Visual Studio Code is a well-loved and easy to use integrated development environment (IDE). This is the program you'll use to write your task. ","version":"3.2.x","tagName":"h3"},{"title":"Mac-specific Installs​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#mac-specific-installs","content":"","version":"3.2.x","tagName":"h2"},{"title":"X-Code​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#x-code","content":"XCode is a special IDE for the Apple platform. It comes with everything needed to compile desktop applications from an Apple computer. It must be installed from the terminal: Installing XCode xcode-select --install  ","version":"3.2.x","tagName":"h3"},{"title":"Rosetta​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#rosetta","content":"Rosetta is a translation layer built for Mac computers with Apple Silicon. It should ask to be installed if any of the prerequisite tools need it. Otherwise, this guide can be used to make sure it is on your Apple silicon system. ","version":"3.2.x","tagName":"h3"},{"title":"Windows-specific Install​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#windows-specific-install","content":"","version":"3.2.x","tagName":"h2"},{"title":"Visual Studio​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#visual-studio","content":"Visual Studio is a special IDE for the Windows platform. It comes with everything needed to compile desktop applications from a PC. Visual Studio Community is a free to use platform. caution The &quot;Desktop development with C++&quot; workload must also be installed with Visual Studio. The automated installers should preselect this but you should double check to be certain! ","version":"3.2.x","tagName":"h3"},{"title":"Manual Installation (macOS)​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#manual-installation-macos","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. GitGitHub DesktopNVMPythonOracle JDKVS CodeXcode ","version":"3.2.x","tagName":"h2"},{"title":"Manual Installation (Windows)​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#manual-installation-windows","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. GitGitHub DesktopNVMPythonOracle JDKVS CodeVisual Studio: Visual Studio 2022 CommunityInstall the Native C++ Workflow ","version":"3.2.x","tagName":"h2"},{"title":"Manual Installation (Linux)​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#manual-installation-linux","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. Your preferred installation method for the programs listed above should get you up and running on any Linux distro new enough to support GLIBC_2.28. GitGitHub DesktopNVMPythonOracle JDKVS CodeInstall Clang or follow installation instructions on the electron docsDevelopment headers of GTK 3 and libnotify (Follow installation instructions on the electron docs) ","version":"3.2.x","tagName":"h2"},{"title":"Further Help​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.2.x/prerequisites#further-help","content":"If you are still having issues setting up your computer you can find the full instructions on the electron documentation for your specific OS. ","version":"3.2.x","tagName":"h2"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/docs/3.2.x/quick_start","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Creating Your Task Repository​","type":1,"pageTitle":"Quick Start","url":"/docs/3.2.x/quick_start#creating-your-task-repository","content":"The Honeycomb repository is a template and serves as the starting point for all tasks. Creating your repository from the template starts your project with the same directory structure and files as an existing repository. Go to the Honeycomb repository Click on Use this template and select Create a new repository. Enter the owner, name, and description of your repository and click on Create repository from template. note We recommend creating a public repository and leaving Include all branches unchecked Ensure the repositories workflow permissions are set to &quot;Read and write permissions&quot; Settings -&gt; Actions -&gt; General -&gt; Workflow permissions Additional details about template repositories can be found on the Github Docs. ","version":"3.2.x","tagName":"h2"},{"title":"Cloning the Repository​","type":1,"pageTitle":"Quick Start","url":"/docs/3.2.x/quick_start#cloning-the-repository","content":"With the repository now setup it can be cloned onto your computer. Navigate to the repository on GitHub. Click the Code button and copy the URL Open a terminal and navigate to where you want the cloned directory WindowsmacOS Terminal.app cd 'path/to/directory'  Clone the repo with the following command Paste the URL you copied earlier git clone https://github.com/&lt;YOUR-USERNAME&gt;/&lt;YOUR-REPOSITORY&gt;  note Git can be downloaded here if it is not already on your system. Additional details and alternative methods for cloning a repository can be found on the Github Docs. ","version":"3.2.x","tagName":"h2"},{"title":"Installing Prerequisites​","type":1,"pageTitle":"Quick Start","url":"/docs/3.2.x/quick_start#installing-prerequisites","content":"All of the needed programs for Honeycomb must be installed before we can develop our task. We will use a package manager to automatically install them. See Prerequisites for more information about these programs. ","version":"3.2.x","tagName":"h2"},{"title":"Initial Install​","type":1,"pageTitle":"Quick Start","url":"/docs/3.2.x/quick_start#initial-install","content":"WindowsmacOS The most commonly used package manager on macOS is Homebrew. Paste the following command in a macOS Terminal and follow the prompts to install Homebrew. /bin/bash -c '$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)' Paste the following command and follow the prompts to install the listed programs: brew bundle Install Xcode (not available on Homebrew) xcode-select --install  note If you are running into issues after installing the packages please restart your terminal and/or reboot your computer. This should resolve most issues. ","version":"3.2.x","tagName":"h3"},{"title":"Setting Up Node​","type":1,"pageTitle":"Quick Start","url":"/docs/3.2.x/quick_start#setting-up-node","content":"NVM (Node Version Manager) is a tool for installing and using multiple versions on node on your computer. It must first be installed: Install NVM WindowsmacOS curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash Copy the version number listed in .nvmrc. The version may be different than the screenshot below. Install that version. nvm install [version] Use the needed version. This will automatically check the version listed in the .nvmrc file. nvm use Set the current version as your default nvm alias default node  note You can skip step 4 if you've already set a default node version in a different project. ","version":"3.2.x","tagName":"h3"},{"title":"Install Dependencies​","type":1,"pageTitle":"Quick Start","url":"/docs/3.2.x/quick_start#install-dependencies","content":"There are many node packages used by Honeycomb that also need to be installed. Node (installed in the previous step) comes with its own package manager to install, update, and maintain these dependencies throughout the development lifecycle. Install Honeycomb's dependencies npm install  Certain dependencies are best installed globally within node. These tools will be available from the command line anywhere on your system. Install Honeycomb's global dependencies npm install -g electron firebase-tools dotenv-cli  ","version":"3.2.x","tagName":"h2"},{"title":"Run the Task in Development Mode​","type":1,"pageTitle":"Quick Start","url":"/docs/3.2.x/quick_start#run-the-task-in-development-mode","content":"Running the task in development mode causes it to hot-reload whenever changes are made to the app. This is how you'll run the project while building your task. Run the task in dev mode npm run dev  This script launches an electron window with the task and inspector open. You can quit the task in the middle of development if needed: WindowsmacOSLinux ⌘ + Q ","version":"3.2.x","tagName":"h2"},{"title":"Saving data​","type":1,"pageTitle":"Quick Start","url":"/docs/3.2.x/quick_start#saving-data","content":"Data is saved throughout the task, even when running in development mode. The location of the task is logged at the beginning of the task wherever you ran npm run dev. Note how the data is organized by study and participant. Every run through of the task will save the data somewhere within this folder! ","version":"3.2.x","tagName":"h3"},{"title":"Edit the Task​","type":1,"pageTitle":"Quick Start","url":"/docs/3.2.x/quick_start#edit-the-task","content":"Now that the task is up and running we can make our first changes to the code! We'll edit the package.json file to reflect your information. Create a new branch git checkout -b &lt;branch-name&gt; Open package.json and edit it to reflect your app: name is your task's name, generally this is the name of our repositorydescription should be rewritten to better match your taskauthor is your lab (or PIs) name, email, and websitehoneycombVersion is the number currently in the version fieldversion should be reset to 1.0.0repository is the link the GitHub repository you created earlier. Save your changes and commit them to git: git commit -m &quot;Commit message goes here!&quot; Create a pull request to bring your changes into the main branch ","version":"3.2.x","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Quick Start","url":"/docs/3.2.x/quick_start#next-steps","content":"Honeycomb tasks can be configured to run as a web app in Firebase, or as desktop application via electron. The desktop application can receive port signals from EEG, cameras, foot pedals, and more. The Firebase page explains how to set up your task with Firebase. To learn more about how to configure your task for these different scenarios, see Environment Variables. The NPM Scripts page lists every script you can run and which environment they use. ","version":"3.2.x","tagName":"h2"},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"/docs/3.2.x/troubleshooting","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Inspecting Errors​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.2.x/troubleshooting#inspecting-errors","content":"When developing Electron apps there are two processes: main, and renderer. In this case main corresponds to electron-starter.js and its console is wherever you called npm run dev or electron . from. renderer corresponds to the React App - this is everything else. The React app's console is in the electron/browser window and can be seen by using dev tools to inspect the window. When running npm run dev, it should open by default. In case you want to find out where the error is coming from when running the app locally: Try reviewing logs in the terminalInspect element in your browser by opening your developer tools. For instance, in Chrome, this can be done via the menu View -&gt; Developer or right-clicking and pressing inspect. ","version":"3.2.x","tagName":"h2"},{"title":"Testing in Linux​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.2.x/troubleshooting#testing-in-linux","content":"When running npm test on Linux, you might get an error that mentions ENOSPC. This is because the test runner creates &quot;watchers&quot; for files in the project repo in order to automatically re-run tests as the files change. Linux limits the number of watchers that can be created at a time and the default limit may be smaller than the number of files in the repo. This is a &quot;known issue&quot; with some test runners on Linux, as in discussions here and here. One simple workaround is to increase the number of allowed watchers (100000 seems to be sufficient): Command that initially fails with ENOSPC: npm testCheck the configured limit on &quot;watchers&quot;: cat /proc/sys/fs/inotify/max_user_watchesEdit the relevant Linux config file: sudo vim /etc/sysctl.confAdd a line at the end of the config file: fs.inotify.max_user_watches=100000Save, exit, and reload the config file: sudo sysctl -pCheck that the limit has changed: cat /proc/sys/fs/inotify/max_user_watchesRetry the initial command, which should now succeed: npm test ","version":"3.2.x","tagName":"h2"},{"title":"Common issues​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.2.x/troubleshooting#common-issues","content":"","version":"3.2.x","tagName":"h2"},{"title":"Installing Dependencies​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.2.x/troubleshooting#installing-dependencies","content":"Brew Not Available​ If you run into issues installing Homebrew in step 1 of Installing Prerequisites it may be because Homebrew is not available on your shell. Older versions of macOS (under 10.14) do not do this automatically. Run the following command to manually add the Homebrew installation location to your PATH so it is available in your shell. echo 'PATH=&quot;/usr/local/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile  note If you're using zsh, also add to your ~/.zshrc file. ","version":"3.2.x","tagName":"h3"},{"title":"NPM Errors​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.2.x/troubleshooting#npm-errors","content":"Try deleting your node_modules folder and the package-lock.json then running npm install then npm run rebuild. This should fix most issues. ","version":"3.2.x","tagName":"h3"},{"title":"Variants","type":0,"sectionRef":"#","url":"/docs/3.2.x/variants","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Variant-specific Executables​","type":1,"pageTitle":"Variants","url":"/docs/3.2.x/variants#variant-specific-executables","content":"In order to create multiple variants of a task that can be co-installed, it is necessary to add new scripts to the package.json file in addition to creating the necessary environment variables for configuration. Each variant must have a unique, lowercase name. Optionally, a unique icon can be used for each variant by saving multiple icons to the icons directories with the same names as the variants. Example scripts for Windows, Mac, and Linux are shown below. Windows: &quot;package:windows:&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform win32 --arch x64 --icon ./assets/icons/win/&lt;task_name&gt; --out dist/ --overwrite --asar&quot;  &quot;postpackage:windows:&lt;task_name&gt;&quot;: &quot;electron-installer-windows --src dist/&lt;task_name&gt;-win32-x64/ --dest dist/installers/ --overwrite --homepage https://ccv.brown.edu/ --name &lt;task_name&gt; --exe &lt;task_name&gt;.exe --productName &lt;task_name&gt;&quot;  Mac: &quot;package:mac:,&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform darwin --arch x64 --out dist/ --icon ./assets/icons/mac/&lt;task_name&gt;.icns --overwrite&quot;  &quot;installer:mac:&lt;task_name&gt;&quot;: &quot;electron-installer-dmg ./dist/&lt;task_name&gt;-darwin-x64/&lt;task_name&gt;.app &lt;task_name&gt;-${npm_package_version} --out ./dist/installers/ --icon ./assets/icons/mac/&lt;task_name&gt;.icns --overwrite&quot;  Linux: &quot;package:linux:&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform linux --arch x64 --icon ./assets/icons/mac/&lt;task_name&gt; --out dist/ --overwrite&quot;  &quot;postpackage:linux:&lt;task_name&gt;&quot;: &quot;electron-installer-debian --src dist/&lt;task_name&gt;-linux-x64/ --dest dist/installers/ --arch x64 --overwrite --name &lt;task_name&gt; --productName &lt;task_name&gt; --genericName &lt;task_name&gt; --bin &lt;task_name&gt;&quot;  ","version":"3.2.x","tagName":"h2"},{"title":"Variant-specific Workflows​","type":1,"pageTitle":"Variants","url":"/docs/3.2.x/variants#variant-specific-workflows","content":"In order to use Github workflows to build and upload executables for each variant, the build.yaml, package.yaml, and release.yaml files must be modified as well. For all three files, a new row should be added to the matrix variable as follows: variant: [&lt;comma_separated_list_of_variant_names&gt;]  Add the following before npm build in the steps section of build.yaml, package.yaml, and release.yaml: - name: Load .env file for variant uses: xom9ikk/dotenv@v1.0.2 with: path: ./env mode: ${{matrix.variant}}  In package.yaml and release.yaml, replace the # Build electron app package installers section with the following code: - name: package electron - windows if: startsWith(matrix.os, 'windows') run: npm run package:windows:${{ matrix.variant }} - name: package electron - linux if: startsWith(matrix.os, 'ubuntu') run: npm run package:linux:${{ matrix.variant }} - name: package electron - mac if: startsWith(matrix.os, 'mac') run: npm run package:mac:${{ matrix.variant }} - name: npm rebuild - mac if: startsWith(matrix.os, 'mac') run: npm rebuild - name: Mac installer if: startsWith(matrix.os, 'mac') run: npm run installer:mac:${{ matrix.variant }}  Replace the # Upload installers to github action section in package.yaml with the following code: - name: upload win-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'windows') with: name: ${{ format('win-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-setup.exe - name: upload mac-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'mac') with: name: ${{ format('mac-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}.dmg - name: upload linux-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'ubuntu') with: name: ${{ format('linux-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_x64.deb  Replace the # Upload installers to github release section in release.yaml with the following code: - name: Upload app to release - windows if: startsWith(matrix.os, 'windows') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-setup.exe asset_name: ${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-${{ matrix.setting }}-setup.exe tag: ${{ github.ref }} - name: Upload app to release - linux if: startsWith(matrix.os, 'ubuntu') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_x64.deb asset_name: ${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_${{ matrix.setting }}_x64.deb tag: ${{ github.ref }} - name: Upload app to release - mac if: startsWith(matrix.os, 'mac') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}.dmg asset_name: ${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-${{ matrix.setting }}.dmg tag: ${{ github.ref }}  ","version":"3.2.x","tagName":"h2"},{"title":"Version Control","type":0,"sectionRef":"#","url":"/docs/3.2.x/version_control","content":"","keywords":"javascript  jspsych","version":"3.2.x"},{"title":"Git Overview​","type":1,"pageTitle":"Version Control","url":"/docs/3.2.x/version_control#git-overview","content":"Git is a version control system that enables you to track changes to files. With Git, you are able to revert files back to previous versions, restore deleted files, remove added files and even track down where a particular line of code was introduced. Nearly all operations that are performed by Git are in your local computing environment, for the exception of few used purely to synchronize with a remote. Some of the most common git operations are depicted below.  If you would like to make any changes to current repository, it is always good to start with creating a feature branch, where you can save all the changes.  ","version":"3.2.x","tagName":"h2"},{"title":"Create a Pull Request​","type":1,"pageTitle":"Version Control","url":"/docs/3.2.x/version_control#create-a-pull-request","content":"Pull requests are useful before you merge your branch with the main branch. You can request a review from your colleagues and check for any conflicts with the main branch. After you pushed all the changes to your branch, you can go to the original GitHub repository and click on the pull request.   ","version":"3.2.x","tagName":"h2"},{"title":"Stay up-to-date with Honeycomb template repo​","type":1,"pageTitle":"Version Control","url":"/docs/3.2.x/version_control#stay-up-to-date-with-honeycomb-template-repo","content":"Honeycomb is an active project, and will be updated with new features over time. To bring changes from the Honeycomb template repository to your task: Add Honeycomb as an additional remote as follows: git remote add honeycomb https://github.com/brown-ccv/honeycomb.git Fetch the changes made to Honeycomb git fetch --all Merge the current Honeycomb repo git merge honeycomb/main --allow-unrelated histories  caution There will almost certainly be many &quot;merge conflicts&quot; when merging in changes form the template repository. It is tedious but extremely import to not accidentally overwrite your task when resolving these conflicts ","version":"3.2.x","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Version Control","url":"/docs/3.2.x/version_control#best-practices","content":"","version":"3.2.x","tagName":"h2"},{"title":"Git Branches​","type":1,"pageTitle":"Version Control","url":"/docs/3.2.x/version_control#git-branches","content":"main is the default branch and where releases are made from. This branch should be in clean/working conditions at all times. This branch is protected and can only be merged from Pull Requests for topic branches. topic branches are created for new features, fixes, or really any changes. E.g, fix-task-trial2-stuck-button This flow is sometimes referred to as Feature Branch Workflow ","version":"3.2.x","tagName":"h3"},{"title":"Basic Workflow​","type":1,"pageTitle":"Version Control","url":"/docs/3.2.x/version_control#basic-workflow","content":"We recommend using a simple flow based on following rules: Use topic/feature branches, no direct commits on main.Perform tests and code reviews before merges into main, not afterwards.Every branch starts from main, and targets main.Commit messages reflect intent. ","version":"3.2.x","tagName":"h3"},{"title":"Comment styles​","type":1,"pageTitle":"Version Control","url":"/docs/3.2.x/version_control#comment-styles","content":"We encourage using Commitizen, a great tool for recording descriptions of commits in a standardized format which makes it easier for people to understand what changed in the code. ","version":"3.2.x","tagName":"h3"},{"title":"Cheatsheet​","type":1,"pageTitle":"Version Control","url":"/docs/3.2.x/version_control#cheatsheet","content":"","version":"3.2.x","tagName":"h2"},{"title":"Git Commands​","type":1,"pageTitle":"Version Control","url":"/docs/3.2.x/version_control#git-commands","content":"Command\tBriefgit add &lt;files&gt;\tadd a file to next commit (stage) git commit -m &lt;message&gt;\tcommit staged files git push\tupload staged commit to repo git pull\tget remote repo commits and download (try and resolve conflicts) git clone &lt;url&gt;\tdownload entire repository git checkout &lt;branch&gt;\tcheckout and create the branch you want to use # create branch with your feature git checkout -b feature_name # check the status of your repositoey git status # commit file contents to the local repository git commit -m &quot;My feature is ready&quot; # specific message # push file contents to the remote (i.e. cloud) repository git push origin feature_name  ","version":"3.2.x","tagName":"h3"},{"title":"Alternative options​","type":1,"pageTitle":"Version Control","url":"/docs/3.2.x/version_control#alternative-options","content":"VS Code​ Most IDEs have some built in tools for working with Git and VS Code is no exception. Check out this overview of source control in VS Code! GitHub Desktop​ GitHub Desktop is a GUI application for working with git. It is one of the programs installed as a prerequisite of Honeycomb. Check out this overview of source control in GitHub Desktop! ","version":"3.2.x","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/3.3.x/","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Flexible deployment online and in the lab​","type":1,"pageTitle":"Introduction","url":"/docs/3.3.x/#flexible-deployment-online-and-in-the-lab","content":"Honeycomb provides the ability to write one codebase and use it flexibly across settings (with guaranteed consistency in instructions, timing, etc.). The same code-base is used to maintain and deploy the identical task on Mechanical Turk, Prolific, and in research settings during concurrent electrophysiological recordings. ","version":"3.3.x","tagName":"h3"},{"title":"Easy-to-install executables​","type":1,"pageTitle":"Introduction","url":"/docs/3.3.x/#easy-to-install-executables","content":"Deployment specifications are abstracted as parameters that are easy to configure, and application building is automated via GitHub actions providing continuous delivery of easy-to-download executables, easing setup burden across research sites. ","version":"3.3.x","tagName":"h3"},{"title":"Foundation in jsPsych​","type":1,"pageTitle":"Introduction","url":"/docs/3.3.x/#foundation-in-jspsych","content":"Honeycomb is built on top of jsPsych, a JavaScript library for running behavioral experiments in a web browser. jsPsych7 tasks can be moved directly into Honeycomb to take advantage of the flexible deployment and automated GitHub Actions workflow that Honeycomb provides. ","version":"3.3.x","tagName":"h3"},{"title":"Community Driven​","type":1,"pageTitle":"Introduction","url":"/docs/3.3.x/#community-driven","content":"Honeycomb additionally provides a Behavioral Task Hub at our Beehive website. These tasks are built in Honeycomb and are ready to be deployed. ","version":"3.3.x","tagName":"h3"},{"title":"Cite this work​","type":1,"pageTitle":"Introduction","url":"/docs/3.3.x/#cite-this-work","content":"If you use Honeycomb in your work, please cite Provenza, N.R., Gelin, L.F.F., Mahaphanit, W., McGrath, M.C., Dastin-van Rijn, E.M., Fan, Y., Dhar, R., Frank, M.J., Restrepo, M.I., Goodman, W.K. and Borton, D.A., 2021. Honeycomb: a template for reproducible psychophysiological tasks for clinic, laboratory, and home use. Brazilian Journal of Psychiatry, 44, pp.147-155. ","version":"3.3.x","tagName":"h3"},{"title":"Continuous Integration / Deployment","type":0,"sectionRef":"#","url":"/docs/3.3.x/ci_cd","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"What are Github Actions​","type":1,"pageTitle":"Continuous Integration / Deployment","url":"/docs/3.3.x/ci_cd#what-are-github-actions","content":"GitHub Actions automate tasks within the development life cycle of your software. GitHub Actions consist of a series of commands that run after a specified event has occurred. For example, every time someone creates a pull request for a repository, you can automatically run a command to build and test your software. You can learn more about the events that trigger workflows in GitHub's documentation GitHub Actions are written as YML files inside the .github/workflows/ folder of your repository. ","version":"3.3.x","tagName":"h2"},{"title":"Honeycomb's CI/CD Workflows​","type":1,"pageTitle":"Continuous Integration / Deployment","url":"/docs/3.3.x/ci_cd#honeycombs-cicd-workflows","content":"Honeycomb includes workflows to build and create installers for Windows, Mac and Linux, as well as for deploying to Firebase. These workflows exist for two configurations of the tasks: Home: The app does not expect event code triggers and photodiode spots.Clinic: The app expects event code triggers and photodiode spots. tip Event code triggers and photodiode spots can only be used on local applications! They will not appear when Honeycomb is deployed on the web. pull_request.yaml: Every time a Pull Request (PR) is created the software is built and tests are run for all platforms with home and clinic settings. This workflow does not upload desktop installers. release.yml: Every time a release is created, edited, or published installers for the Honeycomb app are created and uploaded to the release. This also builds a PsiTurk version and deploys the app to GitHub pages. workflow-package.yaml: Create installers for any/all platforms for the home and/or clinic setting on demand. The installers/executables are uploaded as artifacts and are available for download from the GitHub Actions tab. This also builds a PsiTurk version when linux or all operating systems are selected. note On-demand workflows are triggered manually from the GitHub Actions tab. Each GitHub organization/individual has a quota on storage in private repositories. Uploading artifacts counts against your quota. You may consider configuring your workflows to only upload what you need. You can learn more about GitHub's storage limits in their official documentation. workflow-delete-artifacts.yaml: On-demand workflow for deleting artifacts form your GitHub repository. This can be useful when the package.yaml workflow is run multiple times and you want to delete the artifacts from previous runs. ","version":"3.3.x","tagName":"h2"},{"title":"Firebase​","type":1,"pageTitle":"Continuous Integration / Deployment","url":"/docs/3.3.x/ci_cd#firebase","content":"firebase-hosting-merge.yaml: Deploys the web version of the application to Firebase when a PR is merged into the main branch.firebase-hosting-pull-request.yaml: Creates a preview version of the application with Firebase when a PR is opened. danger While this workflow uses a preview link it does use the production database. Ensure you use a test study to not conflict with your participant data. note These workflows may be safely deleted if you are not planning to ever use Firebase. ","version":"3.3.x","tagName":"h3"},{"title":"Environment Variables","type":0,"sectionRef":"#","url":"/docs/3.3.x/environment_variables","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Understanding the Environment Variables​","type":1,"pageTitle":"Environment Variables","url":"/docs/3.3.x/environment_variables#understanding-the-environment-variables","content":"","version":"3.3.x","tagName":"h2"},{"title":"Run-time​","type":1,"pageTitle":"Environment Variables","url":"/docs/3.3.x/environment_variables#run-time","content":"The badge indicates the variable is set/determined each time the executable is run. Run-time environment variables allow for quick changes when running the task. They are convenient since they don't require building a whole different executable. Desktop deployments must set these environment variables at the system level. See this tutorial for OS specific instructions.. Online deployments must use Firebase, and store the runtime environment variables in Firestore. ","version":"3.3.x","tagName":"h3"},{"title":"Build-time​","type":1,"pageTitle":"Environment Variables","url":"/docs/3.3.x/environment_variables#build-time","content":"The badge indicates the variable is set during the build phase (npm run build) and cannot be changed at run-time. These variables are configured via .env files in the env folder. The dotenv-cli comes with the dotenv command that can be used to properly load the needed variables. We write our npm scripts with the following format: package.json &quot;[build|dev]:&lt;env name&gt;&quot;: &quot;dotenv -e env/&lt;env name&gt; npm run [build|dev]&quot;  See NPM Scripts for more ","version":"3.3.x","tagName":"h3"},{"title":"Event Triggers","type":0,"sectionRef":"#","url":"/docs/3.3.x/event_triggers","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"BrainVision Trigger Box setup​","type":1,"pageTitle":"Event Triggers","url":"/docs/3.3.x/event_triggers#brainvision-trigger-box-setup","content":"Follow the TriggerBox setup instructions in the BrainVision Trigger Box manual. Plug the TriggerBox into the computer running the task. Check your operating system’s device list to identify the COM port that the TriggerBox is connected to. Create a new system environment variable: COMNAME  and set the COM port to the correct value (e.g., COM3). ","version":"3.3.x","tagName":"h2"},{"title":"Open Source Event Trigger setup​","type":1,"pageTitle":"Event Triggers","url":"/docs/3.3.x/event_triggers#open-source-event-trigger-setup","content":"Details on how to make the open source event trigger and photodiode can be found here. Connect the open source event trigger to the computer running the task using a USB to micro-USB cable. Check your operating system’s USB device list to identify the product ID of the teensyduino event marker. Create a new system environment variable: EVENT_MARKER_PRODUCT_ID and set to the product ID of the event marker. ","version":"3.3.x","tagName":"h2"},{"title":"Send event code triggers​","type":1,"pageTitle":"Event Triggers","url":"/docs/3.3.x/event_triggers#send-event-code-triggers","content":"Change the eventCodes values listed in the src/config/trigger.js file to the desired values. Import eventCodes from ./trigger and export as eventCodes. Whenever you would like to send an event code in a trial, load eventCodes from ../config/main/, and call pdSpotEncode with the proper code (e.g. eventCode.Fixation) as input. ","version":"3.3.x","tagName":"h2"},{"title":"Run the task with event triggers​","type":1,"pageTitle":"Event Triggers","url":"/docs/3.3.x/event_triggers#run-the-task-with-event-triggers","content":"Honeycomb automatically checks whether your event marker is connected and running at the start of the task. If it is not connected, the task will present an error and will not be able to run. ","version":"3.3.x","tagName":"h2"},{"title":"Directory Structure","type":0,"sectionRef":"#","url":"/docs/3.3.x/directory_structure","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"assets/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#assets","content":"This folder contains static files that are used by the application. Honeycomb uses a few images as icons for the installed applications. caution Assets that pertain to your specific task should be added to the public/assets/ folder, not here! ","version":"3.3.x","tagName":"h2"},{"title":"build/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#build","content":"The build scripts automatically create a build folder at the root of the repository and update it on subsequent builds. caution build/ should be left alone! It is in Honeycomb's .gitignore and should never be added to git. ","version":"3.3.x","tagName":"h2"},{"title":"emulator_data/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#emulator_data","content":"This folder contains starter data for the Firebase Emulators to use while developing locally. The Firebase Scripts detail how to use this data. caution emulator_data/ is written to when running npm run firebase:emulators:save and should never be edited. ","version":"3.3.x","tagName":"h2"},{"title":"env/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#env","content":"This folder contains different files used to pass environment variables (settings) into Honeycomb. Honeycomb starts with presets for common use cases and is explained in greater detail in the Environment Variables section. ","version":"3.3.x","tagName":"h2"},{"title":"node_modules/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#node_modules","content":"caution node_modules/ is written to when running npm install and should never be edited. It is in Honeycomb's .gitignore and should never be added to git. ","version":"3.3.x","tagName":"h2"},{"title":"psiturkit/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#psiturkit","content":"The file psiturk-it inside psiturkit/ is a bash script used to instal PsiTurk locally - see PsiTurk for more information. caution This folder involves a Honeycomb deployment. The files do not need to be edited. ","version":"3.3.x","tagName":"h2"},{"title":"public/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#public","content":"The public directory contains files that are used as assets in the built app. index.html is the entry point of the website Changing &lt;title&gt;Honeycomb&lt;/title&gt; will update the text in the browser tab! favicon.ico is the small (16x16px) icon you can see in the browser tabmanifest.json contains metadata about the web app caution manifest.json involves project metadata and does not need to be edited. ","version":"3.3.x","tagName":"h2"},{"title":"assets/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#assets-1","content":"The public/assets/ directory contains all of the audio, images, and videos needed to run your task. ","version":"3.3.x","tagName":"h3"},{"title":"electron/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#electron","content":"The public/electron/ directory contains the files needed to run Honeycomb as an Electron app. main.js sets up Electron itselfpreload.js sets up the communication between the main and renderer processes. caution This folder involves a Honeycomb deployment, the files do not need to be edited. ","version":"3.3.x","tagName":"h3"},{"title":"lib/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#lib","content":"The public/lib/ directory contains the files PsiTurk needs to run. Note that index.html references these files inside the &lt;script&gt; tags. caution This folder involves dependencies for a Honeycomb deployment, the files should not be edited. ","version":"3.3.x","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#src","content":"This folder contains the source code for the Honeycomb application. index.js is the entry point for React in our application. Note that the id 'root' corresponds with a tag in public/index.html: &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; caution index.js runs Honeycomb itself and should not be edited. ","version":"3.3.x","tagName":"h2"},{"title":"App/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#app","content":"Files relating to the React application. caution This folder holds the code that runs the jsPsych task, the files do not need to be edited. components/​ The React components that make up Honeycomb are located here. App.jsx initializes and maintains the state of the application.Error.jsx displays a small error message. It is rendered when the App.jsx detects an issue in state.JsPsychExperiment.jsx initializes the jsPsych experiment.Login.jsx handles user authentication based on the environment variables passed to Honeycomb. deployments/​ Custom code used by the various deployments such as Firebase. caution This folder involves Honeycomb deployments, the files do not need to be edited. ","version":"3.3.x","tagName":"h3"},{"title":"config/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#config","content":"Each file in the config directory contains settings for a different part of the task. language.json contains the language used in your task. This file allows for easy internationalization of the task (e.g. English and Spanish) and mturk-specific language. Common phrases can be written once and re-used throughout the task. main.js contains the global settings (e.g., whether Honeycomb is running online or in the clinic) passed from env variables and logic for loading the appropriate files. settings.json contains the settings for your task. Usage of the config file allows for easy updating of task settings. Common settings can be written once and re-used throughout the task. trigger.js contains equipment-related settings for a trigger box. The eventCodes are especially important for marking the types of given trials. ","version":"3.3.x","tagName":"h3"},{"title":"experiment/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#experiment","content":"tip This is where you'll spend most of your time while developing your task! index.js contains the outermost logic for running the experiment. It loads experiment's styling and exports the main timeline and options for the experiment. caution The experiment will not run correctly if the names jsPsychOptions or buildTimeline are changed. honeycomb.js contains the options and timeline for the jsPsych tutorial's &quot;Simple React Time Task&quot;. It serves as an example for the experiment timeline for your task. tip This is just an example experiment! Be sure to write your experiment in its own file. {/ TODO: Link to this in the quick_start guide once it's ready /} procedures/​ A procedure is a tested timeline of trials in jsPsych. Common parameters can be used across trials, and the trials within a procedure can be ordered and repeated as desired. Check out the JsPsych documentation for more information on creating a custom procedure. startProcedure.js contains the procedure for the start of the experiment. It uses the environment and task settings from config.json to create a nested timeline that correctly starts the experiment.honeycombProcedure.js contains the procedure for the Honeycomb task. It displays a fixation dot and presents the stimulus of the example task. tip This is just an example procedure! Be sure to write your procedures in their own files. endProcedure.js contains the procedure for the end of the experiment. It uses the environment and task settings from config.json to create a nested timeline that correctly end the experiment. trials/​ A trial is the base unit of an experiment. These trials are ordered into procedures and timelines to create the task itself. adjustVolume.js prompts the user to adjust the volume on their tablet. camera.js contains trials for beginning and ending a camera recording. conclusion.js displays a message to the user indicating that the experiment has concluded. fixation.js displays a fixation dot in the center of the screen. It contains additional logic for flashing a photodiode spot and emitting an event code based on the environment settings. fullscreen.js contains trials for entering and exiting fullscreen mode. holdUpMarker.js prompts the user to connect their event marker and hold it up to the camera. honeycombTrials.js contains the individual trials used in the Honeycomb task. These trials are imported into experiment/procedures/honeycombProcedure.js and experiment/honeycomb.js. tip These trials are for the example experiment! Be sure to write trials pertaining to your task in their own file(s). introduction.js displays a message to the user welcoming them to the experiment. They must click on a button to continue. name.js displays the name of the task to the user. startCode.js emits a start code to a photodiode spot and audible beep. survey.js contains trials pertaining to a survey/quiz for the user to complete. ","version":"3.3.x","tagName":"h3"},{"title":"lib/​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#lib-1","content":"A library of utility and markup functions are located here. This allows for functions and html to be re-used wherever needed. utils.js contains utility functions that can be used across a variety of trials. Be sure to look for functions you might be able to use in your task! markup/​ Markup files contain HTML templates used throughout the task. photodiode.js contains the markup for the photodiode box and spot displayed in the bottom right corner of the screentags.js contains functions for wrapping language in common html tags. You should always wrap your language in a tag to ensure it is displayed correctly. For example: p('Hello World') will return &lt;p&gt;Hello World&lt;/p&gt;. tip The tag function inside tags.js can be used to wrap language in any html tag you need. ","version":"3.3.x","tagName":"h3"},{"title":"Other Folders/Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#other-foldersfiles","content":".nvmrc determines which version of node that Honeycomb is designed to be run on. .github/workflows/ contains .yaml files used for CI/CD with GitHub Actions. package.json contains metadata about your project, a list of the dependencies needed for the project, and scripts to run tasks related to your task. The Quick Start lists which metadata should be changed. cli.mjs is the script used to download and delete data stored in Firestore. version.js is the script used to keep track of which version of the task a given experiment is using. caution cli.mjs and version.js are automated scripts and should not be edited. package-lock.json is written to when running npm install and should never be edited. ","version":"3.3.x","tagName":"h2"},{"title":"Firebase Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#firebase-files","content":".firebaserc contains the name of the project Firebase should connect to. Be sure to update the default project to the one you created!firebase.json contains the Firebase settings for Honeycomb.firestore.indexes.json contains the Firestore index settings for Honeycomb.firestore.rules contains the Firestore rules for creating/editing data. caution firebase.json and firestore.indexes.json are default configs and shouldn't need to be edited. ","version":"3.3.x","tagName":"h3"},{"title":"Git Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#git-files","content":".gitignore lists the folders and files that should be excluded from Git. caution Any secrets and/or tokens must be added to .gitignore or they will be visible to anyone with access to the repository! ","version":"3.3.x","tagName":"h3"},{"title":"Eslint Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#eslint-files","content":".eslintrc.js contains the Eslint settings for Honeycomb. We recommend it's left alone but can be adjusted for personal preference..eslintignore lists the folders and files that eslint shouldn't touch, similar to .gitignore. ","version":"3.3.x","tagName":"h3"},{"title":"Prettier Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/3.3.x/directory_structure#prettier-files","content":".prettierrc.js contains the Prettier settings for Honeycomb. We recommend it's left alone but can be adjusted for personal preference. ","version":"3.3.x","tagName":"h3"},{"title":"JavaScript","type":0,"sectionRef":"#","url":"/docs/3.3.x/javascript","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Learning JavaScript​","type":1,"pageTitle":"JavaScript","url":"/docs/3.3.x/javascript#learning-javascript","content":"The Mozilla Developer Network Web Docs is the gold standard for programming on the web. The JavaScript page is an excellent place for further reading about JavaScript. ","version":"3.3.x","tagName":"h2"},{"title":"Interactive Tutorials​","type":1,"pageTitle":"JavaScript","url":"/docs/3.3.x/javascript#interactive-tutorials","content":"Learn JavaScript is an excellent platform for beginning to learn the JavaScript programming language. It is full of interactive tutorials and small projects. ","version":"3.3.x","tagName":"h2"},{"title":"GitHub Pages","type":0,"sectionRef":"#","url":"/docs/3.3.x/gh_pages","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Setup​","type":1,"pageTitle":"GitHub Pages","url":"/docs/3.3.x/gh_pages#setup","content":"Please follow the GitHub documentation for setting up GH Pages on your repository and make sure the publishing source for your repository is configured for gh-pages branch. ","version":"3.3.x","tagName":"h3"},{"title":"Github Discussions","type":0,"sectionRef":"#","url":"/docs/3.3.x/github_discussions","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Reporting Bugs​","type":1,"pageTitle":"Github Discussions","url":"/docs/3.3.x/github_discussions#reporting-bugs","content":"Bugs with Honeycomb should be reported directly to the issues tab of the repository. Please select &quot;Bug report&quot; and include as much information as possible. If you are able to provide a minimal example that reproduces the bug, that is even better! ","version":"3.3.x","tagName":"h2"},{"title":"Firebase","type":0,"sectionRef":"#","url":"/docs/3.3.x/firebase","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Setting up Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/3.3.x/firebase#setting-up-firebase","content":"info Members of Brown University should submit a support ticket to have their Firebase project created. Members of other institutions should check to see if their university has access to Google Cloud. Otherwise, a personal Firebase account can be created for free. Please follow the firebase documentation for creating a new project. ","version":"3.3.x","tagName":"h2"},{"title":"Adding Products​","type":1,"pageTitle":"Firebase","url":"/docs/3.3.x/firebase#adding-products","content":"First we'll configure Firebase Hosting and Cloud Firestore on your project. Log in to Firebase with your Google account on the Firebase console Navigate to your project from the console Register a new web app to your project (Register your app) note We recommend giving your web app the same name as your task's repository Add Firestore Database to your project (Create a Cloud Firestore database) note Choose production mode for the starting mode and the default &quot;Cloud Firestore Location&quot; The Firebase project is now fully set up! Now we'll connect your task to that project from your computer. ","version":"3.3.x","tagName":"h3"},{"title":"Installing the Command Line Interface​","type":1,"pageTitle":"Firebase","url":"/docs/3.3.x/firebase#installing-the-command-line-interface","content":"The Firebase CLI is installed with the node package manager just like the rest of Honeycomb's dependencies. Be sure to log in with same account you used when logging into the console! Login to Firebase firebase login  A command not found error usually indicates firebase-tools has not been installed correctly. Re-running npm install -g firebase-tools should fix this issue. ","version":"3.3.x","tagName":"h3"},{"title":"Connecting Your Firebase Project​","type":1,"pageTitle":"Firebase","url":"/docs/3.3.x/firebase#connecting-your-firebase-project","content":"Change the default project name of your task in .firebaserc .firebaserc { &quot;projects&quot;: { &quot;default&quot;: &quot;&lt;your project name&gt;&quot; } }  Copy the web app credentials from the Firebase console to the corresponding variables in .env.firebase Return to your project on the Firebase console Navigate to your project setting Scroll down and copy the auto-generated values from the Firebase console to the corresponding variables in the .env.firebase file in the env folder of your Honeycomb task repo env/.env.firebase REACT_APP_FIREBASE=&quot;true&quot; REACT_APP_apiKey= REACT_APP_authDomain= REACT_APP_projectId= REACT_APP_storageBucket= REACT_APP_messagingSenderId= REACT_APP_appId= Additional variables may be present in the console, they do not need to be copied. Deploy the default Firestore security rules Deploy Firestore rules firebase deploy --only firestore:rules  Your task is now connected to an initialized Firebase project! ","version":"3.3.x","tagName":"h3"},{"title":"Developing With Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/3.3.x/firebase#developing-with-firebase","content":"Two terminal windows must be used while developing for Firebase. See here for instructions on splitting terminals in VSCode. Run Honeycomb with Firebase Enabled npm run dev:firebase  Start the Firebase Emulators npm run firebase:emulators:start  Honeycomb is now running in the browser and connected to data on an emulated instance of Firestore. It may be viewed on localhost:4000. info Honeycomb populates the Firestore emulators with the study s1 and participant p1. ","version":"3.3.x","tagName":"h2"},{"title":"Deploying on Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/3.3.x/firebase#deploying-on-firebase","content":"Firebase deployments are handled automatically following Continuous Integration Continuous Development (CI/CD) practices using GitHub Actions. Here we will create custom actions that are connected to the task's Firebase project. Execute the following command to begin initializing Firebase hosting via GitHub actions. Be sure to follow the instructions below as the prompts appear. Initialize Firebase hosting via Github actions firebase init hosting:github  The window should log you in automatically; if not, follow the prompts to log in with the same account you used in the console&lt;username&gt;/&lt;repository name&gt; refers to the name of your repository in Github - be sure it's typed correctly!Enter y for the prompt &quot;Set up the workflow to run a build script before every deploy?&quot;Enter npm install &amp;&amp; npm run build:firebase for the prompt &quot;What script should be run before every deploy?&quot;Enter y to overwrite the current workflow fileEnter y for the prompt &quot;Set up automatic deployment to your site's live channel when a PR is merged?&quot;Enter main for the prompt &quot;What is the name of the GitHub branch associated with your site's live channel?&quot;Enter y to overwrite the current workflow file Firebase will update the files firebase-hosting-pull-request.yml and firebase-hosting-merge.yml inside the .github/workflows/ directory. Ensure the correct run script is present in both files.  ","version":"3.3.x","tagName":"h2"},{"title":"Managing Data​","type":1,"pageTitle":"Firebase","url":"/docs/3.3.x/firebase#managing-data","content":"Honeycomb ships with a CLI script for managing data in Firebase. A local service account must be created in order to use it. ","version":"3.3.x","tagName":"h2"},{"title":"Setting up a Service Account​","type":1,"pageTitle":"Firebase","url":"/docs/3.3.x/firebase#setting-up-a-service-account","content":"Service accounts are accounts that are not attached to a human user. They authorize access to a Firebase project without someone physically logging in online. We use a service account to give the download script access to the Firestore database automatically. Return to the project settings your project on the Firebase console Click on the &quot;Service accounts&quot; tab Near the bottom, click &quot;Generate new Private key&quot; and &quot;Generate Key&quot; Rename the key firebase-service-account.json and move it to the root directory of your task - be sure the file looks grayed out and is not picked up by git! danger A service account has total administrative access to ts Firebase project. The file and keys inside should never be shared and never committed to GitHub. ","version":"3.3.x","tagName":"h3"},{"title":"Using the CLI Script​","type":1,"pageTitle":"Firebase","url":"/docs/3.3.x/firebase#using-the-cli-script","content":"Script Usage npm run cli  The CLI script will guide you through the steps needed to manage your data appropriately: Whether you wish to download or delete data Entering the ID of a given study Entering the ID of a given participant on that study Selecting the sessions to download/delete info SPACE selects a single session and A toggles every session note The download script will prompt you for where the data should be saved. It defaults to ., which is your current folder. The folder must exist before running the script. ","version":"3.3.x","tagName":"h3"},{"title":"Further Reading​","type":1,"pageTitle":"Firebase","url":"/docs/3.3.x/firebase#further-reading","content":"The Firebase Documentation details its Emulator Suite in much greater detail. ","version":"3.3.x","tagName":"h2"},{"title":"Security Rules​","type":1,"pageTitle":"Firebase","url":"/docs/3.3.x/firebase#security-rules","content":"Honeycomb uses security rules to authenticate participants and studies for each task. By default participants must be registered to each study in order to complete the task. Firestore rules are defined in the firestore.rules file in the home directory. Note the highlighted lines: firestore.rules rules_version = '2'; service cloud.firestore { match /databases/{database}/documents { match /participant_responses/{studyID}/participants/{participantID} { allow create, read: if // Allows any combination of studyID and participantID to be created in Firebase true // participantID must be in the registered_participants array in the registered_studies/{studyID} document // participantID in get(/databases/$(database)/documents/registered_studies/$(studyID)).data.registered_participants; // experimentID must be in the data subcollection match /data/{experimentID} { allow create, read: if true // trialID must be in the trials subcollection match /trials/{trialID} { allow create, read: if true } } } } }  Lines 3 and 4 indicate that Honeycomb attempts to connect to a document at /databases/{database}/documents/participant_responses/{studyID}/participants/{participantID} where studyID is a given study and participantID is a given participant within that study. Line 5 indicates how Honeycomb can interact with that document. Note that Honeycomb cannot update or delete data! You must use the CLI script to delete data. Lines 6 through 10 defines our rule for creating a document for a given participant at participant_responses/{studyID}/participants/{participantID}. Honeycomb ships with two possible rules: Line 8 specifies true which allows any combination of studyID and participantID to be created in Firebase. info This is the default rule Honeycomb ships with. It is recommended to leave this rule as is and handle the registration of studies in another tool such as Prolific. Line 10 only allows a participantID to be created if the value is in an array called registered_participants inside of a document at registered_studies/{studyID}. This ensures pre-registration of every study and participant - the next section explains how to register studies. caution Firestore rules define every valid path for data in your project. Attempting to connect anywhere besides the paths in your Firestore rules will be automatically denied, even if you have manually saved data elsewhere. This is why firestore.rules contains the nested rules in lines 12 - 20. These should be left alone. Registering Studies​ Navigate to your Firestore Database in the Firebase console Click &quot;Start collection&quot; Enter registered_studies as the collection ID Enter the id of your study as the document id Click &quot;Add Field&quot;. Enter registered_participants as the field name, and set the type &quot;array&quot; Add the id of each study participant to the array as type &quot;string&quot; The study should look like this when you're finished:  Additional studies are created as documents inside the registered_studies collection ","version":"3.3.x","tagName":"h3"},{"title":"Local Application","type":0,"sectionRef":"#","url":"/docs/3.3.x/local_application","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Creating a Release​","type":1,"pageTitle":"Local Application","url":"/docs/3.3.x/local_application#creating-a-release","content":"Follow the GitHub documentation for creating a release. The tag should be in the format vX.X.X where X.X.X is the version number of the release. For example, if the release is version 1.0.0, the tag should be v1.0.0. danger Your release must included a new tag for the CI/CD workflow to work. ","version":"3.3.x","tagName":"h2"},{"title":"Installing the task​","type":1,"pageTitle":"Local Application","url":"/docs/3.3.x/local_application#installing-the-task","content":"Navigate to the repository's &quot;Releases&quot; tab and select the tag you created from aboveDownload the correct installer for your operating systemDouble click the installer to run it. Follow the instructions to install the application. ","version":"3.3.x","tagName":"h2"},{"title":"Running the Task​","type":1,"pageTitle":"Local Application","url":"/docs/3.3.x/local_application#running-the-task","content":"The task can be run by double-clicking the application icon on the desktop. The local application will run the task in a full-screen window. This aims to prevent study participants from doing anything else on the computer while the task is running. However, the task can be exited if needed with the following shortcut: WindowsmacOSLinux ⌘ + Q ","version":"3.3.x","tagName":"h2"},{"title":"Working with Data​","type":1,"pageTitle":"Local Application","url":"/docs/3.3.x/local_application#working-with-data","content":"Data is automatically saved throughout the task and moved to a nested folder structure on the Desktop when the task is completed. Note how the folders are organized by studyID and participantID. Each session is saved as its own .json file; it's name is the timestamp of start_date of the task. ","version":"3.3.x","tagName":"h2"},{"title":"Early Exits​","type":1,"pageTitle":"Local Application","url":"/docs/3.3.x/local_application#early-exits","content":"The run-through of an experiment in which the tasks exits prematurely will NOT be sent to the desktop. However, what data was collected is available in the user's &quot;userData&quot; folder which can be found in the following location: WindowsmacOSLinux ~/Library/Application Support/honeycomb/TempData  caution The .json file will likely not be formatted correctly because of the early exit. Take extra care to fix the file before using it for data analysis. ","version":"3.3.x","tagName":"h3"},{"title":"NPM Scripts","type":0,"sectionRef":"#","url":"/docs/3.3.x/npm_scripts","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Start​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.3.x/npm_scripts#start","content":"start runs the app in development mode and does NOT open a browser. This makes working with Electron easier as it creates its own browser for development.start:browser runs the app in development mode and automatically opens a new browser tab. It uses your system's default browser. The page will reload if you make edits.start:electron: Waits for the app to be running (from start) and then starts an electron process. ","version":"3.3.x","tagName":"h2"},{"title":"Dev​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.3.x/npm_scripts#dev","content":"npm run dev runs the app in development mode on Electron. It executes start and start:electron concurrently. Note that this is a base script that other scripts build on top of - you should always run one of the scripts below while developing your app. The additional scripts execute npm run dev with different environment variables. dev:home runs the app with equipment disabled.dev:home:video runs the app with equipment disabled and video enabled.dev:clinic runs the app with equipment enabled.dev:clinic:video runs the app with equipment enabled and video enabled.dev:turk-prolific runs the app with prolific and PsiTurk enabled. ","version":"3.3.x","tagName":"h2"},{"title":"Firebase Development​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.3.x/npm_scripts#firebase-development","content":"dev:firebase runs the app with Firebase enabled.firebase:emulators:start starts the Firebase emulators with the data found in emulator_data/.firebase:emulators:save saves the current state of the Firebase emulators into emulator_data/. Working with Firebase is slightly different as it is meant to be run on the browser. npm run dev:firebase executes start:browser with Firebase enabled, which will automatically launch the running app in your default browser. It can be found on other browsers by navigating to localhost:3000. dev:firebase must be run in conjunction with firebase:emulators:start to work properly. This runs the Firebase Emulators locally with some dummy data. The emulator data can be viewed at localhost:4000. caution npm run firebase:emulators:start must be run in a separate terminal window that stays during development. tip The dummy study is s1 and the dummy participant is p1. ","version":"3.3.x","tagName":"h3"},{"title":"Build​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.3.x/npm_scripts#build","content":"npm run build creates a production build of the app in the build/ folder. Note that this is a base script that other scripts build on top of - you should always run one of the scripts below while developing your app. The additional scripts execute npm run build with different environment variables. build:home builds the app with equipment disabledbuild:home:video builds the app with equipment disabled and video enabledbuild:clinic builds the app with equipment enabledbuild:clinic:video builds the app with equipment enabled and video enabledbuild:firebase builds the app with Firebase enabledbuild:turk-prolific builds the app with prolific and PsiTurk enabled ","version":"3.3.x","tagName":"h2"},{"title":"Package​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.3.x/npm_scripts#package","content":"npm run package:[platform] creates a standalone installer for the given platform using electron-forge. The installer is created in out/. Note that the scripts build the app before creating the installers npm run package:windowsnpm run package:linuxnpm run package:mac info Packaging for Windows on a non-Windows machine requires mono and wine to be installed. ","version":"3.3.x","tagName":"h2"},{"title":"Miscellaneous​","type":1,"pageTitle":"NPM Scripts","url":"/docs/3.3.x/npm_scripts#miscellaneous","content":"cli runs the Firebase CLI script.commit runs Commitizen in the console. It is useful for ensuring your Git commit messages are easy to follow.format uses Prettier to style code in a consistent format.lint uses Eslint to find problems in the code.postinstall is run automatically after npm install and is used to rebuild the Electron dependenciesprepare is run automatically before the project is packaged/installed and is used to set up the project's pre-commit hooksprebuild is run automatically before npm run build and is used to rebuild the Electron dependencies ","version":"3.3.x","tagName":"h2"},{"title":"Prerequisites","type":0,"sectionRef":"#","url":"/docs/3.3.x/prerequisites","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"OS Independent​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#os-independent","content":"","version":"3.3.x","tagName":"h2"},{"title":"Git​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#git","content":"git is an open-sourced version control system. It is used to track changes, revert mistakes, and enable peer code reviews! GitHub Desktop is a GUI application used to interact with git and GitHub directly from your computer. It is not strictly needed but many folks find it easier to work with than using git directly from the command line. ","version":"3.3.x","tagName":"h3"},{"title":"Node Version Manager​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#node-version-manager","content":"NodeJS is a cross-platform runtime environment for JavaScript code. Almost every web application today builds on top of node. Node Version Manager manages running multiple versions of node on the same system. The .nvmrc denotes the version of node that Honeycomb uses. ","version":"3.3.x","tagName":"h3"},{"title":"Python​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#python","content":"Python is a high-level programming language. Some &quot;under the hood&quot; tools needed by Honeycomb are written in python so it must be installed on your system. danger Honeycomb cannot use Python version 3.12 or newer. The installers will install version 3.11. ","version":"3.3.x","tagName":"h3"},{"title":"Oracle JDk​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#oracle-jdk","content":"Java is another high-level programming language that some tools are written in (namely, the Firebase Emulators). We must install a JDK (Java Development Kit) for it to run. note Honeycomb needs Java version 11 or later to run - the installers use version 18. ","version":"3.3.x","tagName":"h3"},{"title":"Visual Studio Code​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#visual-studio-code","content":"Visual Studio Code is a well-loved and easy to use integrated development environment (IDE). This is the program you'll use to write your task. ","version":"3.3.x","tagName":"h3"},{"title":"Mac-specific Installs​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#mac-specific-installs","content":"","version":"3.3.x","tagName":"h2"},{"title":"X-Code​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#x-code","content":"XCode is a special IDE for the Apple platform. It comes with everything needed to compile desktop applications from an Apple computer. It must be installed from the terminal: Installing XCode xcode-select --install  ","version":"3.3.x","tagName":"h3"},{"title":"Rosetta​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#rosetta","content":"Rosetta is a translation layer built for Mac computers with Apple Silicon. It should ask to be installed if any of the prerequisite tools need it. Otherwise, this guide can be used to make sure it is on your Apple Silicon system. ","version":"3.3.x","tagName":"h3"},{"title":"Windows-specific Install​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#windows-specific-install","content":"","version":"3.3.x","tagName":"h2"},{"title":"Visual Studio​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#visual-studio","content":"Visual Studio is a special IDE for the Windows platform. It comes with everything needed to compile desktop applications from a PC. Visual Studio Community is free to use. caution The &quot;Desktop development with C++&quot; workload must also be installed with Visual Studio. The automated installers should preselect this but you should double check to be certain! ","version":"3.3.x","tagName":"h3"},{"title":"Manual Installation​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#manual-installation","content":"","version":"3.3.x","tagName":"h2"},{"title":"macOS​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#macos","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. GitGitHub DesktopNVMPythonOracle JDKVS CodeXcode ","version":"3.3.x","tagName":"h3"},{"title":"Windows​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#windows","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. GitGitHub DesktopNVMPythonOracle JDKVS CodeVisual Studio: Visual Studio 2022 CommunityInstall the Native C++ Workflow ","version":"3.3.x","tagName":"h3"},{"title":"Linux​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#linux","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. Your preferred installation method for the programs listed above should get you up and running on any Linux distro new enough to support GLIBC_2.28. GitGitHub DesktopNVMPythonOracle JDKVS CodeInstall Clang or follow installation instructions on the electron docsDevelopment headers of GTK 3 and libnotify (Follow installation instructions on the electron docs) ","version":"3.3.x","tagName":"h3"},{"title":"Further Help​","type":1,"pageTitle":"Prerequisites","url":"/docs/3.3.x/prerequisites#further-help","content":"If you are still having issues setting up your computer you can find the full instructions on the electron documentation for your specific OS. ","version":"3.3.x","tagName":"h2"},{"title":"Prolific","type":0,"sectionRef":"#","url":"/docs/3.3.x/prolific","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Prolific Setup​","type":1,"pageTitle":"Prolific","url":"/docs/3.3.x/prolific#prolific-setup","content":"caution Prolific integration is only available in Honeycomb for tasks deployed to Firebase. Please follow the discussion post Configure participant and study ID in prolific to configure a Prolific study that integrates with Honeycomb. The &quot;Prolific ID&quot; should be set to participantIDThe &quot;Study ID&quot; should be set to studyIDThe &quot;Session ID&quot; should be set to SESSION_ID ","version":"3.3.x","tagName":"h2"},{"title":"Further Reading​","type":1,"pageTitle":"Prolific","url":"/docs/3.3.x/prolific#further-reading","content":"The jsPsych Documentation also provides a guide for Prolific integration. Please note that this documentation will differ slightly from the Honeycomb integration. ","version":"3.3.x","tagName":"h2"},{"title":"PsiTurk","type":0,"sectionRef":"#","url":"/docs/3.3.x/psiturk","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Prebuilt version​","type":1,"pageTitle":"PsiTurk","url":"/docs/3.3.x/psiturk#prebuilt-version","content":"When a GitHub Action is run, a PsiTurk build will be created automatically, and can be downloaded from its artifacts. The workflows responsible for building the PsiTurk application are .github/workflows/package.yml and .github/workflows/release.yml. The first one has to be triggered manually, the latter is triggered when you tag a release. If this is all you need, the build instructions below can be skipped! ","version":"3.3.x","tagName":"h3"},{"title":"Build instructions​","type":1,"pageTitle":"PsiTurk","url":"/docs/3.3.x/psiturk#build-instructions","content":"To set up your PsiTurk project, we provide a script that does the conversion. PsiTurk is a Python package used to manage HITs in Mechanical Turk. Before using the provided script, install PsiTurk. You'll need to follow these steps (the path to the PsiTurk project should be a directory you wish to be created): Build the application: npm run build Move to the psiturkit directory: cd psiturkit If it's the first time you're running the script: ./psiturk-it -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt; To update an existing PsiTurk project (the path to the PsiTurk project should already exist from the previous steps): ./psiturk-it -U -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt;  ","version":"3.3.x","tagName":"h3"},{"title":"Running PsiTurk​","type":1,"pageTitle":"PsiTurk","url":"/docs/3.3.x/psiturk#running-psiturk","content":"After that, just navigate to your newly created PsiTurk project directory. shell&gt; psiturk # start psiturk psiturk&gt; server on # start server psiturk&gt; debug # enter debug mode  ","version":"3.3.x","tagName":"h3"},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"/docs/3.3.x/troubleshooting","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Inspecting Errors​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.3.x/troubleshooting#inspecting-errors","content":"When running any of the npm run dev commands you may encounter errors. These may display over the window itself or may may exist in the developer tools. These tools can be accessed by right clicking the window and selecting &quot;Inspect&quot; or by pressing Ctrl+Shift+I (Cmd+Option+I on Mac). The errors, as well as any console.logs, will be displayed in the &quot;Console&quot; tab of the developer tools. When developing Electron apps there are two processes: main, and renderer. In this case, main corresponds to public/electron/main.js and its console is in the terminal where npm run devwas run. renderer corresponds to the React App - this is everything else. This console can be found using the same steps as above - note that running npm run dev should open the developer console by default. ","version":"3.3.x","tagName":"h2"},{"title":"Common issues​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.3.x/troubleshooting#common-issues","content":"","version":"3.3.x","tagName":"h2"},{"title":"Installing Dependencies​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.3.x/troubleshooting#installing-dependencies","content":"Brew Not Available​ If you run into issues installing Homebrew in step 1 of Installing Prerequisites it may be because Homebrew is not available on your shell. Older versions of macOS (under 10.14) do not do this automatically. Run the following command to manually add the Homebrew installation location to your PATH so it is available in your shell. echo 'PATH=&quot;/usr/local/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile  note If you're using zsh, also add to your ~/.zshrc file. ","version":"3.3.x","tagName":"h3"},{"title":"NPM Errors​","type":1,"pageTitle":"Troubleshooting","url":"/docs/3.3.x/troubleshooting#npm-errors","content":"Most npm issues can be resolved by re-installing dependencies. This can be done by running the following commands in the root directory of the project: Delete the node_modules/ folderDelete hte package-lock.json fileReinstall dependencies npm install  ","version":"3.3.x","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Flexible deployment online and in the lab​","type":1,"pageTitle":"Introduction","url":"/docs/#flexible-deployment-online-and-in-the-lab","content":"Honeycomb provides the ability to write one codebase and use it flexibly across settings (with guaranteed consistency in instructions, timing, etc.). The same code-base is used to maintain and deploy the identical task on Mechanical Turk, Prolific, and in research settings during concurrent electrophysiological recordings. ","version":"3.4.x","tagName":"h3"},{"title":"Easy-to-install executables​","type":1,"pageTitle":"Introduction","url":"/docs/#easy-to-install-executables","content":"Deployment specifications are abstracted as parameters that are easy to configure, and application building is automated via GitHub actions providing continuous delivery of easy-to-download executables, easing setup burden across research sites. ","version":"3.4.x","tagName":"h3"},{"title":"Foundation in jsPsych​","type":1,"pageTitle":"Introduction","url":"/docs/#foundation-in-jspsych","content":"Honeycomb is built on top of jsPsych, a JavaScript library for running behavioral experiments in a web browser. jsPsych7 tasks can be moved directly into Honeycomb to take advantage of the flexible deployment and automated GitHub Actions workflow that Honeycomb provides. ","version":"3.4.x","tagName":"h3"},{"title":"Community Driven​","type":1,"pageTitle":"Introduction","url":"/docs/#community-driven","content":"Honeycomb additionally provides a Behavioral Task Hub at our Beehive website. These tasks are built in Honeycomb and are ready to be deployed. ","version":"3.4.x","tagName":"h3"},{"title":"Cite this work​","type":1,"pageTitle":"Introduction","url":"/docs/#cite-this-work","content":"If you use Honeycomb in your work, please cite Provenza, N.R., Gelin, L.F.F., Mahaphanit, W., McGrath, M.C., Dastin-van Rijn, E.M., Fan, Y., Dhar, R., Frank, M.J., Restrepo, M.I., Goodman, W.K. and Borton, D.A., 2021. Honeycomb: a template for reproducible psychophysiological tasks for clinic, laboratory, and home use. Brazilian Journal of Psychiatry, 44, pp.147-155. ","version":"3.4.x","tagName":"h3"},{"title":"Variants","type":0,"sectionRef":"#","url":"/docs/3.3.x/variants","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Variant-specific Executables​","type":1,"pageTitle":"Variants","url":"/docs/3.3.x/variants#variant-specific-executables","content":"In order to create multiple variants of a task that can be co-installed, it is necessary to add new scripts to the package.json file in addition to creating the necessary environment variables for configuration. Each variant must have a unique, lowercase name. Optionally, a unique icon can be used for each variant by saving multiple icons to the icons directories with the same names as the variants. Example scripts for Windows, Mac, and Linux are shown below. Windows: &quot;package:windows:&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform win32 --arch x64 --icon ./assets/icons/win/&lt;task_name&gt; --out dist/ --overwrite --asar&quot;  &quot;postpackage:windows:&lt;task_name&gt;&quot;: &quot;electron-installer-windows --src dist/&lt;task_name&gt;-win32-x64/ --dest dist/installers/ --overwrite --homepage https://ccv.brown.edu/ --name &lt;task_name&gt; --exe &lt;task_name&gt;.exe --productName &lt;task_name&gt;&quot;  Mac: &quot;package:mac:,&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform darwin --arch x64 --out dist/ --icon ./assets/icons/mac/&lt;task_name&gt;.icns --overwrite&quot;  &quot;installer:mac:&lt;task_name&gt;&quot;: &quot;electron-installer-dmg ./dist/&lt;task_name&gt;-darwin-x64/&lt;task_name&gt;.app &lt;task_name&gt;-${npm_package_version} --out ./dist/installers/ --icon ./assets/icons/mac/&lt;task_name&gt;.icns --overwrite&quot;  Linux: &quot;package:linux:&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform linux --arch x64 --icon ./assets/icons/mac/&lt;task_name&gt; --out dist/ --overwrite&quot;  &quot;postpackage:linux:&lt;task_name&gt;&quot;: &quot;electron-installer-debian --src dist/&lt;task_name&gt;-linux-x64/ --dest dist/installers/ --arch x64 --overwrite --name &lt;task_name&gt; --productName &lt;task_name&gt; --genericName &lt;task_name&gt; --bin &lt;task_name&gt;&quot;  ","version":"3.3.x","tagName":"h2"},{"title":"Variant-specific Workflows​","type":1,"pageTitle":"Variants","url":"/docs/3.3.x/variants#variant-specific-workflows","content":"In order to use Github workflows to build and upload executables for each variant, the build.yaml, package.yaml, and release.yaml files must be modified as well. For all three files, a new row should be added to the matrix variable as follows: variant: [&lt;comma_separated_list_of_variant_names&gt;]  Add the following before npm build in the steps section of build.yaml, package.yaml, and release.yaml: - name: Load .env file for variant uses: xom9ikk/dotenv@v1.0.2 with: path: ./env mode: ${{matrix.variant}}  In package.yaml and release.yaml, replace the # Build electron app package installers section with the following code: - name: package electron - windows if: startsWith(matrix.os, 'windows') run: npm run package:windows:${{ matrix.variant }} - name: package electron - linux if: startsWith(matrix.os, 'ubuntu') run: npm run package:linux:${{ matrix.variant }} - name: package electron - mac if: startsWith(matrix.os, 'mac') run: npm run package:mac:${{ matrix.variant }} - name: npm rebuild - mac if: startsWith(matrix.os, 'mac') run: npm rebuild - name: Mac installer if: startsWith(matrix.os, 'mac') run: npm run installer:mac:${{ matrix.variant }}  Replace the # Upload installers to github action section in package.yaml with the following code: - name: upload win-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'windows') with: name: ${{ format('win-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-setup.exe - name: upload mac-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'mac') with: name: ${{ format('mac-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}.dmg - name: upload linux-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'ubuntu') with: name: ${{ format('linux-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_x64.deb  Replace the # Upload installers to github release section in release.yaml with the following code: - name: Upload app to release - windows if: startsWith(matrix.os, 'windows') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-setup.exe asset_name: ${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-${{ matrix.setting }}-setup.exe tag: ${{ github.ref }} - name: Upload app to release - linux if: startsWith(matrix.os, 'ubuntu') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_x64.deb asset_name: ${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_${{ matrix.setting }}_x64.deb tag: ${{ github.ref }} - name: Upload app to release - mac if: startsWith(matrix.os, 'mac') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}.dmg asset_name: ${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-${{ matrix.setting }}.dmg tag: ${{ github.ref }}  ","version":"3.3.x","tagName":"h2"},{"title":"Version Control","type":0,"sectionRef":"#","url":"/docs/3.3.x/version_control","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Git Overview​","type":1,"pageTitle":"Version Control","url":"/docs/3.3.x/version_control#git-overview","content":"Git is a version control system that enables you to track changes to files. With Git, you are able to revert files back to previous versions, restore deleted files, remove added files and even track down where a particular line of code was introduced. Nearly all operations that are performed by Git are in your local computing environment, with the exception of a few used to synchronize with the GitHub remote host. Some of the most common git operations are depicted below.  If you would like to make any changes to current repository, it is always good to start with creating a feature branch, where you can save all the changes.  ","version":"3.3.x","tagName":"h2"},{"title":"Create a Pull Request​","type":1,"pageTitle":"Version Control","url":"/docs/3.3.x/version_control#create-a-pull-request","content":"Pull requests are useful before you merge your branch with the main branch. You can request a review from your colleagues and check for any conflicts with the main branch. After you pushed all the changes to your branch, you can go to the original GitHub repository and click on the pull request.   ","version":"3.3.x","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Version Control","url":"/docs/3.3.x/version_control#best-practices","content":"","version":"3.3.x","tagName":"h2"},{"title":"Git Branches​","type":1,"pageTitle":"Version Control","url":"/docs/3.3.x/version_control#git-branches","content":"main is the default branch and where releases are made from. This branch should be in clean/working conditions at all times. This branch is protected and can only be merged from Pull Requests for topic branches. topic branches are created for new features, fixes, or really any changes. E.g, fix-task-trial2-stuck-button. Note how the branch name describes the changes. This flow is sometimes referred to as Feature Branch Workflow ","version":"3.3.x","tagName":"h3"},{"title":"Basic Workflow​","type":1,"pageTitle":"Version Control","url":"/docs/3.3.x/version_control#basic-workflow","content":"We recommend using a simple flow based on following rules: Use topic/feature branches, no direct commits on mainPerform tests and code reviews before merges into main, not afterwardsEvery branch starts from main, and targets mainCommit messages reflect intent ","version":"3.3.x","tagName":"h3"},{"title":"Comment styles​","type":1,"pageTitle":"Version Control","url":"/docs/3.3.x/version_control#comment-styles","content":"We encourage using Commitizen, a great tool for recording descriptions of commits in a standardized format which makes it easier for people to understand what changed in the code. ","version":"3.3.x","tagName":"h3"},{"title":"Git Commands​","type":1,"pageTitle":"Version Control","url":"/docs/3.3.x/version_control#git-commands","content":"Command\tBriefgit add &lt;files&gt;\tadd a file to next commit (stage) git commit -m &lt;message&gt;\tcommit staged files git push\tupload staged commit to repo git pull\tget remote repo commits and download (try and resolve conflicts) git clone &lt;url&gt;\tdownload entire repository git checkout -b &lt;branch&gt;\tcreate and checkout a new branch git checkout &lt;branch&gt;\tcheckout the branch you want to use # create branch with your feature git checkout -b feature_name # check the status of your repositoey git status # commit file contents to the local repository git commit -m &quot;My feature is ready&quot; # specific message # push file contents to the remote (i.e. cloud) repository git push origin feature_name  ","version":"3.3.x","tagName":"h2"},{"title":"GUI Based Source Control​","type":1,"pageTitle":"Version Control","url":"/docs/3.3.x/version_control#gui-based-source-control","content":"VS Code is the default IDE installed by Honeycomb. Check out this overview of source control in VS Code!GitHub Desktop is a GUI application built specifically for working with Git. It is one of the programs installed as a prerequisite of Honeycomb. Check out this overview of source control in GitHub Desktop! ","version":"3.3.x","tagName":"h2"},{"title":"Stay up-to-date with Honeycomb template repo​","type":1,"pageTitle":"Version Control","url":"/docs/3.3.x/version_control#stay-up-to-date-with-honeycomb-template-repo","content":"Honeycomb is an active project, and will be updated with new features over time. To bring changes from the Honeycomb template repository to your task: Add Honeycomb as an additional remote as follows: git remote add honeycomb https://github.com/brown-ccv/honeycomb.git Fetch the changes made to Honeycomb git fetch --all Merge the current Honeycomb repo git merge honeycomb/main --allow-unrelated histories  caution There will almost certainly be many &quot;merge conflicts&quot; when merging in changes from the template repository. It is tedious, but extremely import, to not accidentally overwrite your task when resolving these conflicts. ","version":"3.3.x","tagName":"h2"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/docs/3.3.x/quick_start","content":"","keywords":"javascript  jspsych","version":"3.3.x"},{"title":"Creating Your Task Repository​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#creating-your-task-repository","content":"The Honeycomb repository is a template and serves as the starting point for all tasks. Creating your repository from the template starts your project with the same directory structure and files as an existing repository. Go to the Honeycomb repository Click on Use this template and select Create a new repository. Enter the owner, name, and description of your repository and click on Create repository from template. note We recommend creating a public repository and leaving Include all branches unchecked Ensure the repository's workflow permissions are set to &quot;Read and write permissions&quot; Settings -&gt; Actions -&gt; General -&gt; Workflow permissions Additional details about template repositories can be found on the Github Docs. ","version":"3.3.x","tagName":"h2"},{"title":"Cloning the Repository​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#cloning-the-repository","content":"With the repository now setup it can be cloned onto your computer. Navigate to the repository on GitHub. Click the Code button and copy the URL Open a terminal and navigate to where you want the cloned directory WindowsmacOS Terminal.app cd 'path/to/directory'  Clone the repo with the following command Paste the URL you copied earlier git clone https://github.com/&lt;YOUR-USERNAME&gt;/&lt;YOUR-REPOSITORY&gt;  note Git can be downloaded here if it is not already on your system. Additional details and alternative methods for cloning a repository can be found on the Github Docs. ","version":"3.3.x","tagName":"h2"},{"title":"Installing Prerequisites​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#installing-prerequisites","content":"All of the needed programs for Honeycomb must be installed before we can develop our task. We will use a package manager to automatically install them. See Prerequisites for more information about these programs. ","version":"3.3.x","tagName":"h2"},{"title":"Initial Install​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#initial-install","content":"WindowsmacOS The most commonly used package manager on macOS is Homebrew. Paste the following command in a macOS Terminal and follow the prompts to install Homebrew. /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; Paste the following command and follow the prompts to install the listed programs: brew bundle Install Xcode (not available on Homebrew) xcode-select --install  note If you are running into issues after installing the packages, please restart your terminal and/or reboot your computer. This should resolve most issues. ","version":"3.3.x","tagName":"h3"},{"title":"Setting Up Node​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#setting-up-node","content":"NVM (Node Version Manager) is a tool for installing and using multiple versions on Node on your computer. It must first be installed: Install NVM WindowsmacOS curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash Copy the version number listed in .nvmrc. Install that version. nvm install &lt;VERSION&gt; Use the needed version. nvm use &lt;VERSION&gt; Set the current version as your default nvm alias default node note You can skip this step if you've already set a default node version in a different project. ","version":"3.3.x","tagName":"h3"},{"title":"Install Dependencies​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#install-dependencies","content":"There are many Node packages used by Honeycomb that also need to be installed. Node comes with its own package manager to install, update, and maintain these dependencies throughout the development lifecycle. Install Honeycomb's dependencies npm install  Certain Node dependencies are best installed globally. These tools will be available from the command line anywhere on your system. Install Honeycomb's global dependencies npm install -g electron firebase-tools dotenv-cli electron lint-staged  ","version":"3.3.x","tagName":"h2"},{"title":"Run the Task​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#run-the-task","content":"Run the task in development mode npm run dev  Running the task in development mode enables &quot;hot reloading&quot;: changes to the code will immediately be reflected in the app without needing to restart the server. tip The dev script runs Honeycomb on Electron without any environment variables. Check out the NPM Scripts page for more information on the available development environments. note Honeycomb ships with a modified version of the &quot;simple reaction time task&quot; from the jsPsych tutorial. In the next section we'll create a new task and tell Honeycomb to run it! ","version":"3.3.x","tagName":"h2"},{"title":"Edit the Task​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#edit-the-task","content":"Now that the project is up and running we can make our first changes to the code! info The quick start guide details a command line workflow for version control. If you are unfamiliar with Git, we recommend reading the linked page before proceeding. ","version":"3.3.x","tagName":"h2"},{"title":"1) Edit the Project Metadata​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#1-edit-the-project-metadata","content":"Create a new branch in a separate terminal Create the branch edit-package-json git checkout -b edit-package-json Open package.json and edit it to reflect your app: name is your task's name, generally this is the name of our repositorydescription should be rewritten to better match your taskauthor is your lab (or PIs) name, email, and websitehoneycombVersion is the number currently in the version fieldversion should then be reset to 1.0.0repository is the link the GitHub repository you created earlier. package.json { &quot;name&quot;: &quot;my-task&quot;, &quot;description&quot;: &quot;A custom task for the Honeycomb platform&quot;, &quot;author&quot;: { &quot;name&quot;: &quot;My Lab&quot;, &quot;email&quot;: &quot;example@domain.com&quot;, &quot;url&quot;: &quot;https://lab-web-page.com&quot; }, &quot;honeycombVersion&quot;: &quot;3.3.0&quot;, // Match what was in version! &quot;version&quot;: &quot;3.3.0&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;repository&quot;: &quot;https://github.com/my-username/my-repository&quot; }, Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;edit package.json with my task's information&quot; Create and merge a pull request to merge your changes into the main branch. Make sure the builds complete successfully before merging! ","version":"3.3.x","tagName":"h3"},{"title":"2) Add a file for the task​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#2-add-a-file-for-the-task","content":"Bring your branch up to date with the main branch Switch to the main branch git checkout main Bring changes from GitHub into your local repository git pull Create a new branch (replace task-name with the name of your task) Check out a new branch git checkout -b add-&lt;task-name&gt;-file Add a new file inside src/experiment/ with the same name as your task Save your changes and commit them to git: Add the new file to Git git add . Commit all changed files with a custom message git commit -a -m &quot;feat: adds file for the &lt;task name&gt; task&quot; Add a taskNameOptions object to the new file (replace taskName with the name of your task) taskName.js /** * Experiment-wide settings for jsPsych: https://www.jspsych.org/7.3/overview/experiment-options/ * Note that Honeycomb combines these with other options required for Honeycomb to operate correctly */ export const taskNameOptions = { // Called when every trial finishes on_trial_finish: function (data) { console.log(`Trial ${data.internal_node_id} just finished:`, data); }, // Called when the experiment finishes on_finish: function (data) { console.log(&quot;The experiment has finished:&quot;, data); // Reload the page for another run-through of the experiment window.location.reload(); }, }; Add a buildTaskNameFunction to the new file (replace TaskName with the name of your task) taskName.js /** * This timeline builds the example reaction time task from the jsPsych tutorial. * Take a look at how the code here compares to the jsPsych documentation! * See the jsPsych documentation for more: https://www.jspsych.org/7.3/tutorials/rt-task/ * * @param {Object} jsPsych The jsPsych instance being used to run the task * @returns {Object} A jsPsych timeline object */ export function buildTaskNameTimeline(jsPsych) {} Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;feat: adds taskNameOptions and buildTaskNameTimeline to taskName.js&quot; Edit src/experiment/index.js to use the new file src/experiment/index.js import { buildHoneycombTimeline, honeycombOptions } from &quot;./honeycomb&quot;; import { buildTaskNameTimeline, taskNameOptions } from &quot;./taskName&quot;; // ... export const jsPsychOptions = honeycombOptions; export const jsPsychOptions = taskNameOptions; // ... export function buildTimeline(jsPsych, studyID, participantID) { console.log(`Building timeline for participant ${participantID} on study ${studyID}`); const timeline = buildHoneycombTimeline(jsPsych); const timeline = buildTaskNameTimeline(jsPsych); return timeline; } Run the format script to make sure the code is formatted correctly npm run format Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;fix: Use new task's file&quot; Create and merge a pull request to merge your changes into the main branch. Make sure the builds complete successfully before merging! ","version":"3.3.x","tagName":"h3"},{"title":"3) Add some trials to the task​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#3-add-some-trials-to-the-task","content":"Bring your branch up to date with the main branch Switch to the main branch git checkout main Bring changes from GitHub into your local repository git pull Create a new branch Bring changes from GitHub into your local repository git checkout -b add-start-procedure Add the start procedure to the buildTaskNameTimeline function in the file you created earlier taskName.js import { buildStartProcedure } from &quot;./procedures/startProcedure&quot;; // ... export function buildTaskNameTimeline(jsPsych) { // Build the trials that make up the start procedure const startProcedure = buildStartProcedure(jsPsych); const timeline = [startProcedure]; return timeline; } // ... Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;feat: adds startProcedure to the task&quot; Edit the text for the task's name src/config/language.json { &quot;name&quot;: &quot;taskName&quot; // ... } tip The text for the introduction trial is in src/config/language.json under the trials and introduction key. src/config/language.json { &quot;name&quot;: &quot;taskName&quot; // ... &quot;trials&quot;: { &quot;introduction&quot;: &quot;Welcome to the experiment. Press any key to begin.&quot; // ... }, // ... } Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;feat: Updates the language for the startProcedure of the task&quot; Add the end procedure to the buildTaskNameTimeline function in the file you created earlier taskName.js import { buildStartProcedure } from &quot;./procedures/startProcedure&quot;; import { buildEndProcedure } from &quot;./procedures/endProcedure&quot;; // ... export function buildTaskNameTimeline(jsPsych) { // Build the trials that make up the start procedure const startProcedure = buildStartProcedure(jsPsych); // Builds the trials that make up the end procedure const endProcedure = buildEndProcedure(jsPsych); const timeline = [startProcedure, endProcedure]; return timeline; } // ... tip The text for the conclusion trial is in src/config/language.json under the trials and conclusion key. src/config/language.json { &quot;name&quot;: &quot;taskName&quot; // ... &quot;trials&quot;: { // ... &quot;conclusion&quot;: &quot;Welcome to the experiment. Press any key to begin.&quot; }, } Run a format to make sure the code is formatted correctly npm run format Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;feat: adds endProcedure to the task&quot; Create and merge a pull request to merge your changes into the main branch. Make sure the builds complete successfully before merging! ","version":"3.3.x","tagName":"h3"},{"title":"Next Steps​","type":1,"pageTitle":"Quick Start","url":"/docs/3.3.x/quick_start#next-steps","content":"The Firebase page explains how to set up your task with Firebase.The Environment Variables page explains how to configure your task for deployment to multiple scenarios.The NPM Scripts page lists every script you can run and which environment they use. ","version":"3.3.x","tagName":"h2"},{"title":"Continuous Integration / Deployment","type":0,"sectionRef":"#","url":"/docs/ci_cd","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"What are Github Actions​","type":1,"pageTitle":"Continuous Integration / Deployment","url":"/docs/ci_cd#what-are-github-actions","content":"GitHub Actions automate tasks within the development life cycle of your software. GitHub Actions consist of a series of commands that run after a specified event has occurred. For example, every time someone creates a pull request for a repository, you can automatically run a command to build and test your software. You can learn more about the events that trigger workflows in GitHub's documentation GitHub Actions are written as YML files inside the .github/workflows/ folder of your repository. ","version":"3.4.x","tagName":"h2"},{"title":"Honeycomb's CI/CD Workflows​","type":1,"pageTitle":"Continuous Integration / Deployment","url":"/docs/ci_cd#honeycombs-cicd-workflows","content":"Honeycomb includes workflows to build and create installers for Windows, Mac and Linux, as well as for deploying to Firebase. These workflows exist for two configurations of the tasks: Home: The app does not expect event code triggers and photodiode spots.Clinic: The app expects event code triggers and photodiode spots. tip Event code triggers and photodiode spots can only be used on local applications! They will not appear when Honeycomb is deployed on the web. pull_request.yaml: Every time a Pull Request (PR) is created the software is built and tests are run for all platforms with home and clinic settings. This workflow does not upload desktop installers. release.yml: Every time a release is created, edited, or published installers for the Honeycomb app are created and uploaded to the release. This also builds a PsiTurk version and deploys the app to GitHub pages. workflow-package.yaml: Create installers for any/all platforms for the home and/or clinic setting on demand. The installers/executables are uploaded as artifacts and are available for download from the GitHub Actions tab. This also builds a PsiTurk version when linux or all operating systems are selected. note On-demand workflows are triggered manually from the GitHub Actions tab. Each GitHub organization/individual has a quota on storage in private repositories. Uploading artifacts counts against your quota. You may consider configuring your workflows to only upload what you need. You can learn more about GitHub's storage limits in their official documentation. workflow-delete-artifacts.yaml: On-demand workflow for deleting artifacts form your GitHub repository. This can be useful when the package.yaml workflow is run multiple times and you want to delete the artifacts from previous runs. ","version":"3.4.x","tagName":"h2"},{"title":"Firebase​","type":1,"pageTitle":"Continuous Integration / Deployment","url":"/docs/ci_cd#firebase","content":"firebase-hosting-merge.yaml: Deploys the web version of the application to Firebase when a PR is merged into the main branch.firebase-hosting-pull-request.yaml: Creates a preview version of the application with Firebase when a PR is opened. danger While this workflow uses a preview link it does use the production database. Ensure you use a test study to not conflict with your participant data. note These workflows may be safely deleted if you are not planning to ever use Firebase. ","version":"3.4.x","tagName":"h3"},{"title":"Directory Structure","type":0,"sectionRef":"#","url":"/docs/directory_structure","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"assets/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#assets","content":"This folder contains static files that are used by the application. Honeycomb uses a few images as icons for the installed applications. caution Assets that pertain to your specific task should be added to the public/assets/ folder, not here! ","version":"3.4.x","tagName":"h2"},{"title":"build/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#build","content":"The build scripts automatically create a build folder at the root of the repository and update it on subsequent builds. caution build/ should be left alone! It is in Honeycomb's .gitignore and should never be added to git. ","version":"3.4.x","tagName":"h2"},{"title":"emulator_data/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#emulator_data","content":"This folder contains starter data for the Firebase Emulators to use while developing locally. The Firebase Scripts detail how to use this data. caution emulator_data/ is written to when running npm run firebase:emulators:save and should never be edited. ","version":"3.4.x","tagName":"h2"},{"title":"env/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#env","content":"This folder contains different files used to pass environment variables (settings) into Honeycomb. Honeycomb starts with presets for common use cases and is explained in greater detail in the Environment Variables section. ","version":"3.4.x","tagName":"h2"},{"title":"node_modules/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#node_modules","content":"caution node_modules/ is written to when running npm install and should never be edited. It is in Honeycomb's .gitignore and should never be added to git. ","version":"3.4.x","tagName":"h2"},{"title":"psiturkit/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#psiturkit","content":"The file psiturk-it inside psiturkit/ is a bash script used to instal PsiTurk locally - see PsiTurk for more information. caution This folder involves a Honeycomb deployment. The files do not need to be edited. ","version":"3.4.x","tagName":"h2"},{"title":"public/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#public","content":"The public directory contains files that are used as assets in the built app. index.html is the entry point of the website Changing &lt;title&gt;Honeycomb&lt;/title&gt; will update the text in the browser tab! favicon.ico is the small (16x16px) icon you can see in the browser tabmanifest.json contains metadata about the web app caution manifest.json involves project metadata and does not need to be edited. ","version":"3.4.x","tagName":"h2"},{"title":"assets/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#assets-1","content":"The public/assets/ directory contains all of the audio, images, and videos needed to run your task. ","version":"3.4.x","tagName":"h3"},{"title":"electron/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#electron","content":"The public/electron/ directory contains the files needed to run Honeycomb as an Electron app. main.js sets up Electron itselfpreload.js sets up the communication between the main and renderer processes. caution This folder involves a Honeycomb deployment, the files do not need to be edited. ","version":"3.4.x","tagName":"h3"},{"title":"lib/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#lib","content":"The public/lib/ directory contains the files PsiTurk needs to run. Note that index.html references these files inside the &lt;script&gt; tags. caution This folder involves dependencies for a Honeycomb deployment, the files should not be edited. ","version":"3.4.x","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#src","content":"This folder contains the source code for the Honeycomb application. index.js is the entry point for React in our application. Note that the id 'root' corresponds with a tag in public/index.html: &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; caution index.js runs Honeycomb itself and should not be edited. ","version":"3.4.x","tagName":"h2"},{"title":"App/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#app","content":"Files relating to the React application. caution This folder holds the code that runs the jsPsych task, the files do not need to be edited. components/​ The React components that make up Honeycomb are located here. App.jsx initializes and maintains the state of the application.Error.jsx displays a small error message. It is rendered when the App.jsx detects an issue in state.JsPsychExperiment.jsx initializes the jsPsych experiment.Login.jsx handles user authentication based on the environment variables passed to Honeycomb. deployments/​ Custom code used by the various deployments such as Firebase. caution This folder involves Honeycomb deployments, the files do not need to be edited. ","version":"3.4.x","tagName":"h3"},{"title":"config/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#config","content":"Each file in the config directory contains settings for a different part of the task. language.json contains the language used in your task. This file allows for easy internationalization of the task (e.g. English and Spanish) and mturk-specific language. Common phrases can be written once and re-used throughout the task. main.js contains the global settings (e.g., whether Honeycomb is running online or in the clinic) passed from env variables and logic for loading the appropriate files. settings.json contains the settings for your task. Usage of the config file allows for easy updating of task settings. Common settings can be written once and re-used throughout the task. trigger.js contains equipment-related settings for a trigger box. The eventCodes are especially important for marking the types of given trials. ","version":"3.4.x","tagName":"h3"},{"title":"experiment/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#experiment","content":"tip This is where you'll spend most of your time while developing your task! index.js contains the outermost logic for running the experiment. It loads experiment's styling and exports the main timeline and options for the experiment. caution The experiment will not run correctly if the names jsPsychOptions or buildTimeline are changed. honeycomb.js contains the options and timeline for the jsPsych tutorial's &quot;Simple React Time Task&quot;. It serves as an example for the experiment timeline for your task. tip This is just an example experiment! Be sure to write your experiment in its own file. {/ TODO: Link to this in the quick_start guide once it's ready /} procedures/​ A procedure is a tested timeline of trials in jsPsych. Common parameters can be used across trials, and the trials within a procedure can be ordered and repeated as desired. Check out the JsPsych documentation for more information on creating a custom procedure. startProcedure.js contains the procedure for the start of the experiment. It uses the environment and task settings from config.json to create a nested timeline that correctly starts the experiment.honeycombProcedure.js contains the procedure for the Honeycomb task. It displays a fixation dot and presents the stimulus of the example task. tip This is just an example procedure! Be sure to write your procedures in their own files. endProcedure.js contains the procedure for the end of the experiment. It uses the environment and task settings from config.json to create a nested timeline that correctly end the experiment. trials/​ A trial is the base unit of an experiment. These trials are ordered into procedures and timelines to create the task itself. adjustVolume.js prompts the user to adjust the volume on their tablet. camera.js contains trials for beginning and ending a camera recording. conclusion.js displays a message to the user indicating that the experiment has concluded. fixation.js displays a fixation dot in the center of the screen. It contains additional logic for flashing a photodiode spot and emitting an event code based on the environment settings. fullscreen.js contains trials for entering and exiting fullscreen mode. holdUpMarker.js prompts the user to connect their event marker and hold it up to the camera. honeycombTrials.js contains the individual trials used in the Honeycomb task. These trials are imported into experiment/procedures/honeycombProcedure.js and experiment/honeycomb.js. tip These trials are for the example experiment! Be sure to write trials pertaining to your task in their own file(s). introduction.js displays a message to the user welcoming them to the experiment. They must click on a button to continue. name.js displays the name of the task to the user. startCode.js emits a start code to a photodiode spot and audible beep. survey.js contains trials pertaining to a survey/quiz for the user to complete. ","version":"3.4.x","tagName":"h3"},{"title":"lib/​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#lib-1","content":"A library of utility and markup functions are located here. This allows for functions and html to be re-used wherever needed. utils.js contains utility functions that can be used across a variety of trials. Be sure to look for functions you might be able to use in your task! markup/​ Markup files contain HTML templates used throughout the task. photodiode.js contains the markup for the photodiode box and spot displayed in the bottom right corner of the screentags.js contains functions for wrapping language in common html tags. You should always wrap your language in a tag to ensure it is displayed correctly. For example: p('Hello World') will return &lt;p&gt;Hello World&lt;/p&gt;. tip The tag function inside tags.js can be used to wrap language in any html tag you need. ","version":"3.4.x","tagName":"h3"},{"title":"Other Folders/Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#other-foldersfiles","content":".nvmrc determines which version of node that Honeycomb is designed to be run on. .github/workflows/ contains .yaml files used for CI/CD with GitHub Actions. package.json contains metadata about your project, a list of the dependencies needed for the project, and scripts to run tasks related to your task. The Quick Start lists which metadata should be changed. cli.mjs is the script used to download and delete data stored in Firestore. version.js is the script used to keep track of which version of the task a given experiment is using. caution cli.mjs and version.js are automated scripts and should not be edited. package-lock.json is written to when running npm install and should never be edited. ","version":"3.4.x","tagName":"h2"},{"title":"Firebase Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#firebase-files","content":".firebaserc contains the name of the project Firebase should connect to. Be sure to update the default project to the one you created!firebase.json contains the Firebase settings for Honeycomb.firestore.indexes.json contains the Firestore index settings for Honeycomb.firestore.rules contains the Firestore rules for creating/editing data. caution firebase.json and firestore.indexes.json are default configs and shouldn't need to be edited. ","version":"3.4.x","tagName":"h3"},{"title":"Git Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#git-files","content":".gitignore lists the folders and files that should be excluded from Git. caution Any secrets and/or tokens must be added to .gitignore or they will be visible to anyone with access to the repository! ","version":"3.4.x","tagName":"h3"},{"title":"Eslint Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#eslint-files","content":".eslintrc.js contains the Eslint settings for Honeycomb. We recommend it's left alone but can be adjusted for personal preference..eslintignore lists the folders and files that eslint shouldn't touch, similar to .gitignore. ","version":"3.4.x","tagName":"h3"},{"title":"Prettier Files​","type":1,"pageTitle":"Directory Structure","url":"/docs/directory_structure#prettier-files","content":".prettierrc.js contains the Prettier settings for Honeycomb. We recommend it's left alone but can be adjusted for personal preference. ","version":"3.4.x","tagName":"h3"},{"title":"Environment Variables","type":0,"sectionRef":"#","url":"/docs/environment_variables","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Understanding the Environment Variables​","type":1,"pageTitle":"Environment Variables","url":"/docs/environment_variables#understanding-the-environment-variables","content":"","version":"3.4.x","tagName":"h2"},{"title":"Run-time​","type":1,"pageTitle":"Environment Variables","url":"/docs/environment_variables#run-time","content":"The badge indicates the variable is set/determined each time the executable is run. Run-time environment variables allow for quick changes when running the task. They are convenient since they don't require building a whole different executable. Desktop deployments must set these environment variables at the system level. See this tutorial for OS specific instructions.. Online deployments must use Firebase, and store the runtime environment variables in Firestore. ","version":"3.4.x","tagName":"h3"},{"title":"Build-time​","type":1,"pageTitle":"Environment Variables","url":"/docs/environment_variables#build-time","content":"The badge indicates the variable is set during the build phase (npm run build) and cannot be changed at run-time. These variables are configured via .env files in the env folder. The dotenv-cli comes with the dotenv command that can be used to properly load the needed variables. We write our npm scripts with the following format: package.json &quot;[build|dev]:&lt;env name&gt;&quot;: &quot;dotenv -e env/&lt;env name&gt; npm run [build|dev]&quot;  See NPM Scripts for more ","version":"3.4.x","tagName":"h3"},{"title":"Event Triggers","type":0,"sectionRef":"#","url":"/docs/event_triggers","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"BrainVision Trigger Box setup​","type":1,"pageTitle":"Event Triggers","url":"/docs/event_triggers#brainvision-trigger-box-setup","content":"Follow the TriggerBox setup instructions in the BrainVision Trigger Box manual. Plug the TriggerBox into the computer running the task. Check your operating system’s device list to identify the COM port that the TriggerBox is connected to. Create a new system environment variable: COMNAME  and set the COM port to the correct value (e.g., COM3). ","version":"3.4.x","tagName":"h2"},{"title":"Open Source Event Trigger setup​","type":1,"pageTitle":"Event Triggers","url":"/docs/event_triggers#open-source-event-trigger-setup","content":"Details on how to make the open source event trigger and photodiode can be found here. Connect the open source event trigger to the computer running the task using a USB to micro-USB cable. Check your operating system’s USB device list to identify the product ID of the teensyduino event marker. Create a new system environment variable: EVENT_MARKER_PRODUCT_ID and set to the product ID of the event marker. ","version":"3.4.x","tagName":"h2"},{"title":"Send event code triggers​","type":1,"pageTitle":"Event Triggers","url":"/docs/event_triggers#send-event-code-triggers","content":"Change the eventCodes values listed in the src/config/trigger.js file to the desired values. Import eventCodes from ./trigger and export as eventCodes. Whenever you would like to send an event code in a trial, load eventCodes from ../config/main/, and call pdSpotEncode with the proper code (e.g. eventCode.Fixation) as input. ","version":"3.4.x","tagName":"h2"},{"title":"Run the task with event triggers​","type":1,"pageTitle":"Event Triggers","url":"/docs/event_triggers#run-the-task-with-event-triggers","content":"Honeycomb automatically checks whether your event marker is connected and running at the start of the task. If it is not connected, the task will present an error and will not be able to run. ","version":"3.4.x","tagName":"h2"},{"title":"GitHub Pages","type":0,"sectionRef":"#","url":"/docs/gh_pages","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Setup​","type":1,"pageTitle":"GitHub Pages","url":"/docs/gh_pages#setup","content":"Please follow the GitHub documentation for setting up GH Pages on your repository and make sure the publishing source for your repository is configured for gh-pages branch. ","version":"3.4.x","tagName":"h3"},{"title":"Github Discussions","type":0,"sectionRef":"#","url":"/docs/github_discussions","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Reporting Bugs​","type":1,"pageTitle":"Github Discussions","url":"/docs/github_discussions#reporting-bugs","content":"Bugs with Honeycomb should be reported directly to the issues tab of the repository. Please select &quot;Bug report&quot; and include as much information as possible. If you are able to provide a minimal example that reproduces the bug, that is even better! ","version":"3.4.x","tagName":"h2"},{"title":"JavaScript","type":0,"sectionRef":"#","url":"/docs/javascript","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Learning JavaScript​","type":1,"pageTitle":"JavaScript","url":"/docs/javascript#learning-javascript","content":"The Mozilla Developer Network Web Docs is the gold standard for programming on the web. The JavaScript page is an excellent place for further reading about JavaScript. ","version":"3.4.x","tagName":"h2"},{"title":"Interactive Tutorials​","type":1,"pageTitle":"JavaScript","url":"/docs/javascript#interactive-tutorials","content":"Learn JavaScript is an excellent platform for beginning to learn the JavaScript programming language. It is full of interactive tutorials and small projects. ","version":"3.4.x","tagName":"h2"},{"title":"Local Application","type":0,"sectionRef":"#","url":"/docs/local_application","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Creating a Release​","type":1,"pageTitle":"Local Application","url":"/docs/local_application#creating-a-release","content":"Follow the GitHub documentation for creating a release. The tag should be in the format vX.X.X where X.X.X is the version number of the release. For example, if the release is version 1.0.0, the tag should be v1.0.0. danger Your release must included a new tag for the CI/CD workflow to work. ","version":"3.4.x","tagName":"h2"},{"title":"Installing the task​","type":1,"pageTitle":"Local Application","url":"/docs/local_application#installing-the-task","content":"Navigate to the repository's &quot;Releases&quot; tab and select the tag you created from aboveDownload the correct installer for your operating systemDouble click the installer to run it. Follow the instructions to install the application. ","version":"3.4.x","tagName":"h2"},{"title":"Running the Task​","type":1,"pageTitle":"Local Application","url":"/docs/local_application#running-the-task","content":"The task can be run by double-clicking the application icon on the desktop. The local application will run the task in a full-screen window. This aims to prevent study participants from doing anything else on the computer while the task is running. However, the task can be exited if needed with the following shortcut: WindowsmacOSLinux ⌘ + Q ","version":"3.4.x","tagName":"h2"},{"title":"Working with Data​","type":1,"pageTitle":"Local Application","url":"/docs/local_application#working-with-data","content":"Data is automatically saved throughout the task and moved to a nested folder structure on the Desktop when the task is completed. Note how the folders are organized by studyID and participantID. Each session is saved as its own .json file; it's name is the timestamp of start_date of the task. ","version":"3.4.x","tagName":"h2"},{"title":"Early Exits​","type":1,"pageTitle":"Local Application","url":"/docs/local_application#early-exits","content":"The run-through of an experiment in which the tasks exits prematurely will NOT be sent to the desktop. However, what data was collected is available in the user's &quot;userData&quot; folder which can be found in the following location: WindowsmacOSLinux ~/Library/Application Support/honeycomb/TempData  caution The .json file will likely not be formatted correctly because of the early exit. Take extra care to fix the file before using it for data analysis. ","version":"3.4.x","tagName":"h3"},{"title":"Firebase","type":0,"sectionRef":"#","url":"/docs/firebase","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Setting up Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/firebase#setting-up-firebase","content":"info Members of Brown University should submit a support ticket to have their Firebase project created. Members of other institutions should check to see if their university has access to Google Cloud. Otherwise, a personal Firebase account can be created for free. Please follow the firebase documentation for creating a new project. ","version":"3.4.x","tagName":"h2"},{"title":"Adding Products​","type":1,"pageTitle":"Firebase","url":"/docs/firebase#adding-products","content":"First we'll configure Firebase Hosting and Cloud Firestore on your project. Log in to Firebase with your Google account on the Firebase console Navigate to your project from the console Register a new web app to your project (Register your app) note We recommend giving your web app the same name as your task's repository Add Firestore Database to your project (Create a Cloud Firestore database) note Choose production mode for the starting mode and the default &quot;Cloud Firestore Location&quot; The Firebase project is now fully set up! Now we'll connect your task to that project from your computer. ","version":"3.4.x","tagName":"h3"},{"title":"Installing the Command Line Interface​","type":1,"pageTitle":"Firebase","url":"/docs/firebase#installing-the-command-line-interface","content":"The Firebase CLI is installed with the node package manager just like the rest of Honeycomb's dependencies. Be sure to log in with same account you used when logging into the console! Login to Firebase firebase login  A command not found error usually indicates firebase-tools has not been installed correctly. Re-running npm install -g firebase-tools should fix this issue. ","version":"3.4.x","tagName":"h3"},{"title":"Connecting Your Firebase Project​","type":1,"pageTitle":"Firebase","url":"/docs/firebase#connecting-your-firebase-project","content":"Change the default project name of your task in .firebaserc .firebaserc { &quot;projects&quot;: { &quot;default&quot;: &quot;&lt;your project name&gt;&quot; } }  Copy the web app credentials from the Firebase console to the corresponding variables in .env.firebase Return to your project on the Firebase console Navigate to your project setting Scroll down and copy the auto-generated values from the Firebase console to the corresponding variables in the .env.firebase file in the env folder of your Honeycomb task repo env/.env.firebase REACT_APP_FIREBASE=&quot;true&quot; REACT_APP_API_KEY= REACT_APP_AUTH_DOMAIN= REACT_APP_PROJECT_ID= REACT_APP_STORAGE_BUCKET= REACT_APP_MESSAGING_SENDER_ID= REACT_APP_APP_ID= Additional variables may be present in the console, they do not need to be copied. Deploy the default Firestore security rules Deploy Firestore rules firebase deploy --only firestore:rules  Your task is now connected to an initialized Firebase project! ","version":"3.4.x","tagName":"h3"},{"title":"Developing With Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/firebase#developing-with-firebase","content":"Two terminal windows must be used while developing for Firebase. See here for instructions on splitting terminals in VSCode. Run Honeycomb with Firebase Enabled npm run dev:firebase  Start the Firebase Emulators npm run firebase:emulators:start  Honeycomb is now running in the browser and connected to data on an emulated instance of Firestore. It may be viewed on localhost:4000. info Honeycomb populates the Firestore emulators with the study s1 and participant p1. ","version":"3.4.x","tagName":"h2"},{"title":"Deploying on Firebase​","type":1,"pageTitle":"Firebase","url":"/docs/firebase#deploying-on-firebase","content":"Firebase deployments are handled automatically following Continuous Integration Continuous Development (CI/CD) practices using GitHub Actions. Here we will create custom actions that are connected to the task's Firebase project. Execute the following command to begin initializing Firebase hosting via GitHub actions. Be sure to follow the instructions below as the prompts appear. Initialize Firebase hosting via Github actions firebase init hosting:github  The window should log you in automatically; if not, follow the prompts to log in with the same account you used in the console&lt;username&gt;/&lt;repository name&gt; refers to the name of your repository in Github - be sure it's typed correctly!Enter y for the prompt &quot;Set up the workflow to run a build script before every deploy?&quot;Enter npm ci &amp;&amp; npm run build:firebase for the prompt &quot;What script should be run before every deploy?&quot;Enter y to overwrite the current workflow fileEnter y for the prompt &quot;Set up automatic deployment to your site's live channel when a PR is merged?&quot;Enter main for the prompt &quot;What is the name of the GitHub branch associated with your site's live channel?&quot;Enter y to overwrite the current workflow file info Firebase will update the files firebase-hosting-pull-request.yml and firebase-hosting-merge.yml inside the .github/workflows/ directory. Please ensure the &quot;run&quot; step is npm ci &amp;&amp; npm run build:firebase in both files! ","version":"3.4.x","tagName":"h2"},{"title":"Managing Data​","type":1,"pageTitle":"Firebase","url":"/docs/firebase#managing-data","content":"Honeycomb ships with a CLI script for managing data in Firebase. A local service account must be created in order to use it. ","version":"3.4.x","tagName":"h2"},{"title":"Setting up a Service Account​","type":1,"pageTitle":"Firebase","url":"/docs/firebase#setting-up-a-service-account","content":"Service accounts are accounts that are not attached to a human user. They authorize access to a Firebase project without someone physically logging in online. We use a service account to give the download script access to the Firestore database automatically. Return to the project settings your project on the Firebase console Click on the &quot;Service accounts&quot; tab Near the bottom, click &quot;Generate new Private key&quot; and &quot;Generate Key&quot; Rename the key firebase-service-account.json and move it to the root directory of your task - be sure the file looks grayed out and is not picked up by git! danger A service account has total administrative access to ts Firebase project. The file and keys inside should never be shared and never committed to GitHub. ","version":"3.4.x","tagName":"h3"},{"title":"Using the CLI Script​","type":1,"pageTitle":"Firebase","url":"/docs/firebase#using-the-cli-script","content":"Script Usage npm run cli  The CLI script will guide you through the steps needed to manage your data appropriately: Whether you wish to download or delete data Entering the ID of a given study Entering the ID of a given participant on that study Selecting the sessions to download/delete info SPACE selects a single session and A toggles every session note The download script will prompt you for where the data should be saved. It defaults to ., which is your current folder. The folder must exist before running the script. ","version":"3.4.x","tagName":"h3"},{"title":"Further Reading​","type":1,"pageTitle":"Firebase","url":"/docs/firebase#further-reading","content":"The Firebase Documentation details its Emulator Suite in much greater detail. ","version":"3.4.x","tagName":"h2"},{"title":"Security Rules​","type":1,"pageTitle":"Firebase","url":"/docs/firebase#security-rules","content":"Honeycomb uses security rules to authenticate participants and studies for each task. By default participants must be registered to each study in order to complete the task. Firestore rules are defined in the firestore.rules file in the home directory. Note the highlighted lines: firestore.rules rules_version = '2'; service cloud.firestore { match /databases/{database}/documents { match /participant_responses/{studyID}/participants/{participantID} { allow create, read: if // Allows any combination of studyID and participantID to be created in Firebase true // participantID must be in the registered_participants array in the registered_studies/{studyID} document // participantID in get(/databases/$(database)/documents/registered_studies/$(studyID)).data.registered_participants; // experimentID must be in the data subcollection match /data/{experimentID} { allow create, read: if true // trialID must be in the trials subcollection match /trials/{trialID} { allow create, read: if true } } } } }  Lines 3 and 4 indicate that Honeycomb attempts to connect to a document at /databases/{database}/documents/participant_responses/{studyID}/participants/{participantID} where studyID is a given study and participantID is a given participant within that study. Line 5 indicates how Honeycomb can interact with that document. Note that Honeycomb cannot update or delete data! You must use the CLI script to delete data. Lines 6 through 10 defines our rule for creating a document for a given participant at participant_responses/{studyID}/participants/{participantID}. Honeycomb ships with two possible rules: Line 8 specifies true which allows any combination of studyID and participantID to be created in Firebase. info This is the default rule Honeycomb ships with. It is recommended to leave this rule as is and handle the registration of studies in another tool such as Prolific. Line 10 only allows a participantID to be created if the value is in an array called registered_participants inside of a document at registered_studies/{studyID}. This ensures pre-registration of every study and participant - the next section explains how to register studies. caution Firestore rules define every valid path for data in your project. Attempting to connect anywhere besides the paths in your Firestore rules will be automatically denied, even if you have manually saved data elsewhere. This is why firestore.rules contains the nested rules in lines 12 - 20. These should be left alone. Registering Studies​ Navigate to your Firestore Database in the Firebase console Click &quot;Start collection&quot; Enter registered_studies as the collection ID Enter the id of your study as the document id Click &quot;Add Field&quot;. Enter registered_participants as the field name, and set the type &quot;array&quot; Add the id of each study participant to the array as type &quot;string&quot; The study should look like this when you're finished:  Additional studies are created as documents inside the registered_studies collection ","version":"3.4.x","tagName":"h3"},{"title":"Prolific","type":0,"sectionRef":"#","url":"/docs/prolific","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Prolific Setup​","type":1,"pageTitle":"Prolific","url":"/docs/prolific#prolific-setup","content":"caution Prolific integration is only available in Honeycomb for tasks deployed to Firebase. Please follow the discussion post Configure participant and study ID in prolific to configure a Prolific study that integrates with Honeycomb. The &quot;Prolific ID&quot; should be set to participantIDThe &quot;Study ID&quot; should be set to studyIDThe &quot;Session ID&quot; should be set to SESSION_ID ","version":"3.4.x","tagName":"h2"},{"title":"Further Reading​","type":1,"pageTitle":"Prolific","url":"/docs/prolific#further-reading","content":"The jsPsych Documentation also provides a guide for Prolific integration. Please note that this documentation will differ slightly from the Honeycomb integration. ","version":"3.4.x","tagName":"h2"},{"title":"NPM Scripts","type":0,"sectionRef":"#","url":"/docs/npm_scripts","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Start​","type":1,"pageTitle":"NPM Scripts","url":"/docs/npm_scripts#start","content":"start runs the app in development mode and does NOT open a browser. This makes working with Electron easier as it creates its own browser for development.start:browser runs the app in development mode and automatically opens a new browser tab. It uses your system's default browser. The page will reload if you make edits.start:electron: Waits for the app to be running (from start) and then starts an electron process. ","version":"3.4.x","tagName":"h2"},{"title":"Dev​","type":1,"pageTitle":"NPM Scripts","url":"/docs/npm_scripts#dev","content":"npm run dev runs the app in development mode on Electron. It executes start and start:electron concurrently. Note that this is a base script that other scripts build on top of - you should always run one of the scripts below while developing your app. The additional scripts execute npm run dev with different environment variables. dev:home runs the app with equipment disabled.dev:home:video runs the app with equipment disabled and video enabled.dev:clinic runs the app with equipment enabled.dev:clinic:video runs the app with equipment enabled and video enabled.dev:turk-prolific runs the app with prolific and PsiTurk enabled. ","version":"3.4.x","tagName":"h2"},{"title":"Firebase Development​","type":1,"pageTitle":"NPM Scripts","url":"/docs/npm_scripts#firebase-development","content":"dev:firebase runs the app with Firebase enabled.firebase:emulators:start starts the Firebase emulators with the data found in emulator_data/.firebase:emulators:save saves the current state of the Firebase emulators into emulator_data/. Working with Firebase is slightly different as it is meant to be run on the browser. npm run dev:firebase executes start:browser with Firebase enabled, which will automatically launch the running app in your default browser. It can be found on other browsers by navigating to localhost:3000. dev:firebase must be run in conjunction with firebase:emulators:start to work properly. This runs the Firebase Emulators locally with some dummy data. The emulator data can be viewed at localhost:4000. caution npm run firebase:emulators:start must be run in a separate terminal window that stays during development. tip The dummy study is s1 and the dummy participant is p1. ","version":"3.4.x","tagName":"h3"},{"title":"Build​","type":1,"pageTitle":"NPM Scripts","url":"/docs/npm_scripts#build","content":"npm run build creates a production build of the app in the build/ folder. Note that this is a base script that other scripts build on top of - you should always run one of the scripts below while developing your app. The additional scripts execute npm run build with different environment variables. build:home builds the app with equipment disabledbuild:home:video builds the app with equipment disabled and video enabledbuild:clinic builds the app with equipment enabledbuild:clinic:video builds the app with equipment enabled and video enabledbuild:firebase builds the app with Firebase enabledbuild:turk-prolific builds the app with prolific and PsiTurk enabled ","version":"3.4.x","tagName":"h2"},{"title":"Package​","type":1,"pageTitle":"NPM Scripts","url":"/docs/npm_scripts#package","content":"npm run package:[platform] creates a standalone installer for the given platform using electron-forge. The installer is created in out/. Note that the scripts build the app before creating the installers npm run package:windowsnpm run package:linuxnpm run package:mac info Packaging for Windows on a non-Windows machine requires mono and wine to be installed. ","version":"3.4.x","tagName":"h2"},{"title":"Miscellaneous​","type":1,"pageTitle":"NPM Scripts","url":"/docs/npm_scripts#miscellaneous","content":"cli runs the Firebase CLI script.commit runs Commitizen in the console. It is useful for ensuring your Git commit messages are easy to follow.format uses Prettier to style code in a consistent format.lint uses Eslint to find problems in the code.postinstall is run automatically after npm install and is used to rebuild the Electron dependenciesprepare is run automatically before the project is packaged/installed and is used to set up the project's pre-commit hooksprebuild is run automatically before npm run build and is used to rebuild the Electron dependencies ","version":"3.4.x","tagName":"h2"},{"title":"Prerequisites","type":0,"sectionRef":"#","url":"/docs/prerequisites","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"OS Independent​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#os-independent","content":"","version":"3.4.x","tagName":"h2"},{"title":"Git​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#git","content":"git is an open-sourced version control system. It is used to track changes, revert mistakes, and enable peer code reviews! GitHub Desktop is a GUI application used to interact with git and GitHub directly from your computer. It is not strictly needed but many folks find it easier to work with than using git directly from the command line. ","version":"3.4.x","tagName":"h3"},{"title":"Node Version Manager​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#node-version-manager","content":"NodeJS is a cross-platform runtime environment for JavaScript code. Almost every web application today builds on top of node. Node Version Manager manages running multiple versions of node on the same system. The .nvmrc denotes the version of node that Honeycomb uses. ","version":"3.4.x","tagName":"h3"},{"title":"Python​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#python","content":"Python is a high-level programming language. Some &quot;under the hood&quot; tools needed by Honeycomb are written in python so it must be installed on your system. ","version":"3.4.x","tagName":"h3"},{"title":"Oracle JDk​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#oracle-jdk","content":"Java is another high-level programming language that some tools are written in (namely, the Firebase Emulators). We must install a JDK (Java Development Kit) for it to run. note Honeycomb needs Java version 11 or later to run - the installers use version 18. ","version":"3.4.x","tagName":"h3"},{"title":"Visual Studio Code​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#visual-studio-code","content":"Visual Studio Code is a well-loved and easy to use integrated development environment (IDE). This is the program you'll use to write your task. ","version":"3.4.x","tagName":"h3"},{"title":"Mac-specific Installs​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#mac-specific-installs","content":"","version":"3.4.x","tagName":"h2"},{"title":"X-Code​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#x-code","content":"XCode is a special IDE for the Apple platform. It comes with everything needed to compile desktop applications from an Apple computer. It must be installed from the terminal: Installing XCode xcode-select --install  ","version":"3.4.x","tagName":"h3"},{"title":"Rosetta​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#rosetta","content":"Rosetta is a translation layer built for Mac computers with Apple Silicon. It should ask to be installed if any of the prerequisite tools need it. Otherwise, this guide can be used to make sure it is on your Apple Silicon system. ","version":"3.4.x","tagName":"h3"},{"title":"Manual Installation​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#manual-installation","content":"","version":"3.4.x","tagName":"h2"},{"title":"macOS​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#macos","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. GitGitHub DesktopNVMPythonOracle JDKVS CodeXcode ","version":"3.4.x","tagName":"h3"},{"title":"Windows​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#windows","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. GitGitHub DesktopNVMPythonOracle JDKVS Code ","version":"3.4.x","tagName":"h3"},{"title":"Linux​","type":1,"pageTitle":"Prerequisites","url":"/docs/prerequisites#linux","content":"The links below will take you to each project installation page should you prefer to manually install the prerequisite software. Your preferred installation method for the programs listed above should get you up and running on any Linux distro new enough to support GLIBC_2.28. GitGitHub DesktopNVMPythonOracle JDKVS CodeInstall Clang or follow installation instructions on the electron docsDevelopment headers of GTK 3 and libnotify (Follow installation instructions on the electron docs) ","version":"3.4.x","tagName":"h3"},{"title":"PsiTurk","type":0,"sectionRef":"#","url":"/docs/psiturk","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Prebuilt version​","type":1,"pageTitle":"PsiTurk","url":"/docs/psiturk#prebuilt-version","content":"When a GitHub Action is run, a PsiTurk build will be created automatically, and can be downloaded from its artifacts. The workflows responsible for building the PsiTurk application are .github/workflows/package.yml and .github/workflows/release.yml. The first one has to be triggered manually, the latter is triggered when you tag a release. If this is all you need, the build instructions below can be skipped! ","version":"3.4.x","tagName":"h3"},{"title":"Build instructions​","type":1,"pageTitle":"PsiTurk","url":"/docs/psiturk#build-instructions","content":"To set up your PsiTurk project, we provide a script that does the conversion. PsiTurk is a Python package used to manage HITs in Mechanical Turk. Before using the provided script, install PsiTurk. You'll need to follow these steps (the path to the PsiTurk project should be a directory you wish to be created): Build the application: npm run build Move to the psiturkit directory: cd psiturkit If it's the first time you're running the script: ./psiturk-it -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt; To update an existing PsiTurk project (the path to the PsiTurk project should already exist from the previous steps): ./psiturk-it -U -p &lt;PATH_TO_NEW_PSITURK_PROJECT&gt;  ","version":"3.4.x","tagName":"h3"},{"title":"Running PsiTurk​","type":1,"pageTitle":"PsiTurk","url":"/docs/psiturk#running-psiturk","content":"After that, just navigate to your newly created PsiTurk project directory. shell&gt; psiturk # start psiturk psiturk&gt; server on # start server psiturk&gt; debug # enter debug mode  ","version":"3.4.x","tagName":"h3"},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"/docs/troubleshooting","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Inspecting Errors​","type":1,"pageTitle":"Troubleshooting","url":"/docs/troubleshooting#inspecting-errors","content":"When running any of the npm run dev commands you may encounter errors. These may display over the window itself or may may exist in the developer tools. These tools can be accessed by right clicking the window and selecting &quot;Inspect&quot; or by pressing Ctrl+Shift+I (Cmd+Option+I on Mac). The errors, as well as any console.logs, will be displayed in the &quot;Console&quot; tab of the developer tools. When developing Electron apps there are two processes: main, and renderer. In this case, main corresponds to public/electron/main.js and its console is in the terminal where npm run devwas run. renderer corresponds to the React App - this is everything else. This console can be found using the same steps as above - note that running npm run dev should open the developer console by default. ","version":"3.4.x","tagName":"h2"},{"title":"Common issues​","type":1,"pageTitle":"Troubleshooting","url":"/docs/troubleshooting#common-issues","content":"","version":"3.4.x","tagName":"h2"},{"title":"Installing Dependencies​","type":1,"pageTitle":"Troubleshooting","url":"/docs/troubleshooting#installing-dependencies","content":"Brew Not Available​ If you run into issues installing Homebrew in step 1 of Installing Prerequisites it may be because Homebrew is not available on your shell. Older versions of macOS (under 10.14) do not do this automatically. Run the following command to manually add the Homebrew installation location to your PATH so it is available in your shell. echo 'PATH=&quot;/usr/local/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile  note If you're using zsh, also add to your ~/.zshrc file. ","version":"3.4.x","tagName":"h3"},{"title":"NPM Errors​","type":1,"pageTitle":"Troubleshooting","url":"/docs/troubleshooting#npm-errors","content":"Most npm issues can be resolved by re-installing dependencies. This can be done by running the following commands in the root directory of the project: Delete the node_modules/ folderDelete hte package-lock.json fileReinstall dependencies npm install  ","version":"3.4.x","tagName":"h3"},{"title":"Version Control","type":0,"sectionRef":"#","url":"/docs/version_control","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Git Overview​","type":1,"pageTitle":"Version Control","url":"/docs/version_control#git-overview","content":"Git is a version control system that enables you to track changes to files. With Git, you are able to revert files back to previous versions, restore deleted files, remove added files and even track down where a particular line of code was introduced. Nearly all operations that are performed by Git are in your local computing environment, with the exception of a few used to synchronize with the GitHub remote host. Some of the most common git operations are depicted below.  If you would like to make any changes to current repository, it is always good to start with creating a feature branch, where you can save all the changes.  ","version":"3.4.x","tagName":"h2"},{"title":"Create a Pull Request​","type":1,"pageTitle":"Version Control","url":"/docs/version_control#create-a-pull-request","content":"Pull requests are useful before you merge your branch with the main branch. You can request a review from your colleagues and check for any conflicts with the main branch. After you pushed all the changes to your branch, you can go to the original GitHub repository and click on the pull request.   ","version":"3.4.x","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Version Control","url":"/docs/version_control#best-practices","content":"","version":"3.4.x","tagName":"h2"},{"title":"Git Branches​","type":1,"pageTitle":"Version Control","url":"/docs/version_control#git-branches","content":"main is the default branch and where releases are made from. This branch should be in clean/working conditions at all times. This branch is protected and can only be merged from Pull Requests for topic branches. topic branches are created for new features, fixes, or really any changes. E.g, fix-task-trial2-stuck-button. Note how the branch name describes the changes. This flow is sometimes referred to as Feature Branch Workflow ","version":"3.4.x","tagName":"h3"},{"title":"Basic Workflow​","type":1,"pageTitle":"Version Control","url":"/docs/version_control#basic-workflow","content":"We recommend using a simple flow based on following rules: Use topic/feature branches, no direct commits on mainPerform tests and code reviews before merges into main, not afterwardsEvery branch starts from main, and targets mainCommit messages reflect intent ","version":"3.4.x","tagName":"h3"},{"title":"Comment styles​","type":1,"pageTitle":"Version Control","url":"/docs/version_control#comment-styles","content":"We encourage using Commitizen, a great tool for recording descriptions of commits in a standardized format which makes it easier for people to understand what changed in the code. ","version":"3.4.x","tagName":"h3"},{"title":"Git Commands​","type":1,"pageTitle":"Version Control","url":"/docs/version_control#git-commands","content":"Command\tBriefgit add &lt;files&gt;\tadd a file to next commit (stage) git commit -m &lt;message&gt;\tcommit staged files git push\tupload staged commit to repo git pull\tget remote repo commits and download (try and resolve conflicts) git clone &lt;url&gt;\tdownload entire repository git checkout -b &lt;branch&gt;\tcreate and checkout a new branch git checkout &lt;branch&gt;\tcheckout the branch you want to use # create branch with your feature git checkout -b feature_name # check the status of your repositoey git status # commit file contents to the local repository git commit -m &quot;My feature is ready&quot; # specific message # push file contents to the remote (i.e. cloud) repository git push origin feature_name  ","version":"3.4.x","tagName":"h2"},{"title":"GUI Based Source Control​","type":1,"pageTitle":"Version Control","url":"/docs/version_control#gui-based-source-control","content":"VS Code is the default IDE installed by Honeycomb. Check out this overview of source control in VS Code!GitHub Desktop is a GUI application built specifically for working with Git. It is one of the programs installed as a prerequisite of Honeycomb. Check out this overview of source control in GitHub Desktop! ","version":"3.4.x","tagName":"h2"},{"title":"Stay up-to-date with Honeycomb template repo​","type":1,"pageTitle":"Version Control","url":"/docs/version_control#stay-up-to-date-with-honeycomb-template-repo","content":"Honeycomb is an active project, and will be updated with new features over time. To bring changes from the Honeycomb template repository to your task: Add Honeycomb as an additional remote as follows: git remote add honeycomb https://github.com/brown-ccv/honeycomb.git Fetch the changes made to Honeycomb git fetch --all Merge the current Honeycomb repo git merge honeycomb/main --allow-unrelated-histories  caution There will almost certainly be many &quot;merge conflicts&quot; when merging in changes from the template repository. It is tedious, but extremely import, to not accidentally overwrite your task when resolving these conflicts. ","version":"3.4.x","tagName":"h2"},{"title":"Variants","type":0,"sectionRef":"#","url":"/docs/variants","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Variant-specific Executables​","type":1,"pageTitle":"Variants","url":"/docs/variants#variant-specific-executables","content":"In order to create multiple variants of a task that can be co-installed, it is necessary to add new scripts to the package.json file in addition to creating the necessary environment variables for configuration. Each variant must have a unique, lowercase name. Optionally, a unique icon can be used for each variant by saving multiple icons to the icons directories with the same names as the variants. Example scripts for Windows, Mac, and Linux are shown below. Windows: &quot;package:windows:&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform win32 --arch x64 --icon ./assets/icons/win/&lt;task_name&gt; --out dist/ --overwrite --asar&quot;  &quot;postpackage:windows:&lt;task_name&gt;&quot;: &quot;electron-installer-windows --src dist/&lt;task_name&gt;-win32-x64/ --dest dist/installers/ --overwrite --homepage https://ccv.brown.edu/ --name &lt;task_name&gt; --exe &lt;task_name&gt;.exe --productName &lt;task_name&gt;&quot;  Mac: &quot;package:mac:,&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform darwin --arch x64 --out dist/ --icon ./assets/icons/mac/&lt;task_name&gt;.icns --overwrite&quot;  &quot;installer:mac:&lt;task_name&gt;&quot;: &quot;electron-installer-dmg ./dist/&lt;task_name&gt;-darwin-x64/&lt;task_name&gt;.app &lt;task_name&gt;-${npm_package_version} --out ./dist/installers/ --icon ./assets/icons/mac/&lt;task_name&gt;.icns --overwrite&quot;  Linux: &quot;package:linux:&lt;task_name&gt;&quot;: &quot;electron-packager . &lt;task_name&gt; --platform linux --arch x64 --icon ./assets/icons/mac/&lt;task_name&gt; --out dist/ --overwrite&quot;  &quot;postpackage:linux:&lt;task_name&gt;&quot;: &quot;electron-installer-debian --src dist/&lt;task_name&gt;-linux-x64/ --dest dist/installers/ --arch x64 --overwrite --name &lt;task_name&gt; --productName &lt;task_name&gt; --genericName &lt;task_name&gt; --bin &lt;task_name&gt;&quot;  ","version":"3.4.x","tagName":"h2"},{"title":"Variant-specific Workflows​","type":1,"pageTitle":"Variants","url":"/docs/variants#variant-specific-workflows","content":"In order to use Github workflows to build and upload executables for each variant, the build.yaml, package.yaml, and release.yaml files must be modified as well. For all three files, a new row should be added to the matrix variable as follows: variant: [&lt;comma_separated_list_of_variant_names&gt;]  Add the following before npm build in the steps section of build.yaml, package.yaml, and release.yaml: - name: Load .env file for variant uses: xom9ikk/dotenv@v1.0.2 with: path: ./env mode: ${{matrix.variant}}  In package.yaml and release.yaml, replace the # Build electron app package installers section with the following code: - name: package electron - windows if: startsWith(matrix.os, 'windows') run: npm run package:windows:${{ matrix.variant }} - name: package electron - linux if: startsWith(matrix.os, 'ubuntu') run: npm run package:linux:${{ matrix.variant }} - name: package electron - mac if: startsWith(matrix.os, 'mac') run: npm run package:mac:${{ matrix.variant }} - name: npm rebuild - mac if: startsWith(matrix.os, 'mac') run: npm rebuild - name: Mac installer if: startsWith(matrix.os, 'mac') run: npm run installer:mac:${{ matrix.variant }}  Replace the # Upload installers to github action section in package.yaml with the following code: - name: upload win-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'windows') with: name: ${{ format('win-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-setup.exe - name: upload mac-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'mac') with: name: ${{ format('mac-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}.dmg - name: upload linux-installer uses: actions/upload-artifact@master if: startsWith(matrix.os, 'ubuntu') with: name: ${{ format('linux-installer-{0}', github.event.inputs.setting) }} path: dist/installers/${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_x64.deb  Replace the # Upload installers to github release section in release.yaml with the following code: - name: Upload app to release - windows if: startsWith(matrix.os, 'windows') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-setup.exe asset_name: ${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-${{ matrix.setting }}-setup.exe tag: ${{ github.ref }} - name: Upload app to release - linux if: startsWith(matrix.os, 'ubuntu') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_x64.deb asset_name: ${{ matrix.variant }}_${{ steps.package_info.outputs.package_version }}_${{ matrix.setting }}_x64.deb tag: ${{ github.ref }} - name: Upload app to release - mac if: startsWith(matrix.os, 'mac') uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: dist/installers/${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}.dmg asset_name: ${{ matrix.variant }}-${{ steps.package_info.outputs.package_version }}-${{ matrix.setting }}.dmg tag: ${{ github.ref }}  ","version":"3.4.x","tagName":"h2"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/docs/quick_start","content":"","keywords":"javascript  jspsych","version":"3.4.x"},{"title":"Creating Your Task Repository​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#creating-your-task-repository","content":"The Honeycomb repository is a template and serves as the starting point for all tasks. Creating your repository from the template starts your project with the same directory structure and files as an existing repository. Go to the Honeycomb repository Click on Use this template and select Create a new repository. Enter the owner, name, and description of your repository and click on Create repository from template. note We recommend creating a public repository and leaving Include all branches unchecked Ensure the repository's workflow permissions are set to &quot;Read and write permissions&quot; Settings -&gt; Actions -&gt; General -&gt; Workflow permissions Additional details about template repositories can be found on the Github Docs. ","version":"3.4.x","tagName":"h2"},{"title":"Cloning the Repository​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#cloning-the-repository","content":"With the repository now setup it can be cloned onto your computer. Navigate to the repository on GitHub. Click the Code button and copy the URL Open a terminal and navigate to where you want the cloned directory WindowsmacOS Terminal.app cd 'path/to/directory'  Clone the repo with the following command Paste the URL you copied earlier git clone https://github.com/&lt;YOUR-USERNAME&gt;/&lt;YOUR-REPOSITORY&gt;  Navigate into the cloned repository The folder is the name of your repository cd &lt;YOUR-REPOSITORY&gt;  note Git can be downloaded here if it is not already on your system. Additional details and alternative methods for cloning a repository can be found on the Github Docs. ","version":"3.4.x","tagName":"h2"},{"title":"Installing Prerequisites​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#installing-prerequisites","content":"All of the needed programs for Honeycomb must be installed before we can develop our task. We will use a package manager to automatically install them. See Prerequisites for more information about these programs. ","version":"3.4.x","tagName":"h2"},{"title":"Initial Install​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#initial-install","content":"WindowsmacOS The most commonly used package manager on macOS is Homebrew. Paste the following command in a macOS Terminal and follow the prompts to install Homebrew. /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; Paste the following command and follow the prompts to install the listed programs: brew bundle Install Xcode (not available on Homebrew) xcode-select --install  note If you are running into issues after installing the packages, please restart your terminal and/or reboot your computer. This should resolve most issues. ","version":"3.4.x","tagName":"h3"},{"title":"Setting Up Node​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#setting-up-node","content":"NVM (Node Version Manager) is a tool for installing and using multiple versions on Node on your computer. It must first be installed: Install NVM WindowsmacOS curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash Copy the version number listed in .nvmrc. Install that version. nvm install &lt;VERSION&gt; Use the needed version. nvm use &lt;VERSION&gt; Set the current version as your default nvm alias default node note You can skip this step if you've already set a default node version in a different project. ","version":"3.4.x","tagName":"h3"},{"title":"Install Dependencies​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#install-dependencies","content":"There are many Node packages used by Honeycomb that also need to be installed. Node comes with its own package manager to install, update, and maintain these dependencies throughout the development lifecycle. Install Honeycomb's dependencies npm install  Certain Node dependencies are best installed globally. These tools will be available from the command line anywhere on your system. Install Honeycomb's global dependencies npm install -g electron firebase-tools dotenv-cli lint-staged  ","version":"3.4.x","tagName":"h2"},{"title":"Run the Task​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#run-the-task","content":"Run the task in development mode npm run dev  Running the task in development mode enables &quot;hot reloading&quot;: changes to the code will immediately be reflected in the app without needing to restart the server. tip The dev script runs Honeycomb on Electron without any environment variables. Check out the NPM Scripts page for more information on the available development environments. note Honeycomb ships with a modified version of the &quot;simple reaction time task&quot; from the jsPsych tutorial. In the next section we'll create a new task and tell Honeycomb to run it! ","version":"3.4.x","tagName":"h2"},{"title":"Edit the Task​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#edit-the-task","content":"Now that the project is up and running we can make our first changes to the code! info The quick start guide details a command line workflow for version control. If you are unfamiliar with Git, we recommend reading the linked page before proceeding. ","version":"3.4.x","tagName":"h2"},{"title":"1) Edit the Project Metadata​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#1-edit-the-project-metadata","content":"Create a new branch in a separate terminal Create the branch edit-package-json git checkout -b edit-package-json Open package.json and edit it to reflect your app: name is your task's name, generally this is the name of our repositorydescription should be rewritten to better match your taskauthor is your lab (or PIs) name, email, and websitehoneycombVersion is the number currently in the version fieldversion should then be reset to 1.0.0repository is the link the GitHub repository you created earlier. package.json { &quot;name&quot;: &quot;my-task&quot;, &quot;description&quot;: &quot;A custom task for the Honeycomb platform&quot;, &quot;author&quot;: { &quot;name&quot;: &quot;My Lab&quot;, &quot;email&quot;: &quot;example@domain.com&quot;, &quot;url&quot;: &quot;https://lab-web-page.com&quot; }, &quot;honeycombVersion&quot;: &quot;3.3.0&quot;, // Match what was in version! &quot;version&quot;: &quot;3.3.0&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;repository&quot;: &quot;https://github.com/my-username/my-repository&quot; }, Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;edit package.json with my task's information&quot; Create and merge a pull request to merge your changes into the main branch. Make sure the builds complete successfully before merging! ","version":"3.4.x","tagName":"h3"},{"title":"2) Add a file for the task​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#2-add-a-file-for-the-task","content":"Bring your branch up to date with the main branch Switch to the main branch git checkout main Bring changes from GitHub into your local repository git pull Create a new branch (replace task-name with the name of your task) Check out a new branch git checkout -b add-&lt;task-name&gt;-file Add a new file inside src/experiment/ with the same name as your task Save your changes and commit them to git: Add the new file to Git git add . Commit all changed files with a custom message git commit -a -m &quot;feat: adds file for the &lt;task name&gt; task&quot; Add a taskNameOptions object to the new file (replace taskName with the name of your task) taskName.js /** * Experiment-wide settings for jsPsych: https://www.jspsych.org/7.3/overview/experiment-options/ * Note that Honeycomb combines these with other options required for Honeycomb to operate correctly */ export const taskNameOptions = { // Called when every trial finishes on_trial_finish: function (data) { console.log(`Trial ${data.internal_node_id} just finished:`, data); }, // Called when the experiment finishes on_finish: function (data) { console.log(&quot;The experiment has finished:&quot;, data); // Reload the page for another run-through of the experiment window.location.reload(); }, }; Add a buildTaskNameFunction to the new file (replace TaskName with the name of your task) taskName.js /** * This timeline builds the example reaction time task from the jsPsych tutorial. * Take a look at how the code here compares to the jsPsych documentation! * See the jsPsych documentation for more: https://www.jspsych.org/7.3/tutorials/rt-task/ * * @param {Object} jsPsych The jsPsych instance being used to run the task * @returns {Object} A jsPsych timeline object */ export function buildTaskNameTimeline(jsPsych) {} Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;feat: adds taskNameOptions and buildTaskNameTimeline to taskName.js&quot; Edit src/experiment/index.js to use the new file src/experiment/index.js import { buildHoneycombTimeline, honeycombOptions } from &quot;./honeycomb&quot;; import { buildTaskNameTimeline, taskNameOptions } from &quot;./taskName&quot;; // ... export const jsPsychOptions = honeycombOptions; export const jsPsychOptions = taskNameOptions; // ... export function buildTimeline(jsPsych, studyID, participantID) { console.log( `Building timeline for participant ${participantID} on study ${studyID}` ); const timeline = buildHoneycombTimeline(jsPsych); const timeline = buildTaskNameTimeline(jsPsych); return timeline; } Run the format script to make sure the code is formatted correctly npm run format Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;fix: Use new task's file&quot; Create and merge a pull request to merge your changes into the main branch. Make sure the builds complete successfully before merging! ","version":"3.4.x","tagName":"h3"},{"title":"3) Add some trials to the task​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#3-add-some-trials-to-the-task","content":"Bring your branch up to date with the main branch Switch to the main branch git checkout main Bring changes from GitHub into your local repository git pull Create a new branch Bring changes from GitHub into your local repository git checkout -b add-start-procedure Add the start procedure to the buildTaskNameTimeline function in the file you created earlier taskName.js import { buildStartProcedure } from &quot;./procedures/startProcedure&quot;; // ... export function buildTaskNameTimeline(jsPsych) { // Build the trials that make up the start procedure const startProcedure = buildStartProcedure(jsPsych); const timeline = [startProcedure]; return timeline; } // ... Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;feat: adds startProcedure to the task&quot; Edit the text for the task's name src/config/language.json { &quot;name&quot;: &quot;taskName&quot; // ... } tip The text for the introduction trial is in src/config/language.json under the trials and introduction key. src/config/language.json { &quot;name&quot;: &quot;taskName&quot; // ... &quot;trials&quot;: { &quot;introduction&quot;: &quot;Welcome to the experiment. Press any key to begin.&quot; // ... }, // ... } Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;feat: Updates the language for the startProcedure of the task&quot; Add the end procedure to the buildTaskNameTimeline function in the file you created earlier taskName.js import { buildStartProcedure } from &quot;./procedures/startProcedure&quot;; import { buildEndProcedure } from &quot;./procedures/endProcedure&quot;; // ... export function buildTaskNameTimeline(jsPsych) { // Build the trials that make up the start procedure const startProcedure = buildStartProcedure(jsPsych); // Builds the trials that make up the end procedure const endProcedure = buildEndProcedure(jsPsych); const timeline = [startProcedure, endProcedure]; return timeline; } // ... tip The text for the conclusion trial is in src/config/language.json under the trials and conclusion key. src/config/language.json { &quot;name&quot;: &quot;taskName&quot; // ... &quot;trials&quot;: { // ... &quot;conclusion&quot;: &quot;Welcome to the experiment. Press any key to begin.&quot; }, } Run a format to make sure the code is formatted correctly npm run format Save your changes and commit them to git: Commit all changed files with a custom message git commit -a -m &quot;feat: adds endProcedure to the task&quot; Create and merge a pull request to merge your changes into the main branch. Make sure the builds complete successfully before merging! ","version":"3.4.x","tagName":"h3"},{"title":"Next Steps​","type":1,"pageTitle":"Quick Start","url":"/docs/quick_start#next-steps","content":"The Firebase page explains how to set up your task with Firebase.The Environment Variables page explains how to configure your task for deployment to multiple scenarios.The NPM Scripts page lists every script you can run and which environment they use. ","version":"3.4.x","tagName":"h2"}],"options":{"id":"default"}}